---
title: Librerías de Python
format:
  html:
    code-fold: false
jupyter: python3
---

## Introducción

Python es un lenguaje de programación muy popular, poderoso y versátil que cuenta con una amplia gama de librerías que ayudan a que la programación sea más fácil y eficiente. Pero,  **¿qué son las librerías?** La librerías son conjuntos de módulos que contienen funciones, clases y variables relacionadas, que permiten realizar tareas sin tener que escribir el código desde cero y este se puede reutilizar en múltiples programas y proyectos. 

Entre las librerías disponibles se encuentran las estándares, que se incluye con cada instalación de Python, y las de código abierto creadas por la gran comunidad de desarrolladores, que constantemente genera nuevas librerías y mejora las existentes. Por ello es aconsejable que, al momento de utilizarlas, se verifique si existe alguna actualización en las guías de usuario.

Asimismo, estas librerías se pueden clasificar según su aplicación y funcionalidad en: procesamiento de datos, visualización, aprendizaje automático, desarrollo web, procesamiento de lenguaje y de imágenes, entre otras. En este capítulo se analizarán tres de las librerías más reconocidas y ampliamente utilizadas de Python: **NumPy** y **Pandas** para procesamiento de datos y **Matplotlib**, para visualización.

### ¿Cómo se utilizan las librerías?

Para acceder a una librería y sus funciones, se debe instalar por única vez y luego, importar cada vez que la necesitemos:

-	La instalación se puede llevar a cabo desde el símbolo del sistema (o en inglés: “Command Prompt”), corriendo: `pip install –nombre_de_librería` o en el script de Google Colab, con el siguiente comando `! pip install –nombre_de_librería`


-	Para importarla, en la parte superior de nuestro código debemos correr `import –nombre_de_librería as –nombre_de_librería_corto`. El alias o el nombre corto de la librería se suele agregar para lograr una mayor legilibilidad del código, pero no es mandatorio.

## NumPy

NumPy es una librería de código abierto muy utilizada en el campo de la ciencia y la ingeniería. Permite trabajar con datos numéricos, matrices multidimensionales, funciones matemáticas y estadísticas avanzadas. 

Como ya se mencionó anteriormente, para utilizarse se debe instalar e importar. Por convención, se suele importar como: 

```{python}
import numpy as np
```

NumPy incorpora una estructura de datos propia llamados **arrays** que es similar a la lista de Python, pero puede almacenar y operar con datos de manera mucho más eficiente. **¡El procesamiento de los arrays es hasta 50 veces más rápido!** Esta diferencia de velocidad se debe, en parte, a que **los arrays contienen datos homogéneos**, a diferencia de las listas que pueden contener distintos tipos de datos dentro.

### ¿Qué es un **array**?

Un **array** es un conjunto de elementos del mismo tipo, donde cada uno de ellos posee una posición y esta, es única para cada elemento. Para comprenderlo, analicemos el siguiente ejemplo: si pensamos en una matriz, lo primero que nos viene a la mente es una tabla con valores ordenados en filas y columnas, donde una fila es la línea horizontal y una columna es la vertical. Es decir, una matriz es un conjunto de elementos que posee una posición o índice determinado determinado por la fila y la columna, por lo que sería un array.

También, es posible encontrar en la bibliografía el término **ndarray**, que es una abreviatura de "array N-dimensional", debido a que los arrays pueder ser de dimensión nula (0-D), unidimensional, bidimensional, tridimensional, etc, llamados comúnmente escalar, vector, matriz y tensor, respectivamente. En este capítulo se trabajará principalmente con vectores y matrices ya que consideramos que les será útil para aplicar los conocimientos de Numpy en otras materias.

#### ¿Cómo se crea un **array**?

Un array se crea usando la función `array()` a partir de listas o tuplas. Por ejemplo:

```{python}
a = np.array([1, 2, 3])
print(a)
```

También, se pueden crear arrays particulares, constituídos por ceros con `zeros()` o por unos con `ones()`:

```{python}
# Creo un array de ceros con dos elementos
a_ceros = np.zeros(2)
print(a_ceros)
```

```{python}
# Creo un array de unos con dos elementos
a_unos = np.ones(2)
print(a_unos)
```

Además, se pueden crear arrays con un rango de números, utilizando `arange()` o `linspace()`:

```{python}
# Creo un array con un rango que empieza en 2 hasta 9 y va de 2 en 2.
a_rango = np.arange(2, 9, 2)
print(a_rango)
```

```{python}
# Creo un array con un rango formado por 4 números, que empieza en 2 hasta 8 (incluídos). 
a_rango_2 = np.linspace(2, 8, num=4)
print(a_rango_2)
```

Finalmente, para crear arrays de más dimensiones, se utilizan varias listas:

```{python}
matriz = np.array([[1, 2, 3], [4, 5, 6]])

print(matriz)
```

#### Atributos de un array

Para caracterizar un array es necesario conocer sus dimensiones, utilizando `ndim`. De esta forma, se puede confirmar que el array llamado **matriz**, definido anteriormente, es bidimensional: 

```{python}
# Número de ejes o dimensiones de la matriz
matriz.ndim
```

Otra característica de interés es su forma o `shape`: para las matrices bidimensionales, se muestra una tupla (n, m) con el número de filas n y de columnas m:

```{python}
# (n = filas, m = columnas)
matriz.shape
```

```{python}
# Número total de elementos de la matriz: 2 filas x 3 columnas = 6 elementos
matriz.size
```

Al elemento de una matriz A que se encuentra en la **fila i-ésima y la columna j-ésima** se llama **aij**. De manera análoga, para acceder a un elemento de un array se debe indicar primero la posición de la fila y luego, de la columna:

```{python}
print('Elemento de la primera fila y segunda columna: ', matriz[0, 1])
```

O se puede elegir un rango de elementos en una fila o columna particular:

```{python}
print('Los elementos de la primera fila, columnas 0 y 1: ', matriz[0, 0:2])
```

```{python}
print('Los elementos de la segunda columna, filas 0 y 1: ', matriz[0:2, 1])
```

#### Modificar arrays 

De forma similar a lo aprendido con las listas de Python, se pueden modificar los arrays utilizando ciertas funciones. Para entender y aplicar las mismas, definamos un vector llamado a:

```{python}
a = np.array([2, 1, 5, 3, 7, 4, 6, 8])

print(a)
```

A este vector, se le puede modificar la forma: pasando de ser `(8,)` a `(4,2)`, por dar un ejemplo:

```{python}
a_reshape = a.reshape(2, 4) # 2 filas y 4 columnas

print(a_reshape)
```

También, se modría insertar una fila (`axis = 0`) o una columna (`axis = 1`) en una determinada posición. Por ejemplo:

```{python}
# Agregar fila de cincos en posición 1:
print(np.insert(a_reshape, 1, 5, axis=0))
```

```{python}
# Agregar columna de cincos en posición 1:
print(np.insert(a_reshape, 1, 5, axis=1))
```

O lo que es equivalente:

```{python}
# Agregar columna de cincos en posición 1:
print(np.insert(a_reshape, 1, [5, 5], axis=1))
```

::: {.callout-note}
#### **Observemos los parámetros** \
Note que a la función `insert()`, se le debe indicar: \
- el array que se desea modificar \
- la posición de la fila o columna que se desea agregar \
- los valores a insertar. **¡Ojo con las dimensiones!** Para el ejemplo anterior, a_reshape tenía 2 filas, por lo que se debe agregar una columna con 2 elementos o una fila con 4. \
- el eje que se agrega: una fila (axis = 0) o una columna (axis = 1) \
:::

También podríamos agregar una fila o una columna utilizando `append()` al final, como ocurría con las listas:

```{python}
# Agregar una última fila
a_modificada = np.append(a_reshape, [[1, 2, 3, 4]], axis=0)
print(a_modificada)
```

O eliminarlas con `delete()`

```{python}
# Eliminar la fila de la posición 2.
print(np.delete(a_modificada, 2, axis=0))
```

Finalmente, podemos concatenar arrays, como los siguientes:

```{python}
a = np.array([2, 1, 5, 3])
b = np.array([7, 4, 6, 8])

# Concatenar a y b:
c = np.concatenate((a, b))
print(c)
```

Y ordenar los elementos de un array como numérico o alfabético, ascendente o descendente.

```{python}
print(np.sort(c))
```

### Operaciones aritméticas utilizando **array**

Como se ha mencionado anteriormente, Numpy tiene un gran potencial para realizar operaciones, muy superior al de las listas de Python, gracias a la vectorización que es mucho más rápido que iterar sobre cada elementos. Por ejemplo, si quisieramos sumar dos listas de python necesitaríamos realizar un `for` y utilizar el método `zip():

```{python}
# Definir listas
a = [2, 1, 5, 3]
b = [7, 4, 6, 8]
c = []

# Sumar el primer elemento de a con el primero de b, el segundo elemento de a con el segundo de b y así sucesivamente
for i, j in zip(a, b):
  c.append(i + j)
print(c)
```

Utlizando las funciones de Numpy, esto ya no es más necesario:

```{python}
# add() para sumar elemento a elemento de a y b
c = np.add(a, b)
print(c)
```

Una vez aclarado esto, **¡A calcular!**

#### Operaciones básicas:

A continuación se muestra una lista con las operaciones básicas junto con sus operadores asociados, funciones y ejemplos.

| Operación | Operador | Función |
| --- | --- | --- |
| Suma | `+` | `add()` |
| Resta | `-` | `subtract()` |
| Multiplicación | `*` | `multiply()` |
| División | `/` | `divide()` |
| Potencia | `**` | `power()` |

Definimos los vectores a y b con los que operaremos y veremos ejemplos:

```{python}
a = np.array([1, 3, 5, 7])
b = np.array([1, 1, 2, 2])
```

- Suma:

```{python}
resultado_1 = a + b
print("Suma usando +:", resultado_1) 

resultado_2 = np.add(a, b)
print("Suma usando add():", resultado_2) 
```

- Resta:

```{python}
resultado_1 = a - b
print("Resta usando -:", resultado_1) 

resultado_2 = np.subtract(a, b)
print("Resta usando subtract():", resultado_2) 
```

- Multiplicación:

```{python}
resultado_1 = a * b
print("Multiplicación usando *:", resultado_1) 

resultado_2 = np.multiply(a, b)
print("Multiplicación usando multiply():", resultado_2) 
```

- División:

```{python}
resultado_1 = a / b
print("División usando /:", resultado_1) 

resultado_2 = np.divide(a, b)
print("División usando divide():", resultado_2) 
```

- Potencia:

```{python}
resultado_1 = a ** b
print("Potencia usando **:", resultado_1) 

resultado_2 = np.power(a, b)
print("Potencia usando power():", resultado_2) 
```

::: {.callout-note}
Note que si quisieramo operar con un vector b de elementos iguales, podríamos utilizar un escalar.
:::

```{python}
b = np.array([2, 2, 2, 2])

resultado_1 = a * b
print("Usando un vector b = [2, 2, 2, 2]:", resultado_1) 

resultado_2 = a * 2
print("Usando un escalar b = 2:", resultado_2) 
```

#### Logaritmo:

NumPy provee funciones para los logaritmos de base 2, 10 y e:

| Base | Función |
| --- | --- |
| 2 | `log2()` |
| 10 | `log10()` |
| e | `log()` |

Por ejemplo:

```{python}
# Ejemplo log2()
print("Logaritmo base 2:", np.log2([2, 4, 8, 16]))
# Ejemplo log10()
print("Logaritmo base 10:", np.log10([10, 100, 1000, 10000]))
# Ejemplo log()
print("Logaritmo base e:", np.log([1, np.e, np.e**2]))
```

::: {.callout-note}
Note que el número de Euler o número e es una constante incluída en NumPy como: `np.e`
:::

```{python}
np.e
```

#### Funciones trigonométricas:

A continuación, una lista con las funciones trigonométricas más utilizadas, que toman los valores en radianes:

| Función trigonométrica | Función |
| --- | --- |
| seno | `sin()` |
| coseno | `cos()` |
| tangente | `tan()` |
| arcoseno | `arcsin()` |
| arcocoseno | `arccos()` |
| arcotangente | `arctan()` |

Por ejemplo:

```{python}
# Ejemplo de seno
print("Seno de π / 2:", np.sin(np.pi / 2))

# Ejemplo de arcoseno
print(v np.arcsin(1))
```

```{python}
# Ejemplo de coseno
print("Coseno de π:", np.cos(np.pi))

# Ejemplo de arcocoseno
print("Arcoseno de -1:", np.arccos(-1))
```

```{python}
# Ejemplo de tangente:
print("Tangente de 0:", np.tan(0))

# Ejemplo de arcotangente:
print("Arcotangente de 0:", np.arctan(0))
```

::: {.callout-note}
Note que el número π es una constante incluída en NumPy como: `np.pi`
:::

```{python}
np.pi
```

Para convertir los radianes a grados y viceversa, se utiliza `deg2rad()` y `rad2deg()` respectivamente:

```{python}
print("De grados [90, 180, 270, 360] a radianes:", 
      np.deg2rad([90, 180, 270, 360]))

print("De radianes [π/2, π, 1.5*π, 2*π] a grados:", 
      np.rad2deg([np.pi/2, np.pi, 1.5*np.pi, 2*np.pi]))
```

#### Operaciones con matrices:

A continuación, una lista con las operaciones que les pueden ser de interés mientras estudian álgebra matricial:

| Función | Descripción |
| --- | --- |
| `dot()` | Producto vectorial |
| `transpose()` | Traspuesta |
| `linalg.inv()` | Inversa |
| `linalg.det()` | Determinante |

Definimos las matrices 1 y 2 con los que operaremos y veremos ejemplos:

```{python}
# Crear matrices
matriz_1 = np.array([[1, 3], [5, 7]])
matriz_2 = np.array([[2, 6], [4, 8]])
```

```{python}
print("Producto vectorial entre la matriz 1 y 2: \n", np.dot(matriz_1, matriz_2))
```

```{python}
print("Traspuesta de la matriz 1: \n", np.transpose(matriz_1))
```

```{python}
print("Inversa de la matriz 1: \n", np.linalg.inv(matriz_1))
```

```{python}
print("Determinante de la matriz 1: \n", np.linalg.det(matriz_1))
```

::: {.callout-note}
Note que así como existen constantes numéricas, existen las matrices particulares como las compuestas por ceros `np.zeros()`, por unos `np.ones()` y la matriz identidad `np.eyes`.
:::

```{python}
print("Matriz de identidad de 3x3: \n", np.eye(3))
```

#### Más operaciones útiles:

| Operaciones | Función | Descripción |
| --- | --- | --- |
| Máximo | `max()` | Valor máximo del array o del eje indicado |
| Mínimo | `min()` | Valor mínimo del array o del eje indicado |
| Suma | `sum()` | Suma de todos los elementos o del eje indicado |
| Promedio | `mean()` | Promedio de todos los elementos o del eje indicado |

Utilizando la matriz **data** como ejemplo:

```{python}
data = np.array([[1, 2], [5, 3], [4, 6]])
```

- Valor máximo

```{python}
print("Valor máximo de todo el array: ", data.max())
print("Valores máximos de cada columna: ", data.max(axis=0))
```

- Valor mínimo

```{python}
print("Valor mínimo de todo el array: ", data.min())
print("Valores mínimos de cada fila: ", data.min(axis=1))
```

- Suma de elementos:

```{python}
print("Suma de todos los elementos del array: ", data.sum())
print("Suma de los elementos de cada fila: ", data.sum(axis=1))
```

- Promedio:

```{python}
print("Promedio de todos los elementos del array: ", data.mean())
print("Promedio de los elementos de cada columna: ", data.mean(axis=0))
```

## Pandas

Pandas es una librería de código abierto, diseñada específicamente para la manipulación y el análisis de datos en Python. Es una herramienta poderosa que puede ayudar a los usuarios a limpiar, transformar y analizar datos de una manera rápida y eficiente.

Dado que se basa en la NumPy, luego de instalarse, se deben importar ambas librerías. Por convención, se suele importar como: 

```{python}
import pandas as pd
```

Pandas incorpora dos estructuras de datos llamados **Series** y  **DataFrame**.

### ¿Qué es una **Serie** y un **DataFrame**?

Una **serie** es un vector (unidimensional) capaz de contener cualquier tipo de dato, como por ejemplo, números enteros o decimales, strings, objetos de Python, etc.

Para crearlas, se puede partir de un escalar, una lista, un diccionario, etc. utilizando `pd.Serie()`:

```{python}
# Crear serie partiendo de una lista:
lista = [1, "a", 3.5]

pd.Series(lista)
```

Note que se ven dos líneas verticales de datos. A la derecha se observa una columna con los elementos de la lista antes creada, mientas que a la izquierda se encuentra el **índice**, formado por valores desde 0 a n-1, siendo n la cantidad de elementos. Este índice numérico es el predefinido, por lo que si se deseara uno particular, se puede establecer utilizando `index`.

El índice es de vital importancia ya que permite acceder a los elementos de la serie. Por ello, al establecer un índice en particular, su longitud debe ser acorde al número de elementos de la serie. De lo contrario, se mostrará un ValueError. 

```{python}
# Crear serie partiendo de una lista, indicando el índice
pd.Series(lista, index = ["x", "y", "z"])
```

En el caso de crear Series utilizando diccionarios, sus claves o keys pasan a formar el índice.

```{python}
# Crear serie partiendo de un diccionario:
diccionario = {"x": 1, "y": "a", "z": 3.5}

a = pd.Series(diccionario)
a
```

Como ya se debe estar imaginando, para acceder a un elemento de la serie, se debe indicar el valor del índice o la posición entre corchetes.

```{python}
# Acceder al elemento de índice x:
a["x"]
```

```{python}
# Acceder al elemento de posición 0:
a[0]
```

Otra propiedad interesante de las series (y de los DataFrames, como se verá a continuación) es la vectorización: así como los arrays, no requieren recorrer valor por valor en un for para realizar operaraciones. Por ejemplo:

```{python}
a + a
```

Por otro lado, un **DataFrame** es una estructura de datos tabular (bidimensional), compuesta por filas y columnas, que se asemeja a una hoja de cálculo de Excel.

Para crearlos, se utiliza `DataFrame()` y se ingresan diferentes estructuras como arrays, diccionarios, listas, series u otros dataframes. En el siguiente ejemplo, se crea un Dataframe partiendo de un diccionario **data** para las columnas y de una lista **label** para el índice:

```{python}
data = {'columna_1': ['a', 'b', 'c', 'd', 'e', 'f'],
        'columna_2': [2.5, 3, 0.5, None, 5, None],
        'columna_3': [1, 3, 2, 3, 2, 3]}

labels = ['a1', 'a2', 'a3', 'a4', 'a5', 'a6']

pd.DataFrame(data, index=labels)
```

#### Atributos y descripción de un Dataframe

A continuación, se observa una tabla con métodos que nos permiten conocer las características de un determinado DataFrame.

| Método | Descripción |
| --- | --- |
| `info()` | Brinda información del DataFrame como número de filas y columna, el número de valores no nulos y el tipo de datos por columnas y el uso de la memoria. |
| `shape` | Devuelve una tupla con el número de filas y columnas |
| `size` | Número de elementos |
| `columns` | Lista con los nombres de las columnas |
| `index` | Lista con los nombres de las filas |
| `dtypes` | Serie con los tipos de datos de las columnas |
| `head()` | Muestra las primeras filas |
| `tail()` | Muestra las últimas filas |
| `df.describe()` | Resume la información de las columnas numéricas |

Para ejemplificar los métodos y las funciones de Pandas, usaremos el **DataFrame df** definido en la siguiente línea de código. Recuerda que muchas de ellas pueden ser utilizadas también para Series.

```{python}
data = {'nombre': ['José Martínez', 'Rosa Díaz', 'Javier Garcíaz', 'Carmen López', 'Marisa Collado', 'Antonio Ruiz', 'Antonio Fernández', 
                   'Pilar González', 'Pedro Tenorio', 'Santiago Manzano', 'Macarena Álvarez', 'José Sanz', 'Miguel Gutiérrez', 'Carolina Moreno'],
        'edad': [18, 32, 24, 35, 46, 68, 51, 22, 35, 46, 53, 58, 27, 20],
        'sexo': ['H', 'M', 'H', 'M', 'M', 'H', 'H', 'M', 'H', 'H', 'M', 'H', 'H', 'M'],
        'peso': [85.0, 65.0, None, 65.0, 51.0, 66.0, 62.0, 60.0, 90.0, 75.0, 55.0, 78.0, 109.0, 61.0],
        'altura': [1.79, 1.73, 1.81, 1.7, 1.58, 1.74, 1.72, 1.66, 1.94, 1.85, 1.62, 1.87, 1.98, 1.77],
        'colesterol': [182.0, 232.0, 191.0, 200.0, 148.0, 249.0, 276.0, None, 241.0, 280.0, 262.0, 198.0, 210.0, 194.0]}

df = pd.DataFrame(data)
df
```

Con `info()` se puede ver:
- el índice en la primer línea, que es un rango de 0 a 13
- el número total de columnas en la segunda línea
- el uso de la memoria en la última
- una tabla con los nombres de las columnas en **Column**, la cantidad de valores no nulos en **Non-Null Count** y el tipo de dato en **Dtype** para cada una de ellas.

```{python}
df.info()
```

Note que utilizando `dtypes`, `columns` y `index` se obtiene parte de esta información:

```{python}
# Tipo de dato por columna
df.dtypes
```

```{python}
# Nombre de cada columna
df.columns
```

```{python}
# índice
df.index
```

La forma del DataFrame es de 14 filas y 6 columnas, por lo que contiene 84 elementos.

```{python}
# Forma del DataFrame (filas, columnas)
df.shape
```

```{python}
# Número de elementos del DataFrame
df.size
```

Asimismo, cuando no conocemos un DataFrame, puede ser importante ver los primeros 5 valores con `head()` y/o los últimos con `tail()`. Si se quisiera observar un número determinado de filas, sólo hay que especificarlo, por ejemplo:

```{python}
# Mostrar las primeras 3 filas.
df.head(3)
```

```{python}
# Mostrar las últimas 5 filas.
df.tail()
```

Por otro lado, `describe()` devuelve un resumen descriptivo de las columnas de valores numéricos, como "edad", "peso", "altura" y "colesterol".

```{python}
df.describe()
```

Estos métricas podrían obtenerse utilizando las funciones determinadas, como:
- `count()`: contabiliza los valores no nulos
- `mean()`: promedio
- `min()`: valor mínimo
- `max()`: valor máximo

Por ejemplo:

```{python}
df.count()
```

Finalmente, como ocurre con las series, **para acceder a los elementos de un DataFrame se puede indicar la posición o el nombre de la fila o columna**.

Para acceder a una **fila** en particular, utilizamos `iloc[]` con un entero, una lita o rango de números que indican la posición o con `loc[]` indicando el valor del índice. 

```{python}
# Mostrar la fila de posición 0:
df.iloc[0]
```

```{python}
# Mostrar la fila de posición 0:
df.iloc[[0]]
```

```{python}
# Mostrar las filas de posición 0 y 3:
df.iloc[[0, 3]]
```

```{python}
# Mostrar las filas de posiciones entre 0 hasta 3:
df.iloc[:3]
```

```{python}
# Equivalente a df.iloc[:3]:
df.head(3)
```

```{python}
# Mostar la fila cuyo valor del índice es 0:
df.loc[0]
```

Por otro lado, para acceder a una **columna** se puede utilizar los nombres de la mismas con `DataFrame[columna]` o su equivalente `DataFrame.columna`.

```{python}
# Mostrar la columna "nombre"
df['nombre'] # o df.nombre
```

```{python}
# Mostrar más de una columna: "nombre" y "edad":
df[['nombre', 'edad']]
```

Finalmente, se puede utilizar `loc[filas, columnas]` que devuelve un DataFrame con los elemento que se encuentra en las filas con los nombres de la lista filas y las columnas con los nombres de la lista columna.

```{python}
# Mostrar la filas de índice 0, 1, 2, 3, columnas "nombre" y "edad"
df.loc[:3, ['nombre', 'edad']]
```

```{python}
# O su equivalente:
df.loc[df.index[[0, 1, 2, 3]], ['nombre', 'edad']]
```

#### Modificar un Dataframe

A la hora de modificar un DataFrame puede ser que querramos cambiar la estructura del mismo, como los nombres de las columnas y de los índices, agregar una nueva filas o columna o reemplazar un dato en una determinada posición. A continuación, se enumeran distintos métodos para llevar a cabo estos cambios.

| Método | Descripción |
| --- | --- |
| `set_index()` | Convierte una determinada columna en el nuevo índice. |
| `reset_index()` | Reestablece el índice predefinido |
| `rename()` | Renombra las columnas |
| `insert()` | Agrega columnas |
| `loc[]` | Agrega fila en un dado índice |
| `drop()` | Elimina columnas y filas |
| `loc[]` | Modifica un valor particular dado un índice y una columna |
| `map()` | Busca un valor dado en una columna y lo reemplaza |
| `replace()` | Reemplaza un valor dado en una columna |

Por ejemplo, utilizando `set_index()` podemos transformar a la columna "nombre" en el nuevo índice, y para volver a tener el predefinido, usando `reset_index()`.

```{python}
df = df.set_index(keys = "nombre")
df.head()
```

```{python}
df = df.reset_index()
df.head()
```

Para renombrar una columna, se utiliza `rename(columns={"nombre_columna": "nuevo_nombre_columna"})` 

```{python}
# Reemplazo "nombre" por "nombre y apellido"
df = df.rename(columns={"nombre": "nombre y apellido"})
df.head()
```

Para agregar una nueva columna, existe el método `insert()`, que requiere indicar a posición de la nueva columna, el nombre de la nueva columna, y los valores de la misma. Para ello, creamos una lista llamada **direccion** con 14 valores, para cada una de las personas del DataFrame.

```{python}
# Valores de la nueva columna
direccion = ["CABA", "Bs As", "Bs As", "Bs As", "CABA", "Bs As", "CABA", "CABA", "CABA", "CABA", "CABA", "Bs As", "CABA", "CABA"]

# Insertar la columna "direccion" en la posición 3:
df.insert(3, "direccion", direccion)
df.head()
```

Para agregar una nueva fila, e utiliza el ya conocido `loc[]`, que requiere indicar el índice y los valores de la misma. Para ello, creamos una lista llamada **nueva_fila** con valores para cada columna del DataFrame.

```{python}
# Valores de la nueva fila
nueva_fila = ['Carlos Rivas', 28, 'H', "Bs As", 89.0, 1.78, 245.0]

# Insertar la fila 14
df.loc[14] = nueva_fila
df.tail()
```

Para eliminar una columna `(axis=1)` o fila `(axis=0)`, se utiliza `drop()`:

```{python}
# Elimino columna "direccion", equivalente a del df["direccion"]
df = df.drop('direccion', axis=1)  
df.head()
```

```{python}
# Elimino fila 14
df = df.drop(14, axis=0) 
df.tail()
```

::: {.callout-tip}
##### **Agregar columnas con operaciones** 

Como se ha mencionado anteriormente, gracias a la vectorización se puedem agregar columnas partiendo de operaciones entre columnas existentes en el DataFrame

:::

Por ejemplo, suponga que queremos ingresar una columna el índice de masa corporal de las personas, que se calcula de la siguiente manera: 

$$
IMC = \frac{Peso}{Altura^2}$$

```{python}
# Crear la columna "IMC"
df["IMC"] = df["peso"] / df["altura"]**2
df.head()
```

De manera análoga, se puede crear la columna **dirección** sin utilizar `insert()`:

```{python}
df["direccion"] = direccion
df.head()
```

Finalmente, para cambiar un valor determinado, como por ejemplo el peso de Javier García en la tercer fila:

```{python}
df.loc[2, 'peso'] = 92
df.head()
```

Para transformar los valores de una columna entera, podemos utilizar `map()` pasando un diccionario del estilo `{valor_viejo: valor_nuevo}`. Por ejemplo, modificar la columna "sexo" reemplazando "H" por "M" y "M" por "F":

```{python}
df['sexo'] = df['sexo'].map({'H': 'M', 'M': 'F'})
df.head()
```

Otra manera sería utilizando `replace()`, como en la columna "direccion" donde se modificó "Bs As" por "Buenos Aires".

```{python}
df['direccion'] = df['direccion'].replace('Bs As', 'Buenos Aires')
df.head()
```

#### Filtrar un Dataframe

Para filtrar los elementos de un DataFrame se suelen utilizar condiciones lógicas. Por ejemplo:

```{python}
# Seleccionar aquellas personas menores de 40 años:
df[df['edad'] < 40]
```

Cuando se requieren múltiples condiciones, se puede adicionar usando símbolos como `&` para **intersecciones** y `|` para **uniones**. Por ejemplo:

```{python}
# Seleccionar aquellas personas de sexo femenino y menores de 40 años:
df[(df['edad'] < 40) & (df['sexo'] == 'F')]
```

```{python}
# Seleccionar aquellas personas cuyo peso es 60kg o 90kg:
df[(df['peso'] == 60.0) | (df['peso'] == 90.0)]
```

Cuando se desea filtrar con un cierto rango, se pueden utilizar las condiciones antes mencionadas o la función `between()`.

```{python}
# Equivalente a df[(df['edad'] > 25) & (df['edad'] < 40)]
df[df['edad'].between(25, 40)]
```

#### Otros métodos útiles

A continuación, se muestra una lista con otros métodos muy útiles al analizar datos: 

| Método | Descripción |
| --- | --- |
| `sort_values(by, ascending)` | Ordena el DataFrame considerando los valores de una columna |
| `value_counts()` | Indica los valores únicos de una determinada columna y el número de veces que aparece en el DataFrame |
| `groupby()` | Agrupar las filas según ciertos valores de una columna |




Para utilizar la función `sort_values(by, ascending)`, se debe indicar en el parámetro `by` una lista con las columnas consideradas para ordenar el DataFrame y en `ascending`, `True` para orden creciente y `False` para decreciente.

```{python}
df.sort_values(by=['peso', 'edad'], ascending=[False, True])
```

Utilizando `value_counts()` podemos, por ejemplo, establecer la cantidad de pesonas de sexo F y M:

```{python}
df['sexo'].value_counts()
```

Finalmente con `groupby()` se pueden agrupar las filas del DataFrame. Dado el siguiente ejemplo:

```{python}
df.groupby(['sexo'])['edad'].agg(np.mean)
```

**¿Qué realizamos con el código anterior?**
- Se agrupa por "sexo" con `groupby(['sexo'])`, obteniéndose dos grupos: "M" y "F".
- Se indican las columnas cuyos valores se desean ver agrupadas, en este caso, `['edad']`.
- Con `agg()` se establece la operación a realizar con los valores de la columna "edad", para cada grupo. En este caso, se calcula el promedio con `np.mean`

**Es decir, se está calculandos el promedio de edad por sexo.**

Veamos otro ejemplo:

```{python}
df.groupby(['sexo', 'direccion']).agg({'colesterol': [np.max, np.min], 'peso': [np.mean]})
```

**En este caso se agrupa por sexo y dirección, y se informa para cada grupo el valor máximo y mínimo de colesterol y el promedio del peso de cada uno.**

Finalmente las filas que contienen datos faltantes, es decir `NaN`, pueden ser identificados usando la función `isnull()`. Esta devuelve `True` si el valor de la columna es nulo o NaN. Por ejemplo:

```{python}
df['IMC'].isnull()
```

Para visualizar aquella línea donde el índice de masa corporal es nulo, filtramos:

```{python}
df[df['IMC'].isnull() == True]
```

