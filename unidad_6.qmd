---
title: Bibliotecas de Python
format:
  html:
    code-fold: false
jupyter: python3
---

## Introducción

Python es un lenguaje de programación muy popular, poderoso y versátil que cuenta con una amplia gama de bibliotecas que ayudan a que la programación sea más fácil y eficiente. Pero,  **¿qué son las bibliotecas?** La bibliotecas son conjuntos de módulos que contienen funciones, clases y variables relacionadas, que permiten realizar tareas sin tener que escribir el código desde cero y este se puede reutilizar en múltiples programas y proyectos. 

Entre las bibliotecas disponibles se encuentran las estándares, que se incluye con cada instalación de Python, y las de código abierto creadas por la gran comunidad de desarrolladores, que constantemente genera nuevas bibliotecas y mejora las existentes. Por ello es aconsejable que, al momento de utilizarlas, se verifique si existe alguna actualización en las guías de usuario.

Asimismo, estas bibliotecas se pueden clasificar según su aplicación y funcionalidad en: procesamiento de datos, visualización, aprendizaje automático, desarrollo web, procesamiento de lenguaje y de imágenes, entre otras. En este capítulo se analizarán tres de las bibliotecas más reconocidas y ampliamente utilizadas de Python: **NumPy** y **Pandas** para procesamiento de datos y **Matplotlib**, para visualización.

### ¿Cómo se utilizan las bibliotecas?

Para acceder a una biblioteca y sus funciones, se debe instalar por única vez y luego, importar cada vez que la necesitemos.

En la parte superior de nuestro código debemos correr `import {nombre_de_biblioteca} as {nombre_corto_de_biblioteca}`. El alias o nombre corto de la biblioteca se suele agregar para lograr una mayor legilibilidad del código, pero no es mandatorio.

```python
import numpy as np
```

:::{.callout-note collapse="true}
En nuestro caso, la instalación no es necesaria ya que vamos a utilizar Google Colab o Replit, pero en caso de usar otro IDE (como por ejemplo, Visual Studio Code), se realiza desde el símbolo del sistema (o en inglés: “Command Prompt”, o terminal o consola), corriendo: `pip install –nombre_de_biblioteca`. 
:::

## NumPy

NumPy es una biblioteca de código abierto muy utilizada en el campo de la ciencia y la ingeniería. Permite trabajar con datos numéricos, matrices multidimensionales, funciones matemáticas y estadísticas avanzadas. 

Como ya se mencionó anteriormente, para utilizarse se debe instalar e importar. Por convención, se suele importar como: 

```{python}
import numpy as np
```

NumPy incorpora una estructura de datos propia llamados **arrays** que es similar a la lista de Python, pero puede almacenar y operar con datos de manera mucho más eficiente: **el procesamiento de los arrays es hasta 50 veces más rápido**. Esta diferencia de velocidad se debe, en parte, a que **los arrays contienen datos homogéneos**, a diferencia de las listas que pueden contener distintos tipos de datos dentro.

### **Arrays**

Un **array** es un conjunto de elementos del mismo tipo, donde cada uno de ellos posee una posición y esta es única para cada elemento. Como dijimos arriba, en Python vimos las listas, que es lo más parecido a un Array.

Analicemos el siguiente ejemplo: si pensamos en una matriz, lo primero que nos viene a la mente es una tabla con valores ordenados en filas y columnas, donde una fila es la línea horizontal y una columna es la vertical. Es decir, una matriz es un conjunto de elementos que posee una posición o índice determinado determinado por la fila y la columna, por lo que sería un array.

En este capítulo se trabajará principalmente con vectores y matrices ya que consideramos que les será útil para aplicar los conocimientos de Numpy en otras materias.

#### Creación de un Array

Un array se crea usando la función `array()` a partir de listas o tuplas. Por ejemplo:

```{python}
a = np.array([1, 2, 3])
print(a)
```

También, se pueden crear arrays particulares, constituídos por ceros con `zeros()` o por unos con `ones()`:

```{python}
# Creo un array de ceros con dos elementos
a_ceros = np.zeros(2)
print(a_ceros)
```

```{python}
# Creo un array de unos con dos elementos
a_unos = np.ones(2)
print(a_unos)
```

Además, se pueden crear arrays con un rango de números, utilizando `arange()` o `linspace()`:

```{python}
# Creo un array con un rango que empieza en 2 hasta 9 y va de 2 en 2.
a_rango = np.arange(2, 9, 2)
print(a_rango)
```

```{python}
# Creo un array con un rango formado por 4 números
# que empieza en 2 hasta 10 (incluídos). 
a_rango_2 = np.linspace(2, 10, num=4)
print(a_rango_2)
```
Esto es muy parecido a los rangos que ya vimos en Python, con la sutil diferencia de que el `final` del rango en este caso **sí se icnluye**.

Finalmente, para crear arrays de más dimensiones, se utilizan varias listas:

```{python}
matriz = np.array([[1, 2, 3], [4, 5, 6]])

print(matriz)
```

#### Atributos de un array

#### Dimensión
Para caracterizar un array es necesario conocer sus dimensiones, utilizando `ndim`. De esta forma, se puede confirmar que el array llamado **matriz**, definido anteriormente, es bidimensional: 

```{python}
# Número de ejes o dimensiones de la matriz
matriz.ndim
```

#### Forma
Otra característica de interés es su forma o `shape`: para las matrices bidimensionales, se muestra una tupla (n, m) con el número de filas n y de columnas m:

```{python}
# (n = filas, m = columnas)
matriz.shape
```

#### Tamaño
El tamaño de un array es el número total de elementos que contiene, y se obtiene con `size`:
```{python}
# Número total de elementos de la matriz: 2 filas x 3 columnas = 6 elementos
matriz.size
```

#### Posiciones
Al elemento de una matriz A que se encuentra en la **fila i-ésima y la columna j-ésima** se llama $a_{ij}$. Así, para acceder a un elemento de un array se debe indicar primero la posición de la fila y luego, de la columna:

```{python}
print('Elemento de la primera fila y segunda columna: ', matriz[0, 1])
```

Nótese la diferencia con las matrices (listas de listas) de Python, donde se accedía a un elemento por separado, primero a la fila y luego a la columna: `matriz[0][1]`.

También se puede elegir un rango de elementos en una fila o columna particular:

```{python}
print('Los elementos de la primera fila, columnas 0 y 1: ', matriz[0, 0:2])
```

```{python}
print('Los elementos de la segunda columna, filas 0 y 1: ', matriz[0:2, 1])
```

#### Modificar arrays 

De forma similar a lo aprendido con las listas de Python, se pueden modificar los arrays utilizando ciertas funciones. Para entender y aplicar las mismas, definamos un vector llamado a:

```{python}
a = np.array([2, 1, 5, 3, 7, 4, 6, 8])

print(a)
```

##### Reshape
A este vector, se le puede modificar la forma: pasando de ser `(8,)` a `(4,2)`, por dar un ejemplo:

```{python}
a_reshape = a.reshape(2, 4) # 2 filas y 4 columnas

print(a_reshape)
```

##### Insert

También, se modría insertar una fila (`axis = 0`) o una columna (`axis = 1`) en una determinada posición. Por ejemplo:

```{python}
# Agregar fila de cincos en posición 1:
print(np.insert(a_reshape, 1, 5, axis=0))
```

A la función `insert()`, se le debe indicar: \

- El array que se desea modificar \
- La posición de la fila o columna que se desea agregar \
- Los valores a insertar. **¡Ojo con las dimensiones!** Para el ejemplo anterior, a_reshape tenía 2 filas, por lo que se debe agregar una columna con 2 elementos o una fila con 4. \
- El eje que se agrega: una fila (axis = 0) o una columna (axis = 1) \

```{python}
# Agregar columna de cincos en posición 1:
print(np.insert(a_reshape, 1, 5, axis=1))
```

O lo que es equivalente:

```{python}
# Agregar columna de cincos en posición 1:
print(np.insert(a_reshape, 1, [5, 5], axis=1))
```

##### Append y Delete

También podríamos agregar una fila o una columna utilizando `append()` al final, como ocurría con las listas:

```{python}
# Agregar una última fila
a_modificada = np.append(a_reshape, [[1, 2, 3, 4]], axis=0)
print(a_modificada)
```

O eliminarlas con `delete()`

```{python}
# Eliminar la fila de la posición 2.
print(np.delete(a_modificada, 2, axis=0))
```

##### Concatenate y Sort

Finalmente, podemos concatenar arrays, como los siguientes:

```{python}
a = np.array([2, 1, 5, 3])
b = np.array([7, 4, 6, 8])

# Concatenar a y b:
c = np.concatenate((a, b))
print(c)
```

Y ordenar los elementos de un array como numérico o alfabético, ascendente o descendente.

```{python}
print(np.sort(c))
```

### Operaciones aritméticas utilizando **array**

Como se ha mencionado anteriormente, Numpy tiene un gran potencial para realizar operaciones, muy superior al de las listas de Python. Por ejemplo, si quisieramos sumar dos listas de python necesitaríamos realizar un `for`:

```{python}
# Definir listas
a = [2, 1, 5, 3]
b = [7, 4, 6, 8]
c = []

# Sumar el primer elemento de a con el primero de b, el segundo elemento de a con el segundo de b y así sucesivamente
for i in range(len(a)):
  c.append(a[i] + b[i])
print(c)
```

Utlizando las funciones de Numpy, esto ya no es más necesario:

```{python}
# add() para sumar elemento a elemento de a y b
c = np.add(a, b)
print(c)
```

También podemos realizar otras operaciones, como la resta, multiplicación y división. Usar un arreglo dentro de una ecuación nos devuelve otro arreglo, donde cada elemento es el resultado de aplicar la operación a los elementos correspondientes de los arreglos originales.

```{python}
x = np.array([0,  1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
y = 3 * x + 2
print(y)
```

De esta forma, podemos realizar operaciones aritméticas con arrays de Numpy de forma muy sencilla y rápida. Antes, en Python, para realizar estas operaciones debíamos recurrir a un ciclo `for` o a el uso de `map`. Numpy se ocupa de ahorrarnos el trabajo y calcular, para cada elemento del array, el resultado.

Además, tenemos operaciones básicas que vienen predefinidas por Numpy. Las vamos a ver a continuación.

#### Operaciones básicas:

A continuación se muestra una lista con las operaciones básicas junto con sus operadores asociados, funciones y ejemplos.

| Operación | Operador | Función |
| --- | --- | --- |
| Suma | `+` | `add()` |
| Resta | `-` | `subtract()` |
| Multiplicación | `*` | `multiply()` |
| División | `/` | `divide()` |
| Potencia | `**` | `power()` |

Definimos los vectores a y b con los que operaremos y veremos ejemplos:

```{python}
a = np.array([1, 3, 5, 7])
b = np.array([1, 1, 2, 2])
```

- Suma:

```{python}
resultado_1 = a + b
print("Suma usando +:", resultado_1) 

resultado_2 = np.add(a, b)
print("Suma usando add():", resultado_2) 
```

- Resta:

```{python}
resultado_1 = a - b
print("Resta usando -:", resultado_1) 

resultado_2 = np.subtract(a, b)
print("Resta usando subtract():", resultado_2) 
```

- Multiplicación:

```{python}
resultado_1 = a * b
print("Multiplicación usando *:", resultado_1) 

resultado_2 = np.multiply(a, b)
print("Multiplicación usando multiply():", resultado_2) 
```

- División:

```{python}
resultado_1 = a / b
print("División usando /:", resultado_1) 

resultado_2 = np.divide(a, b)
print("División usando divide():", resultado_2) 
```

- Potencia:

```{python}
resultado_1 = a ** b
print("Potencia usando **:", resultado_1) 

resultado_2 = np.power(a, b)
print("Potencia usando power():", resultado_2) 
```

::: {.callout-note}
Note que si quisieramos operar con un vector `b` de elementos iguales, podríamos utilizar un escalar.
:::

```{python}
b = np.array([2, 2, 2, 2])

resultado_1 = a * b
print("Usando un vector b = [2, 2, 2, 2]:", resultado_1) 

resultado_2 = a * 2
print("Usando un escalar b = 2:", resultado_2) 
```

#### Logaritmo:

NumPy provee funciones para los logaritmos de base 2, 10 y e:

| Base | Función |
| --- | --- |
| 2 | `log2()` |
| 10 | `log10()` |
| e | `log()` |

Por ejemplo:

```{python}
# Ejemplo log2()
print("Logaritmo base 2:", np.log2([2, 4, 8, 16]))
# Ejemplo log10()
print("Logaritmo base 10:", np.log10([10, 100, 1000, 10000]))
# Ejemplo log()
print("Logaritmo base e:", np.log([1, np.e, np.e**2]))
```

::: {.callout-note}
Note que el número de Euler o número e es una constante incluída en NumPy como: `np.e`
:::

```{python}
np.e
```

#### Funciones trigonométricas:

A continuación, una lista con las funciones trigonométricas más utilizadas, que toman los valores en radianes:

| Función trigonométrica | Función |
| --- | --- |
| seno | `sin()` |
| coseno | `cos()` |
| tangente | `tan()` |
| arcoseno | `arcsin()` |
| arcocoseno | `arccos()` |
| arcotangente | `arctan()` |

Por ejemplo:

```{python}
# Ejemplo de seno
print("Seno de π / 2:", np.sin(np.pi / 2))

# Ejemplo de arcoseno
print(np.arcsin(1))
```

```{python}
# Ejemplo de coseno
print("Coseno de π:", np.cos(np.pi))

# Ejemplo de arcocoseno
print("Arcoseno de -1:", np.arccos(-1))
```

```{python}
# Ejemplo de tangente:
print("Tangente de 0:", np.tan(0))

# Ejemplo de arcotangente:
print("Arcotangente de 0:", np.arctan(0))
```

::: {.callout-note}
Note que el número π es una constante incluída en NumPy como: `np.pi`
:::

```{python}
np.pi
```

Para convertir los radianes a grados y viceversa, se utiliza `deg2rad()` y `rad2deg()` respectivamente:

```{python}
print("De grados [90, 180, 270, 360] a radianes:", 
      np.deg2rad([90, 180, 270, 360]))

print("De radianes [π/2, π, 1.5*π, 2*π] a grados:", 
      np.rad2deg([np.pi/2, np.pi, 1.5*np.pi, 2*np.pi]))
```

#### Operaciones con matrices:

A continuación, una lista con las operaciones que les pueden ser de interés mientras estudian álgebra matricial:

| Función | Descripción | Comentario |
| --- | --- | --- |
| `dot()` | Producto escalar | Se utiliza para obtener el producto escalar entre dos vectores. El resultado es un número. |
| `dot()` | Producto vectorial | También se utiliza para multiplicar matrices. El resultado es una matriz |
| `transpose()` | Traspuesta | Cambia las filas por las columnas y viceversa |
| `linalg.inv()` | Inversa | Inversa de una matriz |
| `linalg.det()` | Determinante | Determinante de una matriz |
| `eye()` | Matriz identidad | Matriz cuadrada con unos en la diagonal principal y ceros en el resto |

Definimos los arreglos 1 y 2, y matrices 1 y 2 con los que operaremos y veremos ejemplos:

```{python}
# Crear arreglos
arreglo_1 = np.array([1, 2])
arreglo_2 = np.array([3, 4])

# Crear matrices
matriz_1 = np.array([[1, 3], [5, 7]])
matriz_2 = np.array([[2, 6], [4, 8]])
```

```{python}
print("Producto escalar entre el array 1 y 2: \n", np.dot(arreglo_1, arreglo_2))
```

```{python}
print("Producto vectorial entre la matriz 1 y 2: \n", np.dot(matriz_1, matriz_2))
```

```{python}
print("Traspuesta de la matriz 1: \n", np.transpose(matriz_1))
```

```{python}
print("Inversa de la matriz 1: \n", np.linalg.inv(matriz_1))
```

```{python}
print("Determinante de la matriz 1: \n", np.linalg.det(matriz_1))
```

::: {.callout-note}
Note que así como existen constantes numéricas, existen las matrices particulares como las compuestas por ceros `np.zeros()`, por unos `np.ones()` y la matriz identidad `np.eyes`.
:::

```{python}
print("Matriz de identidad de 3x3: \n", np.eye(3))
```

#### Más operaciones útiles:

| Operaciones | Función | Descripción |
| --- | --- | --- |
| Máximo | `max()` | Valor máximo del array o del eje indicado |
| Mínimo | `min()` | Valor mínimo del array o del eje indicado |
| Suma | `sum()` | Suma de todos los elementos o del eje indicado |
| Promedio | `mean()` | Promedio de todos los elementos o del eje indicado |

Utilizando la matriz **data** como ejemplo:

```{python}
data = np.array([[1, 2], [5, 3], [4, 6]])
```

- Valor máximo

```{python}
print("Valor máximo de todo el array: ", data.max())
print("Valores máximos de cada columna: ", data.max(axis=0))
```

- Valor mínimo

```{python}
print("Valor mínimo de todo el array: ", data.min())
print("Valores mínimos de cada fila: ", data.min(axis=1))
```

- Suma de elementos:

```{python}
print("Suma de todos los elementos del array: ", data.sum())
print("Suma de los elementos de cada fila: ", data.sum(axis=1))
```

- Promedio:

```{python}
print("Promedio de todos los elementos del array: ", data.mean())
print("Promedio de los elementos de cada columna: ", data.mean(axis=0))
```

::: {.callout-note}
Numpy te va a ser muy útil cuando curses materias como Análisis Matemático, Álgebra, Física, Estadística, entre otras. Te va a permitir realizar operaciones de manera rápida y eficiente, y te va a ayudar a entender mejor los conceptos.
:::

## Pandas

Pandas es una biblioteca de código abierto diseñada específicamente para la manipulación y el análisis de datos en Python. Es una herramienta poderosa que puede ayudar a los usuarios a limpiar, transformar y analizar datos de una manera rápida y eficiente.

Al igual que Numpy, se debe importar. Por convención: 

```{python}
import pandas as pd
```

Los datos a trabajar en Pandas van a tener, en general, una forma muy similar a las tablas:

![Esquema de figuras y axes](./imgs/unidad_6/pandas.png)

Como Pandas es una biblioteca un poco más pesada, **no vamos a estar trabajando en Replit**, sino que vamos a usar <a href="https://colab.research.google.com/" ocasion="_blank">Google Colab</a>.

### Cómo usar Google Colab

Al abrir Google Colab por primera vez, vamos a ver lo siguiente:

![Inicio en Google Colab](./imgs/unidad_6/google_colab1.png)

Vamos entonces a hacer click en "New Notebook", y se va a abrir un archivo nuevo, con extensión `.ipynb` (que es la extensión de un archivo del tipo IPython Notebook). Vamos a cambiarle el nombre de 'Untitled0' a 'Unidad_6_pandas' o el nombre que prefieran.

![Archivo nuevo](./imgs/unidad_6/google_colab2.png)

#### Celdas de Código

Colab es muy similar a Replit, ya que vamos a poder correr código. La diferencia es que Colab se divide en celdas individuales: cada celda es un bloque de código que se puede correr por separado. Para agregar una celda nueva, se hace click en el botón de "+ Code" que aparece en la parte superior izquierda de la celda.
Para correr la celda, se hace click en el botón de "play" que aparece a la izquierda de la celda. El output de la celda va a aparecer debajo de la misma.

![Ejecución de una celda de código](./imgs/unidad_6/google_colab3.png)

Si tenemos varias celdas con código, podemos correrlas todas juntas haciendo click en "Runtime" en el menú superior y luego en "Run all". Cada celda de código va a tener su propio output debajo de ella. 

![Ejecución simultánea de dos celdas de código](./imgs/unidad_6/google_colab4.png)

Si tenemos variables o imports definidos en otra celda y no la ejecutamos, al intentar usarla nos va a dar error. Es importante entonces o correr todas las celdas, o que cada celda tenga la información necesaria para poder correrse de forma independiente. Acá vemos cómo, al querer ejecutar sólo la segunda celda, nos da error porque la variable `saludo` está definida en la celda anterior (que no se ejecutó).

![](./imgs/unidad_6/google_colab5.png)

Las celdas, además, no necesitan del uso de `print` si la última linea corresponde a un elemento. Entonces, podemos hacer algo así, y aún así ver el contenido de esa variable en el output. Esta es una diferencia con Replit que vamos a ver muy seguido, porque nos permite ver de mejor forma los elementos de Pandas (a diferencia de con el uso de print).

![](./imgs/unidad_6/google_colab6.png)

#### Celdas de Texto

Así también como podemos agregar celdas de código, podemos agregar celdas de texto. Para eso, hacemos click en el botón de "+ Text" que aparece en la parte superior izquierda de la celda. Dentro podemos escribir texto con formato e incluso agregar imágenes. 

![](./imgs/unidad_6/google_colab7.png)

#### Opciones de Celdas
Para reordenar, eliminar o copiar celdas, al seleccionar una celda aparece un menú a la derecha con distintos íconos. Podemos usar estas opciones para realizar estas distintas acciones.

![](./imgs/unidad_6/google_colab8.png)

#### Beneficios de usar Google Colab

- Google Colab tiene una mejor interfaz para usar Pandas, mostrando el output en forma de tablas.
- Permite importar datos de Google Drive
- Permite compartir el código con otras personas, de tal forma que todas ellas puedan editar un mismo archivo
- Permite guardar los archivos en Google Drive, con guardado automático de cambios
- Permite exportar el archivo en distintos formatos, como PDF, HTML, etc.
- Permite intercalar código ejecutable con texto explicativo, lo que lo hace ideal para la creación de informes, presentaciones, o tutoriales.

Para lo que queda de la unidad 6, vamos a estar usando Google Colab.

### Serie

Pandas incorpora dos estructuras de datos nuevas llamadas: **Series** y **DataFrames**.

Una **serie** es un vector capaz de contener cualquier tipo de dato, como por ejemplo, números enteros o decimales, strings, objetos de Python, etc.

#### Creación de una Serie
Para crearlas, se puede partir de un escalar, una lista, un diccionario, etc., utilizando `pd.Serie()`:

```{python}
# Crear serie partiendo de una lista:
lista = [1, "a", 3.5]

pd.Series(lista)
```

Esto es análogo a lo que se hacía con los arrays de Numpy, pero con la diferencia de que las series de Pandas pueden contener datos de distinto tipo.

Note que se ven dos líneas verticales de datos en el output. A la derecha se observa una columna con los elementos de la lista antes creada, y a la izquierda se encuentra el **índice**, formado por valores desde 0 a n-1, siendo n la cantidad de elementos. Este índice numérico es el predefinido, que nos muestra la posición de los elementos dentro de la Serie.\
También podríamos cambiarlo si quisiéramos. En ese caso, se puede establecer utilizando `index`.

El índice es de vital importancia ya que permite acceder a los elementos de la serie (muy parecido a cómo las claves nos permiten acceden a los valores de un diccionario). Al elegir índices personalizados, tenemos que tener en cuenta que su longitud debe ser acorde al número de elementos de la Serie. De lo contrario, se mostrará un ValueError. 

```{python}
# Crear serie partiendo de una lista, indicando el índice
pd.Series(lista, index = ["x", "y", "z"])
```

También podemos crear Series utilizando diccionarios, y en ese caso, sus claves (o keys) pasan a formar el índice.

```{python}
# Crear serie partiendo de un diccionario:
diccionario = {"x": 1, "y": "a", "z": 3.5}

a = pd.Series(diccionario)
a
```

#### Accediendo a un elemento

Como ya se debe estar imaginando, para acceder a un elemento de la serie, se debe indicar el valor del índice o la posición entre corchetes. Si el índice no es numérico, podrían ser elementos distintos.

```{python}
# Acceder al elemento de índice y:
a["y"]
```

```{python}
# Acceder al elemento de posición 0:
a[0]
```

#### Operaciones con Series
Así como pasaba con los arrays de NumPy, las Series no requieren recorrer valor por valor en un ciclo for si queremos realizar operaraciones. Podemos usar directamente operadores con Series.\
Por ejemplo:

```{python}
a + a
```

```{python}
a * 3
```

### DataFrame

Un **DataFrame** es una estructura de datos tabular **(bidimensional, en forma de tabla)**, compuesta por filas y columnas, que se parece mucho a una hoja de cálculo de Excel.

#### Creando DataFrames

Para crearlos, se utiliza `DataFrame()` y se ingresan diferentes estructuras como arrays, diccionarios, listas, series u otros dataframes.

En el siguiente ejemplo, se crea un Dataframe partiendo de un diccionario llamado `data` para las columnas y de una lista `label` para el índice:

```{python}
data = {'columna_1': ['a', 'b', 'c', 'd', 'e', 'f'],
        'columna_2': [2.5, 3, 0.5, None, 5, None],
        'columna_3': [1, 3, 2, 3, 2, 3]}

labels = ['a1', 'a2', 'a3', 'a4', 'a5', 'a6']

df = pd.DataFrame(data, index=labels)
df
```

Lo que vemos acá es el output de ejecutar el código de arriba en una celda: una tabla donde tenemos 3 columnas, y el índice de cada fila son los elementos de la lista `labels`.

En vez de tener un valor `None`, Pandas lo recibe y lo transforma en `NaN`, que significa "Not a Number". Esto es muy útil para trabajar con datos faltantes, ya que Pandas nos permite realizar operaciones con ellos sin que nos de error (a diferencia de Python).

#### Atributos y descripción de un Dataframe

A continuación, se observa una tabla con métodos que nos permiten conocer las características de un determinado DataFrame.

| Método o atributo | Descripción |
| --- | --- |
| `.info()` | Resume la información del DataFrame |
| `.shape` | Devuelve una tupla con el número de filas y columnas |
| `.size` | Número de elementos |
| `.columns` | Lista con los nombres de las columnas |
| `.index` | Lista con los nombres de las filas |
| `.dtypes` | Serie con los tipos de datos de las columnas |
| `.head()` | Muestra las primeras filas |
| `.tail()` | Muestra las últimas filas |
| `.describe()` | Brinda métricas de las columnas numéricas |

Para ejemplificar los métodos y las funciones de Pandas, usaremos el **DataFrame df** definido en la siguiente línea de código.

```{python}
data = {'nombre': ['José Martínez', 'Rosa Díaz', 'Javier Garcíaz', 'Carmen López', 'Marisa Collado', 'Antonio Ruiz', 'Antonio Fernández', 
                   'Pilar González', 'Pedro Tenorio', 'Santiago Manzano', 'Macarena Álvarez', 'José Sanz', 'Miguel Gutiérrez', 'Carolina Moreno'],
        'edad': [18, 32, 24, 35, 46, 68, 51, 22, 35, 46, 53, 58, 27, 20],
        'genero': ['H', 'M', 'H', 'M', 'X', 'H', 'H', 'M', 'H', 'X', 'M', 'H', 'H', 'M'],
        'peso': [85.0, 65.0, None, 65.0, 51.0, 66.0, 62.0, 60.0, 90.0, 75.0, 55.0, 78.0, 109.0, 61.0],
        'altura': [1.79, 1.73, 1.81, 1.7, 1.58, 1.74, 1.72, 1.66, 1.94, 1.85, 1.62, 1.87, 1.98, 1.77],
        'colesterol': [182.0, 232.0, 191.0, 200.0, 148.0, 249.0, 276.0, None, 241.0, 280.0, 262.0, 198.0, 210.0, 194.0]}

df = pd.DataFrame(data)
df
```

\

:::{.callout-note}
Muchas veces no vamos a querer modificar el dataframe original, pero sí manipularlo. En ese caso, podemos hacer una copia del dataframe original, de esta forma: `df_copy = df.copy()`
:::

##### Info, dtypes, columns e index

Con `info()` se puede ver:

- el índice en la primera línea, que es un rango de 0 a 13
- el número total de columnas en la segunda línea
- el uso de la memoria en la última
- una tabla con los nombres de las columnas en **Column**, la cantidad de valores no nulos en **Non-Null Count** y el tipo de dato en **Dtype** para cada una de ellas.

```{python}
df.info()
```

Note que utilizando `dtypes`, `columns` e `index` se obtiene parte de esta información:

```{python}
# Tipo de dato por columna
df.dtypes
```

```{python}
# Nombre de cada columna
df.columns
```

```{python}
# índice
df.index
```

\ 

##### Shape y Size

La forma del DataFrame es de 14 filas y 6 columnas, por lo que contiene 84 elementos.

```{python}
# Forma del DataFrame (filas, columnas)
df.shape
```

```{python}
# Número de elementos del DataFrame
df.size
```

\

##### Head y Tail

Asimismo, cuando no conocemos un DataFrame, puede ser importante ver las primeras 5 filas con `head()` o las últimas con `tail()`. Si se quisiera observar un número determinado, sólo hay que especificarlo, por ejemplo:

```{python}
# Mostrar las primeras 3 filas.
df.head(3)
```

```{python}
# Mostrar las últimas 5 filas.
df.tail()
```

\

##### Describe

Por otro lado, `describe()` devuelve un resumen descriptivo de las columnas de valores numéricos, como "edad", "peso", "altura" y "colesterol".

```{python}
df.describe()
```

Estas métricas podrían obtenerse de forma puntual (tanto para todo el DataFrame como para sólo una columna) utilizando funciones determinadas, como:\

- `count()`: contabiliza los valores no nulos
- `mean()`: promedio
- `min()`: valor mínimo
- `max()`: valor máximo

Por ejemplo:

```{python}
df.count()
```

```{python}
df.min()
```

```{python}
df.max()
```

#### Accediendo a filas de un DataFrame

Finalmente, como ocurre con las series, para acceder a los elementos de un DataFrame se puede indicar la posición o el nombre de la fila o columna.

Para acceder a una fila en particular, utilizamos `iloc[]`.
Podemos pasarle a `iloc` un entero, una lista de enteros, un rango de números (que indican las posiciones) o directamente el valor del índice. 

```{python}
# Mostrar la fila de posición 0, usando doble corchete [[]]
# Recibe una lista de elementos a mostrar (que contiene sólo al 0)
df.iloc[[0]]
```

<br>
Si queremos mostrar un rango, lo hacemos así:
<br>

```{python}
# Mostrar las filas de posición 0 y 3, usando doble corchete [[]]
# Recibe una lista de elementos a mostrar
df.iloc[[0, 3]]
```

<br>
<br>

```{python}
# Mostrar las filas de posiciones entre 0 hasta 3 (exclusive)
# Usa slices
df.iloc[:3]
```

<br>

```{python}
# El equivalente a df.iloc[:3] es el uso de head(3)
df.head(3)
```

<br>

#### Accediendo a columnas de un DataFrame

A veces no queremos sólo acceder a filas, sino a columnas. Por ejemplo, para calcular sumas, promedios, máximos o mínimos, etc.

Para acceder a una **columna** se pueden utilizar una lista con los nombres de las columnas que se quieren mostrar: `DataFrame[[columna1, columna2]]`.

```{python}
# Mostrar la columna "nombre"
df[['nombre']]
```

<br>

```{python}
# Mostrar más de una columna: "nombre" y "edad":
df[['nombre', 'edad']]
```

De esta forma, podríamos hacer algo así:

```{python}
# calculamos el promedio para los valores de la columna 'edad'
df[['edad']].mean()
```

#### Modificar un Dataframe

A la hora de modificar un DataFrame, tenemos distintas posibilidades:\

- Cambiar la estructura del mismo, como los nombres de las columnas y de los índices,
- Agregar una nueva filas o columna
- Reemplazar un dato en una determinada posición.

A continuación, se enumeran distintos métodos para llevar a cabo estos cambios.

| Método | Descripción |
| --- | --- |
| `rename()` | Renombra las columnas |
| `insert()` | Agrega columnas |
| `drop()` | Elimina columnas y filas |
| `loc[fila]` | Agrega una fila en un índice dado |
| `loc[fila, columna]` | Modifica un valor particular dado un índice y una columna |
| `map()` | Busca un valor dado en una columna y lo reemplaza |
| `replace()` | Reemplaza un valor dado en una columna |

<br>

##### Rename, insert y drop

Para renombrar una columna, se utiliza un diccionario: `rename(columns={"nombre_columna": "nuevo_nombre_columna"})` 

```{python}
# Reemplazo "nombre" por "nombre y apellido"
df = df.rename(columns={"nombre": "nombre y apellido"})
df.head() # para que veamos el cambio de nombre en la columna
```

<br>
Para agregar una nueva columna, existe el método `insert()`, que requiere indicar la posición de la nueva columna, el nombre de la nueva columna, y los valores de la misma. 

Vamos a crear una lista llamada **direccion** con 14 valores, para cada una de las personas del DataFrame, y luego agregarla en la posición 3:

```{python}
# Valores de la nueva columna
direccion = ["CABA", "Bs As", "Bs As", "Bs As", "CABA", "Bs As", "CABA", "CABA", "CABA", "CABA", "CABA", "Bs As", "CABA", "CABA"]

# Insertar la columna "direccion" en la posición 3 de columnas:
df.insert(3, "direccion", direccion)
df.head() # para que veamos que la columna nueva se agregó
```

Para agregar una nueva columna también podemos hacerlo directamente, como si fuera un diccionario: `df['nueva_columna'] = valores`.

Por ejemplo, supongamos que queremos ingresar una columna con el índice de masa corporal de las personas., que se calcula de la siguiente manera: 

$$IMC = \frac{Peso(kg)}{Altura(m)^2}$$

Esto podemos hacerlo directamente trabajando sobre las columnas, como trabajábamos sobre los arrays de NumPy; y guardando el resultado en una nueva columna llamada "IMC".

```{python}
# Crear la columna "IMC"
df["IMC"] = df["peso"] / df["altura"]**2
df.head()
```

Esto lo que va a hacer es tomar todos los valores de peso y altura de cada fila, calcular el IMC y guardarlo en una nueva columna de la línea, bajo el nombre "IMC".

De manera similar, se puede crear la columna **dni** sin utilizar `insert()`, usando la lista **dni**:

```{python}
df_copy = df.copy() # Hacemos una copia, para que no nos afecte el original
dni = [12345678, 23456789, 34567890, 45678901, 56789012, 67890123, 78901234, 89012345, 90123456, 12345678, 23456789, 34567890, 45678901, 56789012]
df_copy["dni"] = dni
df_copy.head()
```

Por lo que vemos que no es indispensable usar `insert` para poder agregar una nueva columna, pero `insert` nos permite decir *en dónde* queremos agregarla.

<br>

Para eliminar una fila `(axis=0)` o columna `(axis=1)`, se utiliza `drop()`:

```python
# Elimino una columna llamada "direccion". También podría hacer: `del df["direccion"]`
df = df.drop('direccion', axis=1)  
```

<br>

```python
# Elimino la fila 14
df = df.drop(14, axis=0) 
```

#### Insertar filas

Para agregar una nueva fila, se utiliza `loc[]`, que nos pide indicar el índice y los valores de la misma. Para ello, creamos una lista llamada **nueva_fila** con valores para cada columna del DataFrame.


```{python}
# Valores de la nueva fila
nueva_fila = ['Carlos Rivas', 30, 'H', "CABA", 70.0, 1.75, 203.0, 22]

# Insertamos al final del DataFrame
largo = len(df.index) # o también: largo = df.shape[0], para obtener la cantidad de filas
df.loc[len] = nueva_fila
df.tail() # Para ver que se agregó al final
```

:::{.callout-note collapse="true"}
### ¿Por qué usamos 'len' arriba?
A diferencia de Python, podemos agregar una fila en una posición que no existe aún. Por eso arriba pudimos hacer `df.loc[len]`.
:::

#### Modificar un valor

Finalmente, **para cambiar un valor determinado** también se utiliza `loc[]`, como por ejemplo, agregar el peso de Javier García (tercera fila), que antes tenía `NaN`:

```{python}
df.loc[2, 'peso'] = 92
df.head()
```

<br>

Para transformar los valores de una columna entera, podemos utilizar `map()` pasando un diccionario del estilo `{valor_viejo: valor_nuevo}`. Por ejemplo, modificar la columna "genero" reemplazando "H" por "M", "M" por "F":

```{python}
df['genero'] = df['genero'].map({'H': 'M', 'M': 'F', 'X': 'X'})
df.head()
```

<br>

Otra manera sería utilizando `replace()`. Por ejemplo, en la columna "direccion" vamos a modificar "Bs As" por "Buenos Aires".

```{python}
df['direccion'] = df['direccion'].replace('Bs As', 'Buenos Aires')
df.head()
```

#### Filtrar un Dataframe

Para filtrar los elementos de un DataFrame se suelen utilizar condiciones lógicas de la siguiente forma: `DataFrame[ condicion ]`.

Por ejemplo:

```{python}
# Seleccionar aquellas personas menores de 40 años
# La condición es que la columna 'edad' del dataframe tenga valor menor a 40
df[ df['edad'] < 40 ] 
```

<br>
Cuando se requieren múltiples condiciones, se puede adicionar usando símbolos como `&` para **and** y `|` para **or**. Por ejemplo:

```{python}
# Seleccionar aquellas personas de genero femenino y menores de 40 años:
df[ (df['edad'] < 40) & (df['genero'] == 'F') ]
```

<br>

```{python}
# Seleccionar aquellas personas cuyo peso es 60kg o 90kg:
df[(df['peso'] == 60.0) | (df['peso'] == 90.0)]
```

<br>

También puedo filtrar las fillas por el valor `NaN`.\
Para eso, se utiliza la función `isnull()` que devuelve `True` si el valor de la columna es nulo o NaN. Por ejemplo:

```{python}
df['IMC'].isnull()
```

Para visualizar aquellas filas donde el índice de masa corporal es nulo, filtramos:

```{python}
df[df['IMC'].isnull()]
```

El método opuesto es `notnull()`, que devuelve `True` si el valor de la columna no es nulo o NaN. Por ejemplo:

```{python}
df[df['IMC'].notnull()]
```

#### Ordenando, Contando y Agrupando

A continuación, se muestra una lista con métodos que resultan muy útiles a la hora de analizar datos: 

| Método | Descripción |
| --- | --- |
| `sort_values(by, ascending)` | Ordena el DataFrame considerando los valores de la o las columnas determinadas y devuelve un DataFrame nuevo (no modifica el original) |
| `value_counts()` | Indica los valores únicos de una determinada columna y el número de veces que aparece en ella |
| `groupby().func()` | Agrupa las filas según ciertos valores de columnas. Requiere que apliquemos una función luego para que 'agrupe' los datos. |

##### Sort value:
  
Para utilizar la función `sort_values(by, ascending)`, se debe indicar en el parámetro `by` una lista con las columnas para ordenar el DataFrame y en `ascending`, `True` si el orden deseado es creciente o `False` para decreciente.

En el siguiente ejemplo ordenamos por "nombre y apellido" en forma alfabética: 

```{python}
df.sort_values(by=['nombre y apellido'], ascending=[True])
```

**¿Qué ocurre cuando ordenamos siguiendo varias columnas?** Los valores del DataFrame se ordenan siguiendo la primera columna en primer lugar, luego la segunda, y así sucesivamente.

```{python}
df.sort_values(by=['genero', 'nombre y apellido'], ascending=[True, True])
```

En el ejemplo de arriba, primero se ordena de manera creciente por genero, resultando en tres grupos: "genero" = "F", "M" y "X". Luego, cada uno de esos grupos se ordena por "nombre y apellido" de forma creciente.

![Ejemplo de sort_values()](./imgs/unidad_6/sortvalues.png)

##### Value Count:

Utilizando `value_counts()` se pueden contar las filas en cada grupo según "direccion". Es decir, cuenta cuántas apariciones hay de cada valor en una columna.

```{python}
df['direccion'].value_counts()
```

##### Group by:
  
`groupby()` es un método que nos permite agrupar los datos del DataFrame según los valores de una o unas columnas dadas, transformándose estas en el nuevo índice de los grupos. Por ejemplo, si quisieramos agrupar por dirección y obtener la cantidad de apariciones de cada valor:

```{python}
# Agrupar por "direccion" y devolver la cantidad de cada uno
df_copy.groupby(['direccion']).size()
```

Obteniendo una tabla con valores agrupados por "direccion", siendo esta columna el nuevo índice.

```{python}
# Agrupar por "direccion" y "genero" y mostrar el promedio de las columnas de 'edad' y 'peso'
df.groupby(['direccion', 'genero'])[['edad', 'peso']].mean()
```

También puedo agrupar por más de una columna, y aplicar distintas funciones a las columnas. Por ejemplo, si quisiera agrupar por "direccion" y "genero" y obtener el promedio de la columna "edad" y la suma de la columna "peso", puedo usar `agg`, que significa "aggregate" (que significa 'agregar') y me pemite, para cada columna, pasarle una función a aplicar:

```{python}
df.groupby(['direccion', 'genero']).agg({'edad': 'mean', 'peso': 'sum'})
```

### Conclusiones
Pandas nos permite trabajar con datos de una manera muy sencilla y eficiente. Nos permite importar datos de distintas fuentes, limpiarlos, transformarlos y analizarlos. Además, nos permite visualizar los datos de una manera muy amigable, lo que nos va a permitir entender mejor los datos con los que estamos trabajando.

## Matplotlib

:::{.callout-note}
Para Matplotlib también vamos a usar Google Colab
:::

Matplotlib es probablemente la biblioteca de Python más usada para crear gráficos, también llamados **plots**. Esta biblioteca provee una forma rápida de graficar datos en varios formatos de alta calidad que pueden ser compartidos y/o publicados.

El primer paso es importar la biblioteca. Por convención:

```{python}
import matplotlib.pyplot as plt
```

### Introducción

Para crear un gráfico con matplotlib, se deben seguir los siguientes pasos:

1. **Crear la figura** que contendrá el gráfico, utilizando las funciones `subplots()` o `figure()`. Se recomienda la primera, como se verá más adelante.

2. **Graficar los datos**, utilizando distintas funciones dependiendo del tipo de gráfico que se desea realizar:


  | Función | Tipo de Gráfico |
  | --- | --- |
  | `plot()` | Gráfico de línea |
  | `scatter()` | Gráfico de puntos |
  | `bar()` | Gráfico de barras verticales |
  | `barh()` | Gráfico de barras horizontales |
  | `pie()` | Gráfico de torta |


3. **Personalizar el gráfico**. Este paso es muy recomendado para lograr un mejor entendimiento de la visualización. Esto incluye agregar etiquetas a los ejes, títulos, leyendas, etc. También podemos modificar el aspecto de las líneas, los puntos, los colores, y más (esto se deja en el final del apunte, y es opcional).

4. **Mostrar el gráfico**, utilizando la función `show()`

  ```python
  plt.show()
  ```

<hr>

Dijimos que podíamos usar `subplots`o `figure` para crear una figura.\
Pero, **¿en qué se diferencian?** Eso depende de lo que quieras hacer. A continuación, se verá el detalle de lo que está ocurriendo en cada línea, para que así puedas elegir qué es lo mejor para tu caso.

```{python}
plt.figure()
```

```{python}
plt.subplots()
```

No se puede ver un gráfico en ninguno de los outputs, pero analicemos lo que nos imprime:

1. `fig = plt.figure()` crea una **figura, pero sin axes**, por lo que muestra `<Figure size 640x480 with 0 Axes>`.
2. `fig, ax = plt.subplots()` permite **crear ambos: figura y axes**, por lo que muestra un plot vacío.

Una **figura** es el marco que delimita la zona donde se trazan los gráficos, mientras que los **axes**, son lo que llamamos comunmente gráficos, es decir, son las áreas donde los puntos se pueden especificar en términos de coordenadas. 
Explicado de forma más simple: **una figura es el lienzo y un axes es el dibujo**.
**Por lo tanto, una figura puede contener muchos axes, pero un axes determinado sólo puede estar contenido en una única figura.**

<img src="./imgs/unidad_6/fig_ax.png" width="200" />

::: {.callout-note}
#### **¡Ojo! No confundir axes con axis** \
Los **Axis** son los ejes cartesianos que se encargan de establecer los límites, la escala y las dimensiones del gráfico: un axes puede tener 2 Axis (x e y), si es un gráfico plano, o 3, si es un gráfico en 3D.
:::

Entonces, con lo aprendido hasta el momento, podemos decir que `figure` puede llegar a ser más amigable para principiantes ya que es más conciso y resulta muy útil cuando simplemente se desea crear un gráfico para verificar resultados rápidamente; y `subplots` es ideal cuando necesitamos un enfoque más flexible, con gráficos más complejos o con un ajuste fino.\
Pero los dos, al final, logran lo mismo (al menos para las cosas que vamos a ver en esta materia).

### Creando una figura

Para crear una figura, la función de gráfico recibe los datos a graficar y los parámetros necesarios para personalizarlo.

#### Gráfico de línea
El gráfico de línea permite visualizar cambios en los valores lo largo de un rango continuo (tendencias), como puede ser el tiempo o la distancia.\
Para crear un gráfico de línea, se utiliza la función `plot()`.

```{python}
# Grafico elemental
x = [0,2,10,11,18,25]
y = [0,1,2,3,4,5]

fig, ax = plt.subplots()

# Gráfico de línea
ax.plot(x, y)
plt.show()
```

En este caso, se creó un gráfico de línea con los valores de **x** e **y**, tal que los puntos (0,0), (2,1), (10,2), (11,3), (18,4) y (25,5) están unidos por una línea recta.

#### Gráfico de puntos
El gráfico de dispersión o puntos permite visualizar la relación entre las variables.\
Para crearlo, se utiliza la función `scatter()`:

```{python}
# Gráfico de puntos
fig2, ax2 = plt.subplots()
ax2.scatter(x, y)
plt.show()
```

:::{.callout-important}
### Grillas
¿Ves cómo en el gráfico de puntos quizás no se entiende bien la ubicación de cada punto?\
Esto es porque no tenemos una guía que nos ayude. Para eso, vamos a agregar una grilla.
La grilla se puede agregar con al función `grid()`, y es una buena forma de darle legibilidad a un gráfico como puede ser el de linea y el de puntos.\
:::

```{python}
# Gráfico de puntos
fig, ax = plt.subplots()
ax.scatter(x, y)
ax.grid()
plt.show()
```

#### Gráficos de Barras

El gráfico de barras permite visualizar proporciones, comparando dos o más valores entre sí. Para crearlo, se utiliza la función `bar()`, la cual primero recibe, en primer lugar, las etiquetas de las barras que se van a mostrar y en segundo lugar, la altura correspondiente a cada una de estas barras.

En el caso de este tipo de gráfico, **no hace falta que los valores de las etiquetas sean numéricos**.

```{python}
peso = [340, 115, 200, 200, 270]
ingredientes = ['chocolate', 'manteca', 'azúcar', 'huevo', 'harina']

fig, ax = plt.subplots()

ax.bar(ingredientes, peso) # Acá podría usarse también barh

ax.set_xlabel('Ingredientes')
ax.set_ylabel('Masa (g)')

ax.set_title("Receta")

plt.show()
```

#### Gráfico de torta

Finalmente, tenemos el gráfico de torta. El gráfico de torta, como el de barras, permite visualizar y comparar proporciones pero de manera circular y como partes de un todo.

Para crearlo, se utiliza la función `pie()`, que recibe los valores de las porciones y las etiquetas de cada una. Para las etiquetas, se debe indicar la variable `label`, y si además queremos que se muestren los porcentajes, se puede utilizar `autopct='%1.1f%%'`. `'%1.1f%%'` significa que se mostrará un decimal y el símbolo de porcentaje. 

```{python}
peso = [340, 115, 200, 200, 270]
ingredientes = ['chocolate', 'manteca', 'azúcar', 'huevo', 'harina']

fig, ax = plt.subplots()

ax.pie(peso, labels= ingredientes, autopct='%1.1f%%')

ax.set_title("Receta")

plt.show()
```

#### Cambio de Tamaño

Podemos establecer el tamaño de la figura con el parámetro `figsize` dentro de la función `subplots()`. Este parámetro recibe una tupla con dos valores: el ancho y el alto de la figura, en pulgadas.

Veamos este ejemplo: **x** es el tiempo medido en minutos e **y** una distancia en metros, entonces:

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots(figsize=(3, 5))

ax.plot(x, y)

plt.show()
```


### Títulos
Así como los nombres de las variables en nuestro código, es importante que nuestro gráfico tenga un Título descriptivo que nos ayude a entender qué es lo que estamos viendo. Lo mismo pasa con los ejes: queremos poder entender qué representa cada uno.

Para setear un título, vamos a usar la función `set_title()`. Para los ejes, usaremos `set_xlabel()` y `set_ylabel()`. Cada una recibe un string que se usará como etiqueta del eje X, etiqueta del eje Y o título, respectivamente.

Siguiendo el ejemplo anterior, vamos a agregar títulos a los ejes y al gráfico:

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y)

# Mostrar el título del gráfico
ax.set_title("Gráfico de posición")

# Mostrar el título de los ejes
ax.set_xlabel('Tiempo (min)')
ax.set_ylabel('Distancia (m)')


ax.grid()
plt.show()
```

### Referencias
El gráfico con el que estamos trabajando sólo tiene una línea, pero si contara con más de una (lo vamos a ver más adelante en este apunte), el uso de referencias sería muy importante para lograr el entendimiento del mismo. Para rotular las líneas, dentro de `plot()` se debe definir la referencia como `label`. Luego se coloca `legend()`

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, label='Objeto 1') # Agregar el label

ax.set_title("Gráfico de posición")
ax.set_xlabel('Tiempo (min)')
ax.set_ylabel('Distancia (m)')

# Agregar la refencia
ax.legend()

ax.grid()
plt.show()
```

### Gráficos múltiples

En los casos anteriores, creamos siempre un sólo gráfico con una curva, en una figura. Pero **También podríamos graficar varias curvas en un mismo gráfico**.

Para esto vamos a seguir el mismo procedimiento que antes, pero vamos a agregar más de un `plot()` al mismo axes. También vamos a darles un label a cada uno, y luego vamos a agregar una leyenda. Automáticamente, al estar en el mismo axes, matplotlib los va a agregar al mismo gráfico con distintos colores.

```{python}
# Valores que se desean graficar
x = [0, 1, 2, 3, 4, 5]
y_linear = [0, 1, 2, 3, 4, 5]
y_quadratic = [0, 1, 4, 9, 16, 25]
y_cubic = [0, 1, 8, 27, 64, 125]

fig, ax = plt.subplots()

# Usamos distintos tipos de y, con distintas labels
ax.plot(x, y_linear, label='Lineal')
ax.plot(x, y_quadratic, label='Cuadrático')
ax.plot(x, y_cubic, label='Cúbico')

ax.set_title("Gráfico de múltiples curvas")
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.legend()

plt.show()
```

Note que se agregan nuevos datos al mismo axes, por lo que siempre usamos `plot()` pero con distintos valores de `y`. Asimismo, se estableció un tamaño de la figura con `figsize=(width, height)`

### Uniendo Bibliotecas

#### Matplotlib y Numpy
Podemos usar arrays de numpy para simplificarnos el trabajo.\
Repetimos el gráfico anterior pero usando numpy, y vamos a ver que pudimos obtener muchos más valores sin tener que calcularlos nosotros y escribirlos en una lista de Python.

```{python}
import numpy as np

x = np.linspace(0, 5, 100) # Creamos un array de 100 valores entre 0 y 5
y_linear = x # usamos x
y_quadratic = x**2 # usamos x al cuadrado
y_cubic = x**3 # usamos x al cubo

fig, ax = plt.subplots()

# Usamos distintos tipos de y
ax.plot(x, y_linear, label='Lineal')
ax.plot(x, y_quadratic, label='Cuadrático')
ax.plot(x, y_cubic, label='Cúbico')

ax.set_title("Gráfico de múltiples curvas")
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.legend()

plt.show()
```

#### Matplotlib y Pandas
También podemos usar columnas de Pandas como datos para crear un gráfico.

Supongamos el siguiente dataframe de los datos de las mascotas en una veterinaria:

```{python}
data = { 'nombre': ['Bola de Nieve', 'Jerry', 'Hueso'],
        'especie': ['gato','chinchilla', 'perro'],
        'edad': [2.5, 3, 7],
        'visitas': [1, 3, 2],
        'prioridad': ['si', 'si', 'no']}

df = pd.DataFrame(data)
df
```

Podemos ahora crear un gráfico usando las columnas del dataframe:

```{python}
# Determino las columnas del DataFrame que queremos graficar
x_values = df['nombre']
y_values = df['edad']

fig, ax = plt.subplots()

ax.bar(x_values, y_values)

ax.set_xlabel('Paciente')
ax.set_ylabel('Edad (años)')

ax.set_title("Mascotas")

plt.show()
```

:::{.callout-note}
#### ¿Qué pasa si nuestros labels no llegan a verse?
Puede pasar, sobre todo si tenemos muchos datos con nombres largos, que nuestros labels no lleguen a verse de forma correcta si los presentamos de forma horizontal.\
Por ejemplo:

<img src="./imgs/unidad_6/matplotlib_labels_horizontales.png" width="300" />

En esos casos, podemos pedirle a matplotlib que los presente de forma vertical, para que no se superpongan. Para eso, usamos `xticks()` y `rotation`: `plt.xticks(rotation=90)`.\
El ángulo de rotación se mide en grados, por lo que `rotation=90` significa que se rotarán 90 grados. De esta forma, los labels se presentarán de forma vertical. Podríamos también usar otro ángulo, y se mostrarían los labels de forma inclinada.\
Esta es la forma en que se visualizan los datos con los labels rotados:

<img src="./imgs/unidad_6/matplotlib_labels_rotados.png" width="300" />

:::

### Bonus Track: Personalización (opcional)

:::{.callout-note}
#### ¿Qué significa opcional?
Significa que esta parte del apunte no es obligatoria. Pero si quieren leerla, les va a permitir hacer gráficos más bonitos y personalizados. También les va a permitir llevarse el conocimiento de qué otras herramientas tienen disponibles, y volver a este apunte a buscar información en un futuro si es que la necesitan.
:::

Esta imagen, fue obtenida de la referencia de matplotlib y resume de manera fácil y visual las modificaciones que podemos hacerla a las figuras creadas.

![Partes de una Figura. Si querés conocer más detalle, podés ingresar a [este link](https://matplotlib.org/stable/tutorials/introductory/quick_start.html).](./imgs/unidad_6/matplotlib.png)

Como dijimos más arriba, las figuras pueden ser personalizadas de muchas maneras. Algunas son:

- Colores
- Estilos de línea
- Marcadores
- Grilla personalizada

¡y más!

#### Cambiando colores y estilos

Para cambiar los colores de los gráficos, podemos utilizar los parámetros `color`, `marker`, `linestyle`, `markersize` y `linewidth` dentro de la función `plot()`.

-  **color =** nombre del color, por ejemplo: `'blue', 'green', 'red'`, etc.
-   **marker =** forma de los puntos o marcadores, por ejemplo: `'^', 'o', 'v'`, etc.
-   **linestyle =** estilo de línea, por ejemplo: `'solid', 'dashed', 'dotted'` o sus equivalentes:` '-', '--', ':',` entre otros.
-   **markersize, linewidth =** con un número, establecemos el tamaño del marcador y el espesor de la línea respectivamente.

Si no le asignamos un valor, se establecen los predefinidos.

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)
plt.show()
```

#### Grilla personalizada:

Si deseamos modificarle a una grilla, por ejemplo, el color, el estilo de línea, o sólo queremos ver uno de los ejes, podemos indicarlo utilizando parámetros muy similares a los vistos anteriormente pero en la funcion `grid()`.

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)

#Grilla modificada
ax.grid(axis = 'y', color = 'gray', linestyle = 'dashed')
plt.show()
```

<hr>

Con esto finalizamos los temas de la materia.\
¡Esperamos que hayas disfrutado de este recorrido!\
Recordá que si querés dejarnos feedback podés hacerlo en el formulario que está en la parte de [Contacto](contact.qmd#feedback).

Si te interesa ser docente de la materia, podés ver los requisitos y escribirnos en la sección [Ser Docente](contact.qmd#docentes).

¡Muchos éxitos! 👋
