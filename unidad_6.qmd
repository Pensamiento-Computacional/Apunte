---
title: Bibliotecas de Python
format:
  html:
    code-fold: false
jupyter: python3
---

## Introducci√≥n

Python es un lenguaje de programaci√≥n muy popular, poderoso y vers√°til que cuenta con una amplia gama de bibliotecas que ayudan a que la programaci√≥n sea m√°s f√°cil y eficiente. Pero,  **¬øqu√© son las bibliotecas?** Las bibliotecas son conjuntos de m√≥dulos que contienen funciones, clases y variables relacionadas, que permiten realizar tareas sin tener que escribir el c√≥digo desde cero y este se puede reutilizar en m√∫ltiples programas y proyectos. 

Entre las bibliotecas disponibles se encuentran las est√°ndares, que se incluye con cada instalaci√≥n de Python, y las de c√≥digo abierto creadas por la gran comunidad de desarrolladores, que constantemente genera nuevas bibliotecas y mejora las existentes. Por ello es aconsejable que, al momento de utilizarlas, se verifique si existe alguna actualizaci√≥n en las gu√≠as de usuario.

Asimismo, estas bibliotecas se pueden clasificar seg√∫n su aplicaci√≥n y funcionalidad en: procesamiento de datos, visualizaci√≥n, aprendizaje autom√°tico, desarrollo web, procesamiento de lenguaje y de im√°genes, entre otras. En este cap√≠tulo se analizar√°n tres de las bibliotecas m√°s reconocidas y ampliamente utilizadas de Python: **NumPy** y **Pandas** para procesamiento de datos y **Matplotlib**, para visualizaci√≥n.

### ¬øC√≥mo se utilizan las bibliotecas?

Para acceder a una biblioteca y sus funciones, se debe instalar por √∫nica vez y luego, importar cada vez que la necesitemos.

En la parte superior de nuestro c√≥digo debemos correr `import {nombre_de_biblioteca} as {nombre_corto_de_biblioteca}`. El alias o nombre corto de la biblioteca se suele agregar para lograr una mayor legibilidad del c√≥digo, pero no es mandatorio.

```python
import numpy as np
```

:::{.callout-note collapse="true}
En nuestro caso, la instalaci√≥n no es necesaria, ya que vamos a utilizar Google Colab, pero en caso de usar otro IDE (como por ejemplo, Visual Studio Code), se realiza desde el s√≠mbolo del sistema (o en ingl√©s: ‚ÄúCommand Prompt‚Äù, o terminal o consola), corriendo: `pip install ‚Äìnombre_de_biblioteca` o similares. 
:::

## Adaptaciones para Colab

A partir de esta gu√≠a es probable que debamos reutilizar ciertas cosas o adaptar la forma en la que venimos trabajando. Para esto, vamos a hacer una modificaci√≥n:

Si tenemos variables o imports definidos en otra celda y no la ejecutamos, al intentar usarla nos va a dar error. Es importante entonces o correr todas las celdas, o que cada celda tenga la informaci√≥n necesaria para poder correrse de forma independiente. Ac√° vemos c√≥mo, al querer ejecutar s√≥lo la segunda celda, nos da error porque la variable `saludo` est√° definida en la celda anterior (que no se ejecut√≥).

![](./imgs/unidad_6/google_colab5.png)

## NumPy

NumPy es una biblioteca de c√≥digo abierto muy utilizada en el campo de la ciencia y la ingenier√≠a. Permite trabajar con datos num√©ricos, matrices multidimensionales, funciones matem√°ticas y estad√≠sticas avanzadas. 

Como ya se mencion√≥ anteriormente, para utilizarse se debe instalar e importar. Por convenci√≥n, se suele importar como: 

```{python}
import numpy as np
```

NumPy incorpora una estructura de datos propia llamados **arrays** que es similar a la lista de Python, pero puede almacenar y operar con datos de manera mucho m√°s eficiente: **el procesamiento de los arrays es hasta 50 veces m√°s r√°pido**. Esta diferencia de velocidad se debe, en parte, a que **los arrays contienen datos homog√©neos**, a diferencia de las listas que pueden contener distintos tipos de datos dentro.

### **Arrays**

Un **array** es un conjunto de elementos del mismo tipo, donde cada uno de ellos posee una posici√≥n y esta es √∫nica para cada elemento. Como dijimos arriba, en Python vimos las listas, que es lo m√°s parecido a un Array.

Analicemos el siguiente ejemplo: si pensamos en una matriz, lo primero que nos viene a la mente es una tabla con valores ordenados en filas y columnas, donde una fila es la l√≠nea horizontal y una columna es la vertical. Es decir, una matriz es un conjunto de elementos que posee una posici√≥n o √≠ndice determinado por la fila y la columna, por lo que ser√≠a un array.

En este cap√≠tulo se trabajar√° principalmente con vectores y matrices, ya que consideramos que les ser√° √∫til para aplicar los conocimientos de Numpy en otras materias.

#### Creaci√≥n de un Array

Un array se crea usando la funci√≥n `array()` a partir de listas o tuplas. Por ejemplo:

```{python}
a = np.array([1, 2, 3])
print(a)
```

Tambi√©n, se pueden crear arrays particulares, constituidos por ceros con `zeros()` o por unos con `ones()`:

```{python}
# Creo un array de ceros con dos elementos
a_ceros = np.zeros(2)
print(a_ceros)
```

```{python}
# Creo un array de unos con dos elementos
a_unos = np.ones(2)
print(a_unos)
```

Adem√°s, se pueden crear arrays con un rango de n√∫meros, utilizando `arange()` o `linspace()`:

```{python}
# Creo un array con un rango que empieza en 2 hasta 9 y va de 2 en 2.
a_rango = np.arange(2, 9, 2)
print(a_rango)
```

```{python}
# Creo un array con un rango formado por 4 n√∫meros
# que empieza en 2 hasta 10 (incluidos). 
a_rango_2 = np.linspace(2, 10, num=4)
print(a_rango_2)
```
Esto es muy parecido a los rangos que ya vimos en Python, con la sutil diferencia de que el `final` del rango en este caso **s√≠ se incluye**.

Finalmente, para crear arrays de m√°s dimensiones, se utilizan varias listas:

```{python}
matriz = np.array([[1, 2, 3], [4, 5, 6]])

print(matriz)
```

#### Atributos de un array

#### Dimensi√≥n
Para caracterizar un array es necesario conocer sus dimensiones, utilizando `ndim`. De esta forma, se puede confirmar que el array llamado **matriz**, definido anteriormente, es bidimensional: 

```{python}
# N√∫mero de ejes o dimensiones de la matriz
matriz.ndim
```

#### Forma
Otra caracter√≠stica de inter√©s es su forma o `shape`: para las matrices bidimensionales, se muestra una tupla (n, m) con el n√∫mero de filas n y de columnas m:

```{python}
# (n = filas, m = columnas)
matriz.shape
```

#### Tama√±o
El tama√±o de un array es el n√∫mero total de elementos que contiene, y se obtiene con `size`:
```{python}
# N√∫mero total de elementos de la matriz: 2 filas x 3 columnas = 6 elementos
matriz.size
```

#### Posiciones
Al elemento de una matriz A que se encuentra en la **fila i-√©sima y la columna j-√©sima** se llama $a_{ij}$. As√≠, para acceder a un elemento de un array se debe indicar primero la posici√≥n de la fila y luego, de la columna:

```{python}
print('Elemento de la primera fila y segunda columna: ', matriz[0, 1])
```

N√≥tese la diferencia con las matrices (listas de listas) de Python, donde se acced√≠a a un elemento por separado, primero a la fila y luego a la columna: `matriz[0][1]`.

Tambi√©n se puede elegir un rango de elementos en una fila o columna particular:

```{python}
print('Los elementos de la primera fila, columnas 0 y 1: ', matriz[0, 0:2])
```

```{python}
print('Los elementos de la segunda columna, filas 0 y 1: ', matriz[0:2, 1])
```

#### Modificar arrays 

De forma similar a lo aprendido con las listas de Python, se pueden modificar los arrays utilizando ciertas funciones. Para entender y aplicar las mismas, definamos un vector llamado a:

```{python}
a = np.array([2, 1, 5, 3, 7, 4, 6, 8])

print(a)
```

##### Reshape
A este vector, se le puede modificar la forma: pasando de ser `(8,)` a `(4,2)`, por dar un ejemplo:

```{python}
a_reshape = a.reshape(2, 4) # 2 filas y 4 columnas

print(a_reshape)
```

##### Insert

Tambi√©n, se podr√≠a insertar una fila (`axis = 0`) o una columna (`axis = 1`) en una determinada posici√≥n. Por ejemplo:

```{python}
# Agregar fila de cincos en posici√≥n 1:
print(np.insert(a_reshape, 1, 5, axis=0))
```

A la funci√≥n `insert()`, se le debe indicar: \

- El array que se desea modificar \
- La posici√≥n de la fila o columna que se desea agregar \
- Los valores a insertar. **¬°Ojo con las dimensiones!** Para el ejemplo anterior, a_reshape ten√≠a 2 filas, por lo que se debe agregar una columna con 2 elementos o una fila con 4. \
- El eje que se agrega: una fila (axis = 0) o una columna (axis = 1) \

```{python}
# Agregar columna de cincos en posici√≥n 1:
print(np.insert(a_reshape, 1, 5, axis=1))
```

O lo que es equivalente:

```{python}
# Agregar columna de cincos en posici√≥n 1:
print(np.insert(a_reshape, 1, [5, 5], axis=1))
```

##### Append y Delete

Tambi√©n podr√≠amos agregar una fila o una columna utilizando `append()` al final, como ocurr√≠a con las listas:

```{python}
# Agregar una √∫ltima fila
a_modificada = np.append(a_reshape, [[1, 2, 3, 4]], axis=0)
print(a_modificada)
```

O eliminarlas con `delete()`

```{python}
# Eliminar la fila de la posici√≥n 2.
print(np.delete(a_modificada, 2, axis=0))
```

##### Concatenate y Sort

Finalmente, podemos concatenar arrays, como los siguientes:

```{python}
a = np.array([2, 1, 5, 3])
b = np.array([7, 4, 6, 8])

# Concatenar a y b:
c = np.concatenate((a, b))
print(c)
```

Y ordenar los elementos de un array como num√©rico o alfab√©tico, ascendente o descendente.

```{python}
print(np.sort(c))
```

### Operaciones aritm√©ticas utilizando **array**

Como se ha mencionado anteriormente, Numpy tiene un gran potencial para realizar operaciones, muy superior al de las listas de Python. Por ejemplo, si quisi√©ramos sumar dos listas de python necesitar√≠amos realizar un `for`:

```{python}
# Definir listas
a = [2, 1, 5, 3]
b = [7, 4, 6, 8]
c = []

# Sumar el primer elemento de a con el primero de b, el segundo elemento de a con el segundo de b y as√≠ sucesivamente
for i in range(len(a)):
  c.append(a[i] + b[i])
print(c)
```

Utilizando las funciones de Numpy, esto ya no es m√°s necesario:

```{python}
# add() para sumar elemento a elemento de a y b
c = np.add(a, b)
print(c)
```

Tambi√©n podemos realizar otras operaciones, como la resta, multiplicaci√≥n y divisi√≥n. Usar un arreglo dentro de una ecuaci√≥n nos devuelve otro arreglo, donde cada elemento es el resultado de aplicar la operaci√≥n a los elementos correspondientes de los arreglos originales.

```{python}
x = np.array([0,  1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
y = 3 * x + 2
print(y)
```

De esta forma, podemos realizar operaciones aritm√©ticas con arrays de Numpy de forma muy sencilla y r√°pida. Antes, en Python, para realizar estas operaciones deb√≠amos recurrir a un ciclo `for` o a el uso de `map`. Numpy se ocupa de ahorrarnos el trabajo y calcular, para cada elemento del array, el resultado.

Adem√°s, tenemos operaciones b√°sicas que vienen predefinidas por Numpy. Las vamos a ver a continuaci√≥n.

#### Operaciones b√°sicas:

A continuaci√≥n se muestra una lista con las operaciones b√°sicas junto con sus operadores asociados, funciones y ejemplos.

| Operaci√≥n | Operador | Funci√≥n |
| --- | --- | --- |
| Suma | `+` | `add()` |
| Resta | `-` | `subtract()` |
| Multiplicaci√≥n | `*` | `multiply()` |
| Divisi√≥n | `/` | `divide()` |
| Potencia | `**` | `power()` |

Definimos los vectores a y b con los que operaremos y veremos ejemplos:

```{python}
a = np.array([1, 3, 5, 7])
b = np.array([1, 1, 2, 2])
```

- Suma:

```{python}
resultado_1 = a + b
print("Suma usando +:", resultado_1) 

resultado_2 = np.add(a, b)
print("Suma usando add():", resultado_2) 
```

- Resta:

```{python}
resultado_1 = a - b
print("Resta usando -:", resultado_1) 

resultado_2 = np.subtract(a, b)
print("Resta usando subtract():", resultado_2) 
```

- Multiplicaci√≥n:

```{python}
resultado_1 = a * b
print("Multiplicaci√≥n usando *:", resultado_1) 

resultado_2 = np.multiply(a, b)
print("Multiplicaci√≥n usando multiply():", resultado_2) 
```

- Divisi√≥n:

```{python}
resultado_1 = a / b
print("Divisi√≥n usando /:", resultado_1) 

resultado_2 = np.divide(a, b)
print("Divisi√≥n usando divide():", resultado_2) 
```

- Potencia:

```{python}
resultado_1 = a ** b
print("Potencia usando **:", resultado_1) 

resultado_2 = np.power(a, b)
print("Potencia usando power():", resultado_2) 
```

::: {.callout-note}
Note que si quisi√©ramos operar con un vector `b` de elementos iguales, podr√≠amos utilizar un escalar.
:::

```{python}
b = np.array([2, 2, 2, 2])

resultado_1 = a * b
print("Usando un vector b = [2, 2, 2, 2]:", resultado_1) 

resultado_2 = a * 2
print("Usando un escalar b = 2:", resultado_2) 
```

#### Logaritmo:

NumPy provee funciones para los logaritmos de base 2, 10 y e:

| Base | Funci√≥n |
| --- | --- |
| 2 | `log2()` |
| 10 | `log10()` |
| e | `log()` |

Por ejemplo:

```{python}
# Ejemplo log2()
print("Logaritmo base 2:", np.log2([2, 4, 8, 16]))
# Ejemplo log10()
print("Logaritmo base 10:", np.log10([10, 100, 1000, 10000]))
# Ejemplo log()
print("Logaritmo base e:", np.log([1, np.e, np.e**2]))
```

::: {.callout-note}
Note que el n√∫mero de Euler o n√∫mero e es una constante incluida en NumPy como: `np.e`
:::

```{python}
np.e
```

:::{.callout-note collapse="true"}
#### Funciones trigonom√©tricas (opcional)
Esta parte del apunte es opcional, es decir, no se eval√∫a en los ex√°menes.
A continuaci√≥n, una lista con las funciones trigonom√©tricas m√°s utilizadas, que toman los valores en radianes:

| Funci√≥n trigonom√©trica | Funci√≥n |
| --- | --- |
| seno | `sin()` |
| coseno | `cos()` |
| tangente | `tan()` |
| arcoseno | `arcsin()` |
| arcocoseno | `arccos()` |
| arcotangente | `arctan()` |

Por ejemplo:

```{python}
# Ejemplo de seno
print("Seno de œÄ / 2:", np.sin(np.pi / 2))

# Ejemplo de arcoseno
print(np.arcsin(1))
```

```{python}
# Ejemplo de coseno
print("Coseno de œÄ:", np.cos(np.pi))

# Ejemplo de arcocoseno
print("Arcoseno de -1:", np.arccos(-1))
```

```{python}
# Ejemplo de tangente:
print("Tangente de 0:", np.tan(0))

# Ejemplo de arcotangente:
print("Arcotangente de 0:", np.arctan(0))
```

::: {.callout-note}
Note que el n√∫mero œÄ es una constante incluida en NumPy como: `np.pi`
:::

```{python}
np.pi
```

Para convertir los radianes a grados y viceversa, se utiliza `deg2rad()` y `rad2deg()` respectivamente:

```{python}
print("De grados [90, 180, 270, 360] a radianes:", 
      np.deg2rad([90, 180, 270, 360]))

print("De radianes [œÄ/2, œÄ, 1.5*œÄ, 2*œÄ] a grados:", 
      np.rad2deg([np.pi/2, np.pi, 1.5*np.pi, 2*np.pi]))
```
:::

#### Operaciones con matrices:

A continuaci√≥n, una lista con las operaciones que les pueden ser de inter√©s mientras estudian √°lgebra matricial:

| Funci√≥n | Descripci√≥n | Comentario |
| --- | --- | --- |
| `dot()` | Producto escalar | Se utiliza para obtener el producto escalar entre dos vectores. El resultado es un n√∫mero. |
| `dot()` | Producto vectorial | Tambi√©n se utiliza para multiplicar matrices. El resultado es una matriz |
| `transpose()` | Traspuesta | Cambia las filas por las columnas y viceversa |
| `linalg.inv()` | Inversa | Inversa de una matriz |
| `linalg.det()` | Determinante | Determinante de una matriz |
| `eye()` | Matriz identidad | Matriz cuadrada con unos en la diagonal principal y ceros en el resto |

Definimos los arreglos 1 y 2, y matrices 1 y 2 con los que operaremos y veremos ejemplos:

```{python}
# Crear arreglos
arreglo_1 = np.array([1, 2])
arreglo_2 = np.array([3, 4])

# Crear matrices
matriz_1 = np.array([[1, 3], [5, 7]])
matriz_2 = np.array([[2, 6], [4, 8]])
```

```{python}
print("Producto escalar entre el array 1 y 2: \n", np.dot(arreglo_1, arreglo_2))
```

```{python}
print("Producto vectorial entre la matriz 1 y 2: \n", np.dot(matriz_1, matriz_2))
```

```{python}
print("Traspuesta de la matriz 1: \n", np.transpose(matriz_1))
```

```{python}
print("Inversa de la matriz 1: \n", np.linalg.inv(matriz_1))
```

```{python}
print("Determinante de la matriz 1: \n", np.linalg.det(matriz_1))
```

::: {.callout-note}
Note que as√≠ como existen constantes num√©ricas, existen las matrices particulares como las compuestas por ceros `np.zeros()`, por unos `np.ones()` y la matriz identidad `np.eyes`.
:::

```{python}
print("Matriz de identidad de 3x3: \n", np.eye(3))
```

#### M√°s operaciones √∫tiles:

| Operaciones | Funci√≥n | Descripci√≥n |
| --- | --- | --- |
| M√°ximo | `max()` | Valor m√°ximo del array o del eje indicado |
| M√≠nimo | `min()` | Valor m√≠nimo del array o del eje indicado |
| Suma | `sum()` | Suma de todos los elementos o del eje indicado |
| Promedio | `mean()` | Promedio de todos los elementos o del eje indicado |

Utilizando la matriz **data** como ejemplo:

```{python}
data = np.array([[1, 2], [5, 3], [4, 6]])
```

- Valor m√°ximo

```{python}
print("Valor m√°ximo de todo el array: ", data.max())
print("Valores m√°ximos de cada columna: ", data.max(axis=0))
```

- Valor m√≠nimo

```{python}
print("Valor m√≠nimo de todo el array: ", data.min())
print("Valores m√≠nimos de cada fila: ", data.min(axis=1))
```

- Suma de elementos:

```{python}
print("Suma de todos los elementos del array: ", data.sum())
print("Suma de los elementos de cada fila: ", data.sum(axis=1))
```

- Promedio:

```{python}
print("Promedio de todos los elementos del array: ", data.mean())
print("Promedio de los elementos de cada columna: ", data.mean(axis=0))
```

::: {.callout-note}
Numpy te va a ser muy √∫til cuando curses materias como An√°lisis Matem√°tico, √Ålgebra, F√≠sica, Estad√≠stica, entre otras. Te va a permitir realizar operaciones de manera r√°pida y eficiente, y te va a ayudar a entender mejor los conceptos.
:::

## Pandas

Pandas es una biblioteca de c√≥digo abierto dise√±ada espec√≠ficamente para la manipulaci√≥n y el an√°lisis de datos en Python. Es una herramienta poderosa que puede ayudar a los usuarios a limpiar, transformar y analizar datos de una manera r√°pida y eficiente.

Al igual que Numpy, se debe importar. Por convenci√≥n: 

```{python}
import pandas as pd
```

Los datos a trabajar en Pandas van a tener, en general, una forma muy similar a las tablas:

![Esquema de figuras y axes](./imgs/unidad_6/pandas.png)

Pandas es una biblioteca un poco m√°s pesada, por lo que vamos a poder aprovechar mucho m√°s <a href="https://colab.research.google.com/" target="_blank">Google Colab</a>, que maneja grandes datos de forma r√°pida y eficiente.

### Serie

Pandas incorpora dos estructuras de datos nuevas llamadas: **Series** y **DataFrames**.

Una **serie** es un vector capaz de contener cualquier tipo de dato, como por ejemplo, n√∫meros enteros o decimales, strings, objetos de Python, etc.

#### Creaci√≥n de una Serie
Para crearlas, se puede partir de un escalar, una lista, un diccionario, etc., utilizando `pd.Serie()`:

```{python}
# Crear serie partiendo de una lista:
lista = [1, "a", 3.5]

pd.Series(lista)
```

Esto es an√°logo a lo que se hac√≠a con los arrays de Numpy, pero con la diferencia de que las series de Pandas pueden contener datos de distinto tipo.

Notemos que se ven dos l√≠neas verticales de datos en el output. A la derecha se observa una columna con los elementos de la lista antes creada, y a la izquierda se encuentra el **√≠ndice**, formado por valores desde 0 a n-1, siendo n la cantidad de elementos. Este √≠ndice num√©rico es el predefinido, que nos muestra la posici√≥n de los elementos dentro de la Serie.\
Tambi√©n podr√≠amos cambiarlo si quisi√©ramos. En ese caso, se puede establecer utilizando `index`.

El √≠ndice es de vital importancia ya que permite acceder a los elementos de la serie (muy parecido a c√≥mo las claves nos permiten acceden a los valores de un diccionario). Al elegir √≠ndices personalizados, tenemos que tener en cuenta que su longitud debe ser acorde al n√∫mero de elementos de la Serie. De lo contrario, se mostrar√° un ValueError. 

```{python}
# Crear serie partiendo de una lista, indicando el √≠ndice
pd.Series(lista, index = ["x", "y", "z"])
```

Tambi√©n podemos crear Series utilizando diccionarios, y en ese caso, sus claves (o keys) pasan a formar el √≠ndice.

```{python}
# Crear serie partiendo de un diccionario:
diccionario = {"x": 1, "y": "a", "z": 3.5}

a = pd.Series(diccionario)
a
```

#### Accediendo a un elemento

Como ya se debe estar imaginando, para acceder a un elemento de la serie, se debe indicar el valor del √≠ndice.

```{python}
# Acceder al elemento de √≠ndice y:
a["y"]
```

Si los √≠ndices son num√©ricos, simplemente se le pasa entre corchetes un n√∫mero.

#### Operaciones con Series
As√≠ como pasaba con los arrays de NumPy, las Series no requieren recorrer valor por valor en un ciclo for si queremos realizar operaraciones. Podemos usar directamente operadores con Series.\
Por ejemplo:

```{python}
a + a
```

```{python}
a * 3
```

### DataFrame

Un **DataFrame** es una estructura de datos tabular **(bidimensional, en forma de tabla)**, compuesta por filas y columnas, que se parece mucho a una hoja de c√°lculo de Excel.

#### Creando DataFrames

Para crearlos, se utiliza `DataFrame()` y se ingresan diferentes estructuras como arrays, diccionarios, listas, series u otros dataframes.

En el siguiente ejemplo, se crea un Dataframe partiendo de un diccionario llamado `data` para las columnas y de una lista `label` para el √≠ndice:

```{python}
data = {'columna_1': ['a', 'b', 'c', 'd', 'e', 'f'],
        'columna_2': [2.5, 3, 0.5, None, 5, None],
        'columna_3': [1, 3, 2, 3, 2, 3]}

labels = ['a1', 'a2', 'a3', 'a4', 'a5', 'a6']

df = pd.DataFrame(data, index=labels)
df
```

Lo que vemos ac√° es el output de ejecutar el c√≥digo de arriba en una celda: una tabla donde tenemos 3 columnas, y el √≠ndice de cada fila son los elementos de la lista `labels`.

En vez de tener un valor `None`, Pandas lo recibe y lo transforma en `NaN`, que significa "Not a Number". Esto es muy √∫til para trabajar con datos faltantes, ya que Pandas nos permite realizar operaciones con ellos sin que nos de error (a diferencia de Python).

#### Atributos y descripci√≥n de un Dataframe

A continuaci√≥n, se observa una tabla con m√©todos que nos permiten conocer las caracter√≠sticas de un determinado DataFrame.

| M√©todo o atributo | Descripci√≥n |
| --- | --- |
| `.info()` | Resume la informaci√≥n del DataFrame |
| `.shape` | Devuelve una tupla con el n√∫mero de filas y columnas |
| `.size` | N√∫mero de elementos, aunque tambi√©n puede usarse `len` |
| `.columns` | Lista con los nombres de las columnas |
| `.index` | Lista con los nombres de las filas |
| `.dtypes` | Serie con los tipos de datos de las columnas |
| `.head()` | Muestra las primeras filas |
| `.tail()` | Muestra las √∫ltimas filas |
| `.describe()` | Brinda m√©tricas de las columnas num√©ricas |

Para ejemplificar los m√©todos y las funciones de Pandas, usaremos el **DataFrame df** definido en el siguiente bloque de c√≥digo.

```{python}
data = {'nombre': ['Jos√© Mart√≠nez', 'Rosa D√≠az', 'Javier Garc√≠az', 'Carmen L√≥pez', 'Marisa Collado', 'Antonio Ruiz', 'Antonio Fern√°ndez', 
                   'Pilar Gonz√°lez', 'Pedro Tenorio', 'Santiago Manzano', 'Macarena √Ålvarez', 'Jos√© Sanz', 'Miguel Guti√©rrez', 'Carolina Moreno'],
        'edad': [18, 32, 24, 35, 46, 68, 51, 22, 35, 46, 53, 58, 27, 20],
        'genero': ['H', 'M', 'H', 'M', 'X', 'H', 'H', 'M', 'H', 'X', 'M', 'H', 'H', 'M'],
        'peso': [85.0, 65.0, None, 65.0, 51.0, 66.0, 62.0, 60.0, 90.0, 75.0, 55.0, 78.0, 109.0, 61.0],
        'altura': [1.79, 1.73, 1.81, 1.7, 1.58, 1.74, 1.72, 1.66, 1.94, 1.85, 1.62, 1.87, 1.98, 1.77],
        'colesterol': [182.0, 232.0, 191.0, 200.0, 148.0, 249.0, 276.0, None, 241.0, 280.0, 262.0, 198.0, 210.0, 194.0]}

df = pd.DataFrame(data)
df
```

\

:::{.callout-note}
Muchas veces no vamos a querer modificar el dataframe original, pero sin manipularlo. En ese caso, podemos hacer una copia del dataframe original, de esta forma: `df_copy = df.copy()`
:::

##### Info, dtypes, columns e index

Con `info()` se puede ver:

- el √≠ndice en la primera l√≠nea, que es un rango de 0 a 13
- el n√∫mero total de columnas en la segunda l√≠nea
- el uso de la memoria en la √∫ltima
- una tabla con los nombres de las columnas en **Column**, la cantidad de valores no nulos en **Non-Null Count** y el tipo de dato en **Dtype** para cada una de ellas.

```{python}
df.info()
```

Note que utilizando `dtypes`, `columns` e `index` se obtiene parte de esta informaci√≥n:

```{python}
# Tipo de dato por columna
df.dtypes
```

```{python}
# Nombre de cada columna
df.columns
```

```{python}
# √≠ndice
df.index
```

\ 

##### Shape y Size

La forma del DataFrame es de 14 filas y 6 columnas, por lo que contiene 84 elementos.

```{python}
# Forma del DataFrame (filas, columnas)
df.shape
```

```{python}
# N√∫mero de elementos del DataFrame
df.size
```

\

##### Head y Tail

Asimismo, cuando no conocemos un DataFrame, puede ser importante ver las primeras 5 filas con `head()` o las √∫ltimas con `tail()`. Si se quisiera observar un n√∫mero determinado, s√≥lo hay que especificarlo, por ejemplo:

```{python}
# Mostrar las primeras 3 filas.
df.head(3)
```

```{python}
# Mostrar las √∫ltimas 5 filas.
df.tail()
```

\

##### Describe

Por otro lado, `describe()` devuelve un resumen descriptivo de las columnas de valores num√©ricos, como "edad", "peso", "altura" y "colesterol".

```{python}
df.describe()
```

Estas m√©tricas podr√≠an obtenerse de forma puntual (tanto para todo el DataFrame como para s√≥lo una columna) utilizando funciones determinadas, como:\

- `count()`: contabiliza los valores no nulos
- `mean()`: promedio
- `min()`: valor m√≠nimo
- `max()`: valor m√°ximo

Por ejemplo:

```{python}
df.count()
```

```{python}
df.min()
```

```{python}
df.max()
```

#### Accediendo a filas de un DataFrame

Finalmente, como ocurre con las series, para acceder a los elementos de un DataFrame se puede indicar la posici√≥n o el nombre de la fila o columna.

Para acceder a una fila en particular, utilizamos `iloc[]`.
Podemos pasarle a `iloc` un entero, una lista de enteros, un rango de n√∫meros (que indican las posiciones) o directamente el valor del √≠ndice. 

```{python}
# Mostrar la fila de posici√≥n 0, usando doble corchete [[]]
# Recibe una lista de elementos a mostrar (que contiene s√≥lo al 0)
df.iloc[[0]]
```

<br>
Si queremos mostrar un rango, lo hacemos as√≠:
<br>

```{python}
# Mostrar las filas de posici√≥n 0 y 3, usando doble corchete [[]]
# Recibe una lista de elementos a mostrar
df.iloc[[0, 3]]
```

<br>
<br>

```{python}
# Mostrar las filas de posiciones entre 0 hasta 3 (exclusive)
# Usa slices
df.iloc[:3]
```

<br>

```{python}
# El equivalente a df.iloc[:3] es el uso de head(3)
df.head(3)
```

<br>

#### Accediendo a columnas de un DataFrame

A veces no queremos s√≥lo acceder a filas, sino a columnas. Por ejemplo, para calcular sumas, promedios, m√°ximos o m√≠nimos, etc.

Para acceder a una **columna** se pueden utilizar una lista con los nombres de las columnas que se quieren mostrar: `DataFrame[[columna1, columna2]]`.

```{python}
# Mostrar la columna "nombre"
df[['nombre']]
```

<br>

```{python}
# Mostrar m√°s de una columna: "nombre" y "edad":
df[['nombre', 'edad']]
```

De esta forma, podr√≠amos hacer algo as√≠:

```{python}
# calculamos el promedio para los valores de la columna 'edad'
df[['edad']].mean()
```

#### Modificar un Dataframe

A la hora de modificar un DataFrame, tenemos distintas posibilidades:\

- Cambiar la estructura del mismo, como los nombres de las columnas y de los √≠ndices,
- Agregar una nueva filas o columna
- Reemplazar un dato en una determinada posici√≥n.

A continuaci√≥n, se enumeran distintos m√©todos para llevar a cabo estos cambios.

| M√©todo | Descripci√≥n |
| --- | --- |
| `rename()` | Renombra las columnas |
| `insert()` | Agrega columnas |
| `drop()` | Elimina columnas y filas |
| `loc[fila]` | Agrega una fila en un √≠ndice dado |
| `loc[fila, columna]` | Modifica un valor particular dado un √≠ndice y una columna |
| `map()` | Busca un valor dado en una columna y lo reemplaza |
| `replace()` | Reemplaza un valor dado en una columna |

<br>

##### Rename, insert y drop

Para renombrar una columna, se utiliza un diccionario: `rename(columns={"nombre_columna": "nuevo_nombre_columna"})` 

```{python}
# Reemplazo "nombre" por "nombre y apellido"
df = df.rename(columns={"nombre": "nombre y apellido"})
df.head() # para que veamos el cambio de nombre en la columna
```

<br>
Para agregar una nueva columna, existe el m√©todo `insert()`, que requiere indicar la posici√≥n de la nueva columna, el nombre de la nueva columna, y los valores de la misma. 

Vamos a crear una lista llamada **direccion** con 14 valores, para cada una de las personas del DataFrame, y luego agregarla en la posici√≥n 3:

```{python}
# Valores de la nueva columna
direccion = ["CABA", "Bs As", "Bs As", "Bs As", "CABA", "Bs As", "CABA", "CABA", "CABA", "CABA", "CABA", "Bs As", "CABA", "CABA"]

# Insertar la columna "direccion" en la posici√≥n 3 de columnas:
df.insert(3, "direccion", direccion)
df.head() # para que veamos que la columna nueva se agreg√≥
```

Para agregar una nueva columna tambi√©n podemos hacerlo directamente, como si fuera un diccionario: `df['nueva_columna'] = valores`.

Por ejemplo, supongamos que queremos ingresar una columna con el √≠ndice de masa corporal de las personas., que se calcula de la siguiente manera: 

$$IMC = \frac{Peso(kg)}{Altura(m)^2}$$

Esto podemos hacerlo directamente trabajando sobre las columnas, como trabaj√°bamos sobre los arrays de NumPy; y guardando el resultado en una nueva columna llamada "IMC".

```{python}
# Crear la columna "IMC"
df["IMC"] = df["peso"] / df["altura"]**2
df.head()
```

Esto lo que va a hacer es tomar todos los valores de peso y altura de cada fila, calcular el IMC y guardarlo en una nueva columna de la l√≠nea, bajo el nombre "IMC".

De manera similar, se puede crear la columna **dni** sin utilizar `insert()`, usando la lista **dni**:

```{python}
df_copy = df.copy() # Hacemos una copia, para que no nos afecte el original
dni = [12345678, 23456789, 34567890, 45678901, 56789012, 67890123, 78901234, 89012345, 90123456, 12345678, 23456789, 34567890, 45678901, 56789012]
df_copy["dni"] = dni
df_copy.head()
```

Por lo que vemos que no es indispensable usar `insert` para poder agregar una nueva columna, pero `insert` nos permite decir *en d√≥nde* queremos agregarla.

<br>

Para eliminar una fila `(axis=0)` o columna `(axis=1)`, se utiliza `drop()`:

```python
# Elimino una columna llamada "direccion". Tambi√©n podr√≠a hacer: `del df["direccion"]`
df = df.drop('direccion', axis=1)  
```

<br>

```python
# Elimino la fila 14
df = df.drop(14, axis=0) 
```

#### Insertar filas

Para agregar una nueva fila, se utiliza `loc[]`, que nos pide indicar el √≠ndice y los valores de la misma. Para ello, creamos una lista llamada **nueva_fila** con valores para cada columna del DataFrame.


```{python}
# Valores de la nueva fila
nueva_fila = ['Carlos Rivas', 30, 'H', "CABA", 70.0, 1.75, 203.0, 22]

# Insertamos al final del DataFrame
largo = len(df.index) # o tambi√©n: largo = df.shape[0], para obtener la cantidad de filas
df.loc[largo] = nueva_fila
df.tail() # Para ver que se agreg√≥ al final
```

:::{.callout-note collapse="true"}
### ¬øPor qu√© usamos 'len' arriba?
A diferencia de Python, podemos agregar una fila en una posici√≥n que no existe a√∫n. Por eso arriba pudimos hacer `df.loc[largo]`.
:::

#### Modificar un valor

Finalmente, **para cambiar un valor determinado** tambi√©n se utiliza `loc[]`, como por ejemplo, agregar el peso de Javier Garc√≠a (tercera fila), que antes ten√≠a `NaN`:

```{python}
df.loc[2, 'peso'] = 92
df.head()
```

<br>

Para transformar los valores de una columna entera, podemos utilizar `map()` pasando un diccionario del estilo `{valor_viejo: valor_nuevo}`. Por ejemplo, modificar la columna "genero" reemplazando "H" por "M", "M" por "F":

```{python}
df['genero'] = df['genero'].map({'H': 'M', 'M': 'F', 'X': 'X'})
df.head()
```

<br>

Otra manera ser√≠a utilizando `replace()`. Por ejemplo, en la columna "direccion" vamos a modificar "Bs As" por "Buenos Aires".

```{python}
df['direccion'] = df['direccion'].replace('Bs As', 'Buenos Aires')
df.head()
```

#### Filtrar un Dataframe

Para filtrar los elementos de un DataFrame se suelen utilizar condiciones l√≥gicas de la siguiente forma: `DataFrame[ condicion ]`.

Por ejemplo:

```{python}
# Seleccionar aquellas personas menores de 40 a√±os
# La condici√≥n es que la columna 'edad' del dataframe tenga valor menor a 40
df[ df['edad'] < 40 ] 
```

<br>
Cuando se requieren m√∫ltiples condiciones, se puede adicionar usando s√≠mbolos como `&` para **and** y `|` para **or**. Por ejemplo:

```{python}
# Seleccionar aquellas personas de genero femenino y menores de 40 a√±os:
df[ (df['edad'] < 40) & (df['genero'] == 'F') ]
```

<br>

```{python}
# Seleccionar aquellas personas cuyo peso es 60kg o 90kg:
df[(df['peso'] == 60.0) | (df['peso'] == 90.0)]
```

<br>

Tambi√©n puedo filtrar las fillas por el valor `NaN`.\
Para eso, se utiliza la funci√≥n `isnull()` que devuelve `True` si el valor de la columna es nulo o NaN. Por ejemplo:

```{python}
df['IMC'].isnull()
```

Para visualizar aquellas filas donde el √≠ndice de masa corporal es nulo, filtramos:

```{python}
df[df['IMC'].isnull()]
```

El m√©todo opuesto es `notnull()`, que devuelve `True` si el valor de la columna no es nulo o NaN. Por ejemplo:

```{python}
df[df['IMC'].notnull()]
```

#### Ordenando, Contando y Agrupando

A continuaci√≥n, se muestra una lista con m√©todos que resultan muy √∫tiles a la hora de analizar datos: 

| M√©todo | Descripci√≥n |
| --- | --- |
| `sort_values(by, ascending)` | Ordena el DataFrame considerando los valores de la o las columnas determinadas y devuelve un DataFrame nuevo (no modifica el original) |
| `value_counts()` | Indica los valores √∫nicos de una determinada columna y el n√∫mero de veces que aparece en ella |
| `groupby().func()` | Agrupa las filas seg√∫n ciertos valores de columnas. Requiere que apliquemos una funci√≥n luego para que 'agrupe' los datos. |

##### Sort value:
  
Para utilizar la funci√≥n `sort_values(by, ascending)`, se debe indicar en el par√°metro `by` una lista con las columnas para ordenar el DataFrame y en `ascending`, `True` si el orden deseado es creciente o `False` para decreciente.

En el siguiente ejemplo ordenamos por "nombre y apellido" en forma alfab√©tica: 

```{python}
df.sort_values(by=['nombre y apellido'], ascending=[True])
```

**¬øQu√© ocurre cuando ordenamos siguiendo varias columnas?** Los valores del DataFrame se ordenan siguiendo la primera columna en primer lugar, luego la segunda, y as√≠ sucesivamente.

```{python}
df.sort_values(by=['genero', 'nombre y apellido'], ascending=[True, True])
```

En el ejemplo de arriba, primero se ordena de manera creciente por genero, resultando en tres grupos: "genero" = "F", "M" y "X". Luego, cada uno de esos grupos se ordena por "nombre y apellido" de forma creciente.

![Ejemplo de sort_values()](./imgs/unidad_6/sortvalues.png)

##### Value Count:

Utilizando `value_counts()` se pueden contar las filas en cada grupo seg√∫n "direccion". Es decir, cuenta cu√°ntas apariciones hay de cada valor en una columna.

```{python}
df['direccion'].value_counts()
```

##### Group by:
  
`groupby()` es un m√©todo que nos permite agrupar los datos del DataFrame seg√∫n los valores de una o unas columnas dadas, transform√°ndose estas en el nuevo √≠ndice de los grupos. Por ejemplo, si quisi√©ramos agrupar por direcci√≥n y obtener la cantidad de apariciones de cada valor:

```{python}
# Agrupar por "direccion" y devolver la cantidad de cada uno
df_copy.groupby(['direccion']).size()
```

Obteniendo una tabla con valores agrupados por "direccion", siendo esta columna el nuevo √≠ndice.

```{python}
# Agrupar por "direccion" y "genero" y mostrar el promedio de las columnas de 'edad' y 'peso'
df.groupby(['direccion', 'genero'])[['edad', 'peso']].mean()
```

Tambi√©n puedo agrupar por m√°s de una columna, y aplicar distintas funciones a las columnas. Por ejemplo, si quisiera agrupar por "direccion" y "genero" y obtener el promedio de la columna "edad" y la suma de la columna "peso", puedo usar `agg`, que significa "aggregate" (que significa 'agregar') y me pemite, para cada columna, pasarle una funci√≥n a aplicar:

```{python}
df.groupby(['direccion', 'genero']).agg({'edad': 'mean', 'peso': 'sum'})
```

### Conclusiones
Pandas nos permite trabajar con datos de una manera muy sencilla y eficiente. Nos permite importar datos de distintas fuentes, limpiarlos, transformarlos y analizarlos. Adem√°s, nos permite visualizar los datos de una manera muy amigable, lo que nos va a permitir entender mejor los datos con los que estamos trabajando.

## Matplotlib

:::{.callout-note}
Para Matplotlib tambi√©n vamos a usar Google Colab
:::

Matplotlib es probablemente la biblioteca de Python m√°s usada para crear gr√°ficos, tambi√©n llamados **plots**. Esta biblioteca provee una forma r√°pida de graficar datos en varios formatos de alta calidad que pueden ser compartidos y/o publicados.

El primer paso es importar la biblioteca. Por convenci√≥n:

```{python}
import matplotlib.pyplot as plt
```

### Introducci√≥n

Para crear un gr√°fico con matplotlib, se deben seguir los siguientes pasos:

1. **Crear la figura** que contendr√° el gr√°fico, utilizando las funciones `subplots()` o `figure()`. Se recomienda la primera, es la que va a utilizarse en la materia.

2. **Graficar los datos**, utilizando distintas funciones dependiendo del tipo de gr√°fico que se desea realizar:


  | Funci√≥n | Tipo de Gr√°fico |
  | --- | --- |
  | `plot()` | Gr√°fico de l√≠nea |
  | `scatter()` | Gr√°fico de puntos |
  | `bar()` | Gr√°fico de barras verticales |
  | `barh()` | Gr√°fico de barras horizontales |
  | `pie()` | Gr√°fico de torta |


3. **Personalizar el gr√°fico**. Este paso es muy recomendado para lograr un mejor entendimiento de la visualizaci√≥n. Esto incluye agregar etiquetas a los ejes, t√≠tulos, leyendas, etc. Tambi√©n podemos modificar el aspecto de las l√≠neas, los puntos, los colores, y m√°s (esto se deja en el final del apunte, y es opcional).

4. **Mostrar el gr√°fico**, utilizando la funci√≥n `show()`

  ```python
  plt.show()
  ```

<hr>

### Creando una figura

Para crear una figura, la funci√≥n de gr√°fico recibe los datos a graficar y los par√°metros necesarios para personalizarlo.

#### Gr√°fico de l√≠nea
El gr√°fico de l√≠nea permite visualizar cambios en los valores lo largo de un rango continuo (tendencias), como puede ser el tiempo o la distancia.\
Para crear un gr√°fico de l√≠nea, se utiliza la funci√≥n `plot()`.

```{python}
# Grafico elemental
x = [0,2,10,11,18,25]
y = [0,1,2,3,4,5]

fig, ax = plt.subplots()

# Gr√°fico de l√≠nea
ax.plot(x, y)
plt.show()
```

En este caso, se cre√≥ un gr√°fico de l√≠nea con los valores de **x** e **y**, tal que los puntos (0,0), (2,1), (10,2), (11,3), (18,4) y (25,5) est√°n unidos por una l√≠nea recta.

#### Gr√°fico de puntos
El gr√°fico de dispersi√≥n o puntos permite visualizar la relaci√≥n entre las variables.\
Para crearlo, se utiliza la funci√≥n `scatter()`:

```{python}
# Gr√°fico de puntos
fig2, ax2 = plt.subplots()
ax2.scatter(x, y)
plt.show()
```

:::{.callout-important}
### Grillas
¬øVes c√≥mo en el gr√°fico de puntos quiz√°s no se entiende bien la ubicaci√≥n de cada punto?\
Esto es porque no tenemos una gu√≠a que nos ayude. Para eso, vamos a agregar una grilla.
La grilla se puede agregar con al funci√≥n `grid()`, y es una buena forma de darle legibilidad a un gr√°fico como puede ser el de l√≠nea y el de puntos.\
:::

```{python}
# Gr√°fico de puntos
fig, ax = plt.subplots()
ax.scatter(x, y)
ax.grid()
plt.show()
```

#### Gr√°ficos de Barras

El gr√°fico de barras permite visualizar proporciones, comparando dos o m√°s valores entre s√≠. Para crearlo, se utiliza la funci√≥n `bar()`, la cual primero recibe, en primer lugar, las etiquetas de las barras que se van a mostrar y en segundo lugar, la altura correspondiente a cada una de estas barras.

En el caso de este tipo de gr√°fico, **no hace falta que los valores de las etiquetas sean num√©ricos**.

```{python}
peso = [340, 115, 200, 200, 270]
ingredientes = ['chocolate', 'manteca', 'az√∫car', 'huevo', 'harina']

fig, ax = plt.subplots()

ax.bar(ingredientes, peso) # Ac√° podr√≠a usarse tambi√©n barh

ax.set_xlabel('Ingredientes')
ax.set_ylabel('Masa (g)')

ax.set_title("Receta")

plt.show()
```

#### Gr√°fico de torta

Finalmente, tenemos el gr√°fico de torta. El gr√°fico de torta, como el de barras, permite visualizar y comparar proporciones pero de manera circular y como partes de un todo.

Para crearlo, se utiliza la funci√≥n `pie()`, que recibe los valores de las porciones y las etiquetas de cada una. Para las etiquetas, se debe indicar la variable `label`, y si adem√°s queremos que se muestren los porcentajes, se puede utilizar `autopct='%1.1f%%'`. `'%1.1f%%'` significa que se mostrar√° un decimal y el s√≠mbolo de porcentaje. 

```{python}
peso = [340, 115, 200, 200, 270]
ingredientes = ['chocolate', 'manteca', 'az√∫car', 'huevo', 'harina']

fig, ax = plt.subplots()

ax.pie(peso, labels= ingredientes, autopct='%1.1f%%')

ax.set_title("Receta")

plt.show()
```

#### Cambio de Tama√±o

Podemos establecer el tama√±o de la figura con el par√°metro `figsize` dentro de la funci√≥n `subplots()`. Este par√°metro recibe una tupla con dos valores: el ancho y el alto de la figura, en pulgadas.

Veamos este ejemplo: **x** es el tiempo medido en minutos e **y** una distancia en metros, entonces:

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots(figsize=(3, 5))

ax.plot(x, y)

plt.show()
```


### T√≠tulos
As√≠ como los nombres de las variables en nuestro c√≥digo, es importante que nuestro gr√°fico tenga un T√≠tulo descriptivo que nos ayude a entender qu√© es lo que estamos viendo. Lo mismo pasa con los ejes: queremos poder entender qu√© representa cada uno.

Para setear un t√≠tulo, vamos a usar la funci√≥n `set_title()`. Para los ejes, usaremos `set_xlabel()` y `set_ylabel()`. Cada una recibe un string que se usar√° como etiqueta del eje X, etiqueta del eje Y o t√≠tulo, respectivamente.

Siguiendo el ejemplo anterior, vamos a agregar t√≠tulos a los ejes y al gr√°fico:

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y)

# Mostrar el t√≠tulo del gr√°fico
ax.set_title("Gr√°fico de posici√≥n")

# Mostrar el t√≠tulo de los ejes
ax.set_xlabel('Tiempo (min)')
ax.set_ylabel('Distancia (m)')


ax.grid()
plt.show()
```

### Referencias
El gr√°fico con el que estamos trabajando s√≥lo tiene una l√≠nea, pero si contara con m√°s de una (lo vamos a ver m√°s adelante en este apunte), el uso de referencias ser√≠a muy importante para lograr el entendimiento del mismo. Para rotular las l√≠neas, dentro de `plot()` se debe definir la referencia como `label`. Luego se coloca `legend()`

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, label='Objeto 1') # Agregar el label

ax.set_title("Gr√°fico de posici√≥n")
ax.set_xlabel('Tiempo (min)')
ax.set_ylabel('Distancia (m)')

# Agregar la refencia
ax.legend()

ax.grid()
plt.show()
```

### Gr√°ficos m√∫ltiples

En los casos anteriores, creamos siempre un s√≥lo gr√°fico con una curva, en una figura. Pero **Tambi√©n podr√≠amos graficar varias curvas en un mismo gr√°fico**.

Para esto vamos a seguir el mismo procedimiento que antes, pero vamos a agregar m√°s de un `plot()` al mismo axes. Tambi√©n vamos a darles un label a cada uno, y luego vamos a agregar una leyenda. Autom√°ticamente, al estar en el mismo axes, matplotlib los va a agregar al mismo gr√°fico con distintos colores.

```{python}
# Valores que se desean graficar
x = [0, 1, 2, 3, 4, 5]
y_linear = [0, 1, 2, 3, 4, 5]
y_quadratic = [0, 1, 4, 9, 16, 25]
y_cubic = [0, 1, 8, 27, 64, 125]

fig, ax = plt.subplots()

# Usamos distintos tipos de y, con distintas labels
ax.plot(x, y_linear, label='Lineal')
ax.plot(x, y_quadratic, label='Cuadr√°tico')
ax.plot(x, y_cubic, label='C√∫bico')

ax.set_title("Gr√°fico de m√∫ltiples curvas")
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.legend()

plt.show()
```

Note que se agregan nuevos datos al mismo axes, por lo que siempre usamos `plot()` pero con distintos valores de `y`. Asimismo, se estableci√≥ un tama√±o de la figura con `figsize=(width, height)`

### Uniendo Bibliotecas

#### Matplotlib y Numpy
Podemos usar arrays de numpy para simplificarnos el trabajo.\
Repetimos el gr√°fico anterior pero usando numpy, y vamos a ver que pudimos obtener muchos m√°s valores sin tener que calcularlos nosotros y escribirlos en una lista de Python.

```{python}
import numpy as np

x = np.linspace(0, 5, 100) # Creamos un array de 100 valores entre 0 y 5
y_linear = x # usamos x
y_quadratic = x**2 # usamos x al cuadrado
y_cubic = x**3 # usamos x al cubo

fig, ax = plt.subplots()

# Usamos distintos tipos de y
ax.plot(x, y_linear, label='Lineal')
ax.plot(x, y_quadratic, label='Cuadr√°tico')
ax.plot(x, y_cubic, label='C√∫bico')

ax.set_title("Gr√°fico de m√∫ltiples curvas")
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.legend()

plt.show()
```

#### Matplotlib y Pandas
Tambi√©n podemos usar columnas de Pandas como datos para crear un gr√°fico.

Supongamos el siguiente dataframe de los datos de las mascotas en una veterinaria:

```{python}
data = { 'nombre': ['Bola de Nieve', 'Jerry', 'Hueso'],
        'especie': ['gato','chinchilla', 'perro'],
        'edad': [2.5, 3, 7],
        'visitas': [1, 3, 2],
        'prioridad': ['si', 'si', 'no']}

df = pd.DataFrame(data)
df
```

Podemos ahora crear un gr√°fico usando las columnas del dataframe:

```{python}
# Determino las columnas del DataFrame que queremos graficar
x_values = df['nombre']
y_values = df['edad']

fig, ax = plt.subplots()

ax.bar(x_values, y_values)

ax.set_xlabel('Paciente')
ax.set_ylabel('Edad (a√±os)')

ax.set_title("Mascotas")

plt.show()
```

:::{.callout-note collapse="true"}
#### ¬øQu√© pasa si nuestros labels no llegan a verse? (opcional)
Puede pasar, sobre todo si tenemos muchos datos con nombres largos, que nuestros labels no lleguen a verse de forma correcta si los presentamos de forma horizontal.\
Por ejemplo:

<img src="./imgs/unidad_6/matplotlib_labels_horizontales.png" width="300" />

En esos casos, podemos pedirle a matplotlib que los presente de forma vertical, para que no se superpongan. Para eso, usamos `xticks()` y `rotation`: `plt.xticks(rotation=90)`.\
El √°ngulo de rotaci√≥n se mide en grados, por lo que `rotation=90` significa que se rotar√°n 90 grados. De esta forma, los labels se presentar√°n de forma vertical. Podr√≠amos tambi√©n usar otro √°ngulo, y se mostrar√≠an los labels de forma inclinada.\
Esta es la forma en que se visualizan los datos con los labels rotados:

<img src="./imgs/unidad_6/matplotlib_labels_rotados.png" width="300" />

:::

### Bonus Track: Personalizaci√≥n (opcional)

:::{.callout-note}
#### ¬øQu√© significa opcional?
Significa que esta parte del apunte no es obligatoria. Pero si quieren leerla, les va a permitir hacer gr√°ficos m√°s bonitos y personalizados. Tambi√©n les va a permitir llevarse el conocimiento de qu√© otras herramientas tienen disponibles, y volver a este apunte a buscar informaci√≥n en un futuro si es que la necesitan.
:::

Esta imagen, fue obtenida de la referencia de matplotlib y resume de manera f√°cil y visual las modificaciones que podemos hacerla a las figuras creadas.

![Partes de una Figura. Si quer√©s conocer m√°s detalle, pod√©s ingresar a [este link](https://matplotlib.org/stable/tutorials/introductory/quick_start.html).](./imgs/unidad_6/matplotlib.png)

Como dijimos m√°s arriba, las figuras pueden ser personalizadas de muchas maneras. Algunas son:

- Colores
- Estilos de l√≠nea
- Marcadores
- Grilla personalizada

¬°y m√°s!

#### Cambiando colores y estilos

Para cambiar los colores de los gr√°ficos, podemos utilizar los par√°metros `color`, `marker`, `linestyle`, `markersize` y `linewidth` dentro de la funci√≥n `plot()`.

-  **color =** nombre del color, por ejemplo: `'blue', 'green', 'red'`, etc.
-   **marker =** forma de los puntos o marcadores, por ejemplo: `'^', 'o', 'v'`, etc.
-   **linestyle =** estilo de l√≠nea, por ejemplo: `'solid', 'dashed', 'dotted'` o sus equivalentes:` '-', '--', ':',` entre otros.
-   **markersize, linewidth =** con un n√∫mero, establecemos el tama√±o del marcador y el espesor de la l√≠nea respectivamente.

Si no le asignamos un valor, se establecen los predefinidos.

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)
plt.show()
```

#### Grilla personalizada:

Si deseamos modificarle a una grilla, por ejemplo, el color, el estilo de l√≠nea, o s√≥lo queremos ver uno de los ejes, podemos indicarlo utilizando par√°metros muy similares a los vistos anteriormente pero en la funcion `grid()`.

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)

#Grilla modificada
ax.grid(axis = 'y', color = 'gray', linestyle = 'dashed')
plt.show()
```

<hr>

Con esto finalizamos los temas de la materia.\
¬°Esperamos que hayas disfrutado de este recorrido!\
Record√° que si quer√©s dejarnos feedback pod√©s hacerlo en el formulario que est√° en la parte de [Contacto](contact.qmd#feedback).

Si te interesa ser docente de la materia, pod√©s ver los requisitos y escribirnos en la secci√≥n [Ser Docente](contact.qmd#docentes).

¬°Muchos √©xitos! üëã
