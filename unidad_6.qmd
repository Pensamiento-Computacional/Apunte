---
title: Librerías de Python
format:
  html:
    code-fold: false
jupyter: python3
---

## Introducción

Python es un lenguaje de programación muy popular, poderoso y versátil que cuenta con una amplia gama de librerías que ayudan a que la programación sea más fácil y eficiente. Pero,  **¿qué son las librerías?** La librerías son conjuntos de módulos que contienen funciones, clases y variables relacionadas, que permiten realizar tareas sin tener que escribir el código desde cero y este se puede reutilizar en múltiples programas y proyectos. 

Entre las librerías disponibles se encuentran las estándares, que se incluye con cada instalación de Python, y las de código abierto creadas por la gran comunidad de desarrolladores, que constantemente genera nuevas librerías y mejora las existentes. Por ello es aconsejable que, al momento de utilizarlas, se verifique si existe alguna actualización en las guías de usuario.

Asimismo, estas librerías se pueden clasificar según su aplicación y funcionalidad en: procesamiento de datos, visualización, aprendizaje automático, desarrollo web, procesamiento de lenguaje y de imágenes, entre otras. En este capítulo se analizarán tres de las librerías más reconocidas y ampliamente utilizadas de Python: **NumPy** y **Pandas** para procesamiento de datos y **Matplotlib**, para visualización.

### ¿Cómo se utilizan las librerías?

Para acceder a una librería y sus funciones, se debe instalar por única vez y luego, importar cada vez que la necesitemos.

En la parte superior de nuestro código debemos correr `import {nombre_de_librería} as {nombre_corto_de_librería}`. El alias o nombre corto de la librería se suele agregar para lograr una mayor legilibilidad del código, pero no es mandatorio.

```python
import numpy as np
```

:::{.callout-note collapse="true}
En nuestro caso, la instalación no es necesaria ya que utilizamos Google Colab**, pero en caso de usar otro IDE (como por ejemplo, Visual Studio Code), se realiza desde el símbolo del sistema (o en inglés: “Command Prompt”, o terminal o consola), corriendo: `pip install –nombre_de_librería`. 
::: 

## NumPy

NumPy es una librería de código abierto muy utilizada en el campo de la ciencia y la ingeniería. Permite trabajar con datos numéricos, matrices multidimensionales, funciones matemáticas y estadísticas avanzadas. 

Como ya se mencionó anteriormente, para utilizarse se debe instalar e importar. Por convención, se suele importar como: 

```{python}
import numpy as np
```

NumPy incorpora una estructura de datos propia llamados **arrays** que es similar a la lista de Python, pero puede almacenar y operar con datos de manera mucho más eficiente: **el procesamiento de los arrays es hasta 50 veces más rápido**. Esta diferencia de velocidad se debe, en parte, a que **los arrays contienen datos homogéneos**, a diferencia de las listas que pueden contener distintos tipos de datos dentro.

### **Arrays**

Un **array** es un conjunto de elementos del mismo tipo, donde cada uno de ellos posee una posición y esta es única para cada elemento. Como dijimos arriba, en Python vimos las listas, que es lo más parecido a un Array.

Analicemos el siguiente ejemplo: si pensamos en una matriz, lo primero que nos viene a la mente es una tabla con valores ordenados en filas y columnas, donde una fila es la línea horizontal y una columna es la vertical. Es decir, una matriz es un conjunto de elementos que posee una posición o índice determinado determinado por la fila y la columna, por lo que sería un array.

En este capítulo se trabajará principalmente con vectores y matrices ya que consideramos que les será útil para aplicar los conocimientos de Numpy en otras materias.

#### Creación de un Array

Un array se crea usando la función `array()` a partir de listas o tuplas. Por ejemplo:

```{python}
a = np.array([1, 2, 3])
print(a)
```

También, se pueden crear arrays particulares, constituídos por ceros con `zeros()` o por unos con `ones()`:

```{python}
# Creo un array de ceros con dos elementos
a_ceros = np.zeros(2)
print(a_ceros)
```

```{python}
# Creo un array de unos con dos elementos
a_unos = np.ones(2)
print(a_unos)
```

Además, se pueden crear arrays con un rango de números, utilizando `arange()` o `linspace()`:

```{python}
# Creo un array con un rango que empieza en 2 hasta 9 y va de 2 en 2.
a_rango = np.arange(2, 9, 2)
print(a_rango)
```

```{python}
# Creo un array con un rango formado por 4 números
# que empieza en 2 hasta 10 (incluídos). 
a_rango_2 = np.linspace(2, 10, num=4)
print(a_rango_2)
```
Esto es muy parecido a los rangos que ya vimos en Python, con la sutil diferencia de que el `final` del rango en este caso **sí se icnluye**.

Finalmente, para crear arrays de más dimensiones, se utilizan varias listas:

```{python}
matriz = np.array([[1, 2, 3], [4, 5, 6]])

print(matriz)
```

#### Atributos de un array

#### Dimensión
Para caracterizar un array es necesario conocer sus dimensiones, utilizando `ndim`. De esta forma, se puede confirmar que el array llamado **matriz**, definido anteriormente, es bidimensional: 

```{python}
# Número de ejes o dimensiones de la matriz
matriz.ndim
```

#### Forma
Otra característica de interés es su forma o `shape`: para las matrices bidimensionales, se muestra una tupla (n, m) con el número de filas n y de columnas m:

```{python}
# (n = filas, m = columnas)
matriz.shape
```

#### Tamaño
El tamaño de un array es el número total de elementos que contiene, y se obtiene con `size`:
```{python}
# Número total de elementos de la matriz: 2 filas x 3 columnas = 6 elementos
matriz.size
```

#### Posiciones
Al elemento de una matriz A que se encuentra en la **fila i-ésima y la columna j-ésima** se llama $a_{ij}$. Así, para acceder a un elemento de un array se debe indicar primero la posición de la fila y luego, de la columna:

```{python}
print('Elemento de la primera fila y segunda columna: ', matriz[0, 1])
```

Nótese la diferencia con las matrices (listas de listas) de Python, donde se accedía a un elemento por separado, primero a la fila y luego a la columna: `matriz[0][1]`.

También se puede elegir un rango de elementos en una fila o columna particular:

```{python}
print('Los elementos de la primera fila, columnas 0 y 1: ', matriz[0, 0:2])
```

```{python}
print('Los elementos de la segunda columna, filas 0 y 1: ', matriz[0:2, 1])
```

#### Modificar arrays 

De forma similar a lo aprendido con las listas de Python, se pueden modificar los arrays utilizando ciertas funciones. Para entender y aplicar las mismas, definamos un vector llamado a:

```{python}
a = np.array([2, 1, 5, 3, 7, 4, 6, 8])

print(a)
```

##### Reshape
A este vector, se le puede modificar la forma: pasando de ser `(8,)` a `(4,2)`, por dar un ejemplo:

```{python}
a_reshape = a.reshape(2, 4) # 2 filas y 4 columnas

print(a_reshape)
```

##### Insert

También, se modría insertar una fila (`axis = 0`) o una columna (`axis = 1`) en una determinada posición. Por ejemplo:

```{python}
# Agregar fila de cincos en posición 1:
print(np.insert(a_reshape, 1, 5, axis=0))
```

A la función `insert()`, se le debe indicar: \

- El array que se desea modificar \
- La posición de la fila o columna que se desea agregar \
- Los valores a insertar. **¡Ojo con las dimensiones!** Para el ejemplo anterior, a_reshape tenía 2 filas, por lo que se debe agregar una columna con 2 elementos o una fila con 4. \
- El eje que se agrega: una fila (axis = 0) o una columna (axis = 1) \

```{python}
# Agregar columna de cincos en posición 1:
print(np.insert(a_reshape, 1, 5, axis=1))
```

O lo que es equivalente:

```{python}
# Agregar columna de cincos en posición 1:
print(np.insert(a_reshape, 1, [5, 5], axis=1))
```

##### Append y Delete

También podríamos agregar una fila o una columna utilizando `append()` al final, como ocurría con las listas:

```{python}
# Agregar una última fila
a_modificada = np.append(a_reshape, [[1, 2, 3, 4]], axis=0)
print(a_modificada)
```

O eliminarlas con `delete()`

```{python}
# Eliminar la fila de la posición 2.
print(np.delete(a_modificada, 2, axis=0))
```

##### Concatenate y Sort

Finalmente, podemos concatenar arrays, como los siguientes:

```{python}
a = np.array([2, 1, 5, 3])
b = np.array([7, 4, 6, 8])

# Concatenar a y b:
c = np.concatenate((a, b))
print(c)
```

Y ordenar los elementos de un array como numérico o alfabético, ascendente o descendente.

```{python}
print(np.sort(c))
```

### Operaciones aritméticas utilizando **array**

Como se ha mencionado anteriormente, Numpy tiene un gran potencial para realizar operaciones, muy superior al de las listas de Python. Por ejemplo, si quisieramos sumar dos listas de python necesitaríamos realizar un `for`:

```{python}
# Definir listas
a = [2, 1, 5, 3]
b = [7, 4, 6, 8]
c = []

# Sumar el primer elemento de a con el primero de b, el segundo elemento de a con el segundo de b y así sucesivamente
for i in range(len(a)):
  c.append(a[i] + b[i])
print(c)
```

Utlizando las funciones de Numpy, esto ya no es más necesario:

```{python}
# add() para sumar elemento a elemento de a y b
c = np.add(a, b)
print(c)
```

También podemos realizar otras operaciones, como la resta, multiplicación y división. Usar un arreglo dentro de una ecuación nos devuelve otro arreglo, donde cada elemento es el resultado de aplicar la operación a los elementos correspondientes de los arreglos originales.

```{python}
x = np.array([0,  1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
y = 3 * x + 2
print(y)
```

De esta forma, podemos realizar operaciones aritméticas con arrays de Numpy de forma muy sencilla y rápida. Antes, en Python, para realizar estas operaciones debíamos recurrir a un ciclo `for` o a el uso de `map`. Numpy se ocupa de ahorrarnos el trabajo y calcular, para cada elemento del array, el resultado.

Además, tenemos operaciones básicas que vienen predefinidas por Numpy. Las vamos a ver a continuación.

#### Operaciones básicas:

A continuación se muestra una lista con las operaciones básicas junto con sus operadores asociados, funciones y ejemplos.

| Operación | Operador | Función |
| --- | --- | --- |
| Suma | `+` | `add()` |
| Resta | `-` | `subtract()` |
| Multiplicación | `*` | `multiply()` |
| División | `/` | `divide()` |
| Potencia | `**` | `power()` |

Definimos los vectores a y b con los que operaremos y veremos ejemplos:

```{python}
a = np.array([1, 3, 5, 7])
b = np.array([1, 1, 2, 2])
```

- Suma:

```{python}
resultado_1 = a + b
print("Suma usando +:", resultado_1) 

resultado_2 = np.add(a, b)
print("Suma usando add():", resultado_2) 
```

- Resta:

```{python}
resultado_1 = a - b
print("Resta usando -:", resultado_1) 

resultado_2 = np.subtract(a, b)
print("Resta usando subtract():", resultado_2) 
```

- Multiplicación:

```{python}
resultado_1 = a * b
print("Multiplicación usando *:", resultado_1) 

resultado_2 = np.multiply(a, b)
print("Multiplicación usando multiply():", resultado_2) 
```

- División:

```{python}
resultado_1 = a / b
print("División usando /:", resultado_1) 

resultado_2 = np.divide(a, b)
print("División usando divide():", resultado_2) 
```

- Potencia:

```{python}
resultado_1 = a ** b
print("Potencia usando **:", resultado_1) 

resultado_2 = np.power(a, b)
print("Potencia usando power():", resultado_2) 
```

::: {.callout-note}
Note que si quisieramos operar con un vector `b` de elementos iguales, podríamos utilizar un escalar.
:::

```{python}
b = np.array([2, 2, 2, 2])

resultado_1 = a * b
print("Usando un vector b = [2, 2, 2, 2]:", resultado_1) 

resultado_2 = a * 2
print("Usando un escalar b = 2:", resultado_2) 
```

#### Logaritmo:

NumPy provee funciones para los logaritmos de base 2, 10 y e:

| Base | Función |
| --- | --- |
| 2 | `log2()` |
| 10 | `log10()` |
| e | `log()` |

Por ejemplo:

```{python}
# Ejemplo log2()
print("Logaritmo base 2:", np.log2([2, 4, 8, 16]))
# Ejemplo log10()
print("Logaritmo base 10:", np.log10([10, 100, 1000, 10000]))
# Ejemplo log()
print("Logaritmo base e:", np.log([1, np.e, np.e**2]))
```

::: {.callout-note}
Note que el número de Euler o número e es una constante incluída en NumPy como: `np.e`
:::

```{python}
np.e
```

#### Funciones trigonométricas:

A continuación, una lista con las funciones trigonométricas más utilizadas, que toman los valores en radianes:

| Función trigonométrica | Función |
| --- | --- |
| seno | `sin()` |
| coseno | `cos()` |
| tangente | `tan()` |
| arcoseno | `arcsin()` |
| arcocoseno | `arccos()` |
| arcotangente | `arctan()` |

Por ejemplo:

```{python}
# Ejemplo de seno
print("Seno de π / 2:", np.sin(np.pi / 2))

# Ejemplo de arcoseno
print(np.arcsin(1))
```

```{python}
# Ejemplo de coseno
print("Coseno de π:", np.cos(np.pi))

# Ejemplo de arcocoseno
print("Arcoseno de -1:", np.arccos(-1))
```

```{python}
# Ejemplo de tangente:
print("Tangente de 0:", np.tan(0))

# Ejemplo de arcotangente:
print("Arcotangente de 0:", np.arctan(0))
```

::: {.callout-note}
Note que el número π es una constante incluída en NumPy como: `np.pi`
:::

```{python}
np.pi
```

Para convertir los radianes a grados y viceversa, se utiliza `deg2rad()` y `rad2deg()` respectivamente:

```{python}
print("De grados [90, 180, 270, 360] a radianes:", 
      np.deg2rad([90, 180, 270, 360]))

print("De radianes [π/2, π, 1.5*π, 2*π] a grados:", 
      np.rad2deg([np.pi/2, np.pi, 1.5*np.pi, 2*np.pi]))
```

#### Operaciones con matrices:

A continuación, una lista con las operaciones que les pueden ser de interés mientras estudian álgebra matricial:

| Función | Descripción | Comentario |
| --- | --- | --- |
| `dot()` | Producto escalar | Se utiliza para obtener el producto escalar entre dos vectores. El resultado es un número. |
| `dot()` | Producto vectorial | También se utiliza para multiplicar matrices. El resultado es una matriz |
| `transpose()` | Traspuesta | Cambia las filas por las columnas y viceversa |
| `linalg.inv()` | Inversa | Inversa de una matriz |
| `linalg.det()` | Determinante | Determinante de una matriz |
| `eye()` | Matriz identidad | Matriz cuadrada con unos en la diagonal principal y ceros en el resto |

Definimos los arreglos 1 y 2, y matrices 1 y 2 con los que operaremos y veremos ejemplos:

```{python}
# Crear arreglos
arreglo_1 = np.array([1, 2])
arreglo_2 = np.array([3, 4])

# Crear matrices
matriz_1 = np.array([[1, 3], [5, 7]])
matriz_2 = np.array([[2, 6], [4, 8]])
```

```{python}
print("Producto escalar entre el array 1 y 2: \n", np.dot(arreglo_1, arreglo_2))
```

```{python}
print("Producto vectorial entre la matriz 1 y 2: \n", np.dot(matriz_1, matriz_2))
```

```{python}
print("Traspuesta de la matriz 1: \n", np.transpose(matriz_1))
```

```{python}
print("Inversa de la matriz 1: \n", np.linalg.inv(matriz_1))
```

```{python}
print("Determinante de la matriz 1: \n", np.linalg.det(matriz_1))
```

::: {.callout-note}
Note que así como existen constantes numéricas, existen las matrices particulares como las compuestas por ceros `np.zeros()`, por unos `np.ones()` y la matriz identidad `np.eyes`.
:::

```{python}
print("Matriz de identidad de 3x3: \n", np.eye(3))
```

#### Más operaciones útiles:

| Operaciones | Función | Descripción |
| --- | --- | --- |
| Máximo | `max()` | Valor máximo del array o del eje indicado |
| Mínimo | `min()` | Valor mínimo del array o del eje indicado |
| Suma | `sum()` | Suma de todos los elementos o del eje indicado |
| Promedio | `mean()` | Promedio de todos los elementos o del eje indicado |

Utilizando la matriz **data** como ejemplo:

```{python}
data = np.array([[1, 2], [5, 3], [4, 6]])
```

- Valor máximo

```{python}
print("Valor máximo de todo el array: ", data.max())
print("Valores máximos de cada columna: ", data.max(axis=0))
```

- Valor mínimo

```{python}
print("Valor mínimo de todo el array: ", data.min())
print("Valores mínimos de cada fila: ", data.min(axis=1))
```

- Suma de elementos:

```{python}
print("Suma de todos los elementos del array: ", data.sum())
print("Suma de los elementos de cada fila: ", data.sum(axis=1))
```

- Promedio:

```{python}
print("Promedio de todos los elementos del array: ", data.mean())
print("Promedio de los elementos de cada columna: ", data.mean(axis=0))
```

::: {.callout-note}
Numpy te va a ser muy útil cuando curses materias como Análisis Matemático, Álgebra, Física, Estadística, entre otras. Te va a permitir realizar operaciones de manera rápida y eficiente, y te va a ayudar a entender mejor los conceptos.
:::

## Pandas

Pandas es una librería de código abierto diseñada específicamente para la manipulación y el análisis de datos en Python. Es una herramienta poderosa que puede ayudar a los usuarios a limpiar, transformar y analizar datos de una manera rápida y eficiente.

Dado que se basa en NumPy, luego de instalarse, se deben importar ambas librerías. Por convención: 

```{python}
import pandas as pd
```

Los datos a trabajar en Pandas van a tener, en general, una forma muy similar a las tablas:

![Esquema de figuras y axes](./imgs/unidad_6/pandas.png)

Pandas incorpora dos estructuras de datos llamados: **Series** y  **DataFrames**. Los vamos a ver a continuación.

### **Serie**

Una **serie** es un vector **(unidimensional)** capaz de contener cualquier tipo de dato, como por ejemplo, números enteros o decimales, strings, objetos de Python, etc.

Para crearlas, se puede partir de un escalar, una lista, un diccionario, etc., utilizando `pd.Serie()`:

```{python}
# Crear serie partiendo de una lista:
lista = [1, "a", 3.5]

pd.Series(lista)
```

Note que se ven dos líneas verticales de datos. A la derecha se observa una columna con los elementos de la lista antes creada, mientas que a la izquierda se encuentra el **índice**, formado por valores desde 0 a n-1, siendo n la cantidad de elementos. Este índice numérico es el predefinido, por lo que si se deseara uno particular, se puede establecer utilizando `index`.

El índice es de vital importancia ya que permite acceder a los elementos de la serie. Es por ello que al colocar un índice en particular, su longitud debe ser acorde al número de elementos de la misma. De lo contrario, se mostrará un ValueError. 

```{python}
# Crear serie partiendo de una lista, indicando el índice
pd.Series(lista, index = ["x", "y", "z"])
```

En el caso de crear Series utilizando diccionarios, sus claves (o keys) pasan a formar el índice.

```{python}
# Crear serie partiendo de un diccionario:
diccionario = {"x": 1, "y": "a", "z": 3.5}

a = pd.Series(diccionario)
a
```

Como ya se debe estar imaginando, para acceder a un elemento de la serie, se debe indicar el valor del índice o la posición entre corchetes.

```{python}
# Acceder al elemento de índice x:
a["x"]
```

```{python}
# Acceder al elemento de posición 0:
a[0]
```

Otra característica interesante de las series (y de los DataFrames, como se verá a continuación) es la vectorización: así como los arrays, no requieren recorrer valor por valor en un for para realizar operaraciones. Por ejemplo:

```{python}
a + a
```

### **DataFrame**

Un **DataFrame** es una estructura de datos tabular **(bidimensional)**, compuesta por filas y columnas, que se asemeja a una hoja de cálculo de Excel. Para crearlos, se utiliza `DataFrame()` y se ingresan diferentes estructuras como arrays, diccionarios, listas, series u otros dataframes. 

En el siguiente ejemplo, se crea un Dataframe partiendo de un diccionario **data** para las columnas y de una lista **label** para el índice:

```{python}
data = {'columna_1': ['a', 'b', 'c', 'd', 'e', 'f'],
        'columna_2': [2.5, 3, 0.5, None, 5, None],
        'columna_3': [1, 3, 2, 3, 2, 3]}

labels = ['a1', 'a2', 'a3', 'a4', 'a5', 'a6']

pd.DataFrame(data, index=labels)
```

#### Atributos y descripción de un Dataframe

A continuación, se observa una tabla con métodos que nos permiten conocer las características de un determinado DataFrame.

| Método | Descripción |
| --- | --- |
| `info()` | Resume la información del DataFrame |
| `shape` | Devuelve una tupla con el número de filas y columnas |
| `size` | Número de elementos |
| `columns` | Lista con los nombres de las columnas |
| `index` | Lista con los nombres de las filas |
| `dtypes` | Serie con los tipos de datos de las columnas |
| `head()` | Muestra las primeras filas |
| `tail()` | Muestra las últimas filas |
| `df.describe()` | Brinda métricas de las columnas numéricas |

Para ejemplificar los métodos y las funciones de Pandas, usaremos el **DataFrame df** definido en la siguiente línea de código.

```{python}
data = {'nombre': ['José Martínez', 'Rosa Díaz', 'Javier Garcíaz', 'Carmen López', 'Marisa Collado', 'Antonio Ruiz', 'Antonio Fernández', 
                   'Pilar González', 'Pedro Tenorio', 'Santiago Manzano', 'Macarena Álvarez', 'José Sanz', 'Miguel Gutiérrez', 'Carolina Moreno'],
        'edad': [18, 32, 24, 35, 46, 68, 51, 22, 35, 46, 53, 58, 27, 20],
        'sexo': ['H', 'M', 'H', 'M', 'M', 'H', 'H', 'M', 'H', 'H', 'M', 'H', 'H', 'M'],
        'peso': [85.0, 65.0, None, 65.0, 51.0, 66.0, 62.0, 60.0, 90.0, 75.0, 55.0, 78.0, 109.0, 61.0],
        'altura': [1.79, 1.73, 1.81, 1.7, 1.58, 1.74, 1.72, 1.66, 1.94, 1.85, 1.62, 1.87, 1.98, 1.77],
        'colesterol': [182.0, 232.0, 191.0, 200.0, 148.0, 249.0, 276.0, None, 241.0, 280.0, 262.0, 198.0, 210.0, 194.0]}

df = pd.DataFrame(data)
df
```
##### Info

Con `info()` se puede ver:
- el índice en la primera línea, que es un rango de 0 a 13
- el número total de columnas en la segunda línea
- el uso de la memoria en la última
- una tabla con los nombres de las columnas en **Column**, la cantidad de valores no nulos en **Non-Null Count** y el tipo de dato en **Dtype** para cada una de ellas.

```{python}
df.info()
```

Note que utilizando `dtypes`, `columns` e `index` se obtiene parte de esta información:

```{python}
# Tipo de dato por columna
df.dtypes
```

```{python}
# Nombre de cada columna
df.columns
```

```{python}
# índice
df.index
```

##### Shape

La forma del DataFrame es de 14 filas y 6 columnas, por lo que contiene 84 elementos.

```{python}
# Forma del DataFrame (filas, columnas)
df.shape
```

```{python}
# Número de elementos del DataFrame
df.size
```

##### Head

Asimismo, cuando no conocemos un DataFrame, puede ser importante ver las primeras 5 filas con `head()` o las últimas con `tail()`. Si se quisiera observar un número determinado, sólo hay que especificarlo, por ejemplo:

```{python}
# Mostrar las primeras 3 filas.
df.head(3)
```

```{python}
# Mostrar las últimas 5 filas.
df.tail()
```

##### Describe

Por otro lado, `describe()` devuelve un resumen descriptivo de las columnas de valores numéricos, como "edad", "peso", "altura" y "colesterol".

```{python}
df.describe()
```

Estas métricas podrían obtenerse utilizando funciones determinadas, como:\

- `count()`: contabiliza los valores no nulos
- `mean()`: promedio
- `min()`: valor mínimo
- `max()`: valor máximo

Por ejemplo:

```{python}
df.count()
```

Finalmente, como ocurre con las series, **para acceder a los elementos de un DataFrame se puede indicar la posición o el nombre de la fila o columna**.

Para acceder a una **fila** en particular, utilizamos `iloc[]` con un entero, una lista de enteros o un rango de números que indican las posiciones o con `loc[]` indicando el valor del índice. 

```{python}
# Mostrar los datos de la fila de posición 0:
df.iloc[0]
```

<br>
<br>

```{python}
# Mostrar la fila de posición 0:
df.iloc[[0]]
```

<br>
<br>

```{python}
# Mostrar las filas de posición 0 y 3:
df.iloc[[0, 3]]
```

<br>
<br>

```{python}
# Mostrar las filas de posiciones entre 0 hasta 3 (exclusive):
df.iloc[:3]
```

<br>
<br>

```{python}
# Equivalente a df.iloc[:3]:
df.head(3)
```

<br>
<br>

```{python}
# Mostar la fila cuyo valor del índice es 0:
df.loc[0]
```

##### Accediendo a columnas

Por otro lado, para acceder a una **columna** se pueden utilizar los nombres de la mismas con `DataFrame[columna]` o su equivalente `DataFrame.columna`.

```{python}
# Mostrar la columna "nombre"
df[['nombre']] # o df.nombre
```

<br>
<br>

```{python}
# Mostrar más de una columna: "nombre" y "edad":
df[['nombre', 'edad']]
```

Finalmente, se puede utilizar `loc[filas, columnas]` que devuelve un DataFrame con los elemento que se encuentra en las filas con los nombres de la lista filas y las columnas con los nombres de la lista columna.

```{python}
# Mostrar la filas de índice 0, 1, 2, 3, columnas "nombre" y "edad"
df.loc[:3, ['nombre', 'edad']]
```

<br>
<br>

```{python}
# O su equivalente:
df.loc[df.index[[0, 1, 2, 3]], ['nombre', 'edad']]
```

#### Modificar un Dataframe

A la hora de modificar un DataFrame puede ser que querramos:\

- cambiar la estructura del mismo, como los nombres de las columnas y de los índices,
- agregar una nueva filas o columna
- reemplazar un dato en una determinada posición.

A continuación, se enumeran distintos métodos para llevar a cabo estos cambios.

| Método | Descripción |
| --- | --- |
| `set_index()` | Convierte una determinada columna en el nuevo índice. |
| `reset_index()` | Reestablece el índice predefinido |
| `rename()` | Renombra las columnas |
| `insert()` | Agrega columnas |
| `loc[fila]` | Agrega una fila en un índice dado |
| `drop()` | Elimina columnas y filas |
| `loc[fila, columna]` | Modifica un valor particular dado un índice y una columna |
| `map()` | Busca un valor dado en una columna y lo reemplaza |
| `replace()` | Reemplaza un valor dado en una columna |

##### Set_index y reset_index

Utilizando `set_index()` podemos, Por ejemplo, transformar a la columna "nombre" en el nuevo índice, y para volver al predefinido, usando `reset_index()`.

```{python}
df = df.set_index(keys = "nombre")
df.head()
```

<br>
<br>

```{python}
df = df.reset_index()
df.head()
```

<br>
<br>

##### Rename, insert y drop

Para renombrar una columna, se utiliza `rename(columns={"nombre_columna": "nuevo_nombre_columna"})` 

```{python}
# Reemplazo "nombre" por "nombre y apellido"
df = df.rename(columns={"nombre": "nombre y apellido"})
df.head()
```

Para agregar una nueva columna, existe el método `insert()`, que requiere indicar La posición de la nueva columna, el nombre de la nueva columna, y los valores de la misma. Para ello, creamos una lista llamada **direccion** con 14 valores, para cada una de las personas del DataFrame.

```{python}
# Valores de la nueva columna
direccion = ["CABA", "Bs As", "Bs As", "Bs As", "CABA", "Bs As", "CABA", "CABA", "CABA", "CABA", "CABA", "Bs As", "CABA", "CABA"]

# Insertar la columna "direccion" en la posición 3:
df.insert(3, "direccion", direccion)
df.head()
```

<br>
Para agregar una nueva fila, se utiliza el ya conocido `loc[]`, que requiere indicar el índice y los valores de la misma. Para ello, creamos una lista llamada **nueva_fila** con valores para cada columna del DataFrame.

```{python}
# Valores de la nueva fila
nueva_fila = ['Carlos Rivas', 28, 'H', "Bs As", 89.0, 1.78, 245.0]

# Insertar la fila 14
df.loc[14] = nueva_fila
df.tail()
```

<br>
<br>

Para eliminar una columna `(axis=1)` o fila `(axis=0)`, se utiliza `drop()`:

```{python}
# Elimino la columna "direccion", equivalente a del df["direccion"]
df = df.drop('direccion', axis=1)  
df.head()
```

<br>
<br>

```{python}
# Elimino la fila 14
df = df.drop(14, axis=0) 
df.tail()
```

::: {.callout-tip}
##### **Agregar columnas con operaciones** 

Como se ha mencionado anteriormente, gracias a la **vectorización** se pueden agregar columnas partiendo de operaciones entre columnas existentes en el DataFrame.

:::

Por ejemplo, suponga que queremos ingresar una columna el índice de masa corporal de las personas que se calcula de la siguiente manera: 

$$
IMC = \frac{Peso(kg)}{Altura(m)^2}$$

```{python}
# Crear la columna "IMC"
df["IMC"] = df["peso"] / df["altura"]**2
df.head()
```

De manera análoga, se puede crear la columna **dirección** sin utilizar `insert()`. Usando la lista **direccion**:

```{python}
df["direccion"] = direccion
df.head()
```

Finalmente, **para cambiar un valor determinado** se utiliza `loc[]`, como por ejemplo, agregar el peso de Javier García (tercera fila):

```{python}
df.loc[2, 'peso'] = 92
df.head()
```

<br>
<br>

Para transformar los valores de una columna entera, podemos utilizar `map()` pasando un diccionario del estilo `{valor_viejo: valor_nuevo}`. Por ejemplo, modificar la columna "sexo" reemplazando "H" por "M" y "M" por "F":

```{python}
df['sexo'] = df['sexo'].map({'H': 'M', 'M': 'F'})
df.head()
```

<br>
<br>

Otra manera sería utilizando `replace()`, como en la columna "direccion" donde se modificó "Bs As" por "Buenos Aires".

```{python}
df['direccion'] = df['direccion'].replace('Bs As', 'Buenos Aires')
df.head()
```

#### Filtrar un Dataframe

Para filtrar los elementos de un DataFrame se suelen utilizar condiciones lógicas. Por ejemplo:

```{python}
# Seleccionar aquellas personas menores de 40 años:
df[df['edad'] < 40]
```

<br>
<br>
Cuando se requieren múltiples condiciones, se puede adicionar usando símbolos como `&` para **intersecciones** y `|` para **uniones**. Por ejemplo:

```{python}
# Seleccionar aquellas personas de sexo femenino y menores de 40 años:
df[(df['edad'] < 40) & (df['sexo'] == 'F')]
```

<br>
<br>

```{python}
# Seleccionar aquellas personas cuyo peso es 60kg o 90kg:
df[(df['peso'] == 60.0) | (df['peso'] == 90.0)]
```

<br>
<br>

Cuando se desea filtrar con un cierto rango en una determinada columna, se pueden utilizar las condiciones antes mencionadas o la función `between()`.

```{python}
# Equivalente a df[(df['edad'] > 25) & (df['edad'] < 40)]
df[df['edad'].between(25, 40)]
```

<br>
<br>

Finalmente, puede ser interesante encontrar aquellas las filas con datos faltantes o `NaN`. Para ello, se utiliza la función `isnull()` que devuelve `True` si el valor de la columna es nulo o NaN. Por ejemplo:

```{python}
df['IMC'].isnull()
```

Para visualizar aquella fila donde el índice de masa corporal es nulo, filtramos:

```{python}
df[df['IMC'].isnull() == True]
```

#### Otros métodos útiles

A continuación, se muestra una lista con métodos que resultan muy útiles a la hora de analizar datos: 

| Método | Descripción |
| --- | --- |
| `sort_values(by, ascending)` | Ordena el DataFrame considerando los valores de la o las columnas determinadas |
| `value_counts()` | Indica los valores únicos de una determinada columna y el número de veces que aparece en ella |
| `groupby().agg()` | Agrupa las filas según ciertos valores de columnas y aplica funciones |

- Sort value:
  
Para utilizar la función `sort_values(by, ascending)`, se debe indicar en el parámetro `by` una lista con las columnas para ordenar el DataFrame y en `ascending`, `True` si el orden deseado es creciente o `False` para decreciente.

En el siguiente ejemplo ordenamos por "nombre y apellido" en forma alfabética: 

```{python}
df.sort_values(by=['nombre y apellido'], ascending=[True])
```

Ahora, **¿Qué ocurre cuando ordenamos siguiendo varias columnas?** Los valores del DataFrame se ordenan siguiendo la primera columna en primer lugar, luego la segunda, y así sucesivamente.

```{python}
df.sort_values(by=['direccion', 'nombre y apellido'], ascending=[True, True])
```

Analicemos el ejemplo anterior, donde queremos ordenar según "direccion" y "nombre y apellido". Allí, primero se ordena de manera creciente por dirección, resultando en dos grupos: el superior con "direccion" = "Buenos Aires" y el inferior con "CABA". Luego, cada uno de esos grupos se ordena por "nombre y apellido" de forma creciente.

![Ejemplo de sort_values()](./imgs/unidad_6/sortvalues.png)

- Value Count:

Utilizando `value_counts()` se pueden contar las filas en cada grupo según "direccion". Es decir, cuantas filas hay para "Buenos Aires" y para "CABA".

```{python}
df['direccion'].value_counts()
```

- Group by:
  
`groupby()` es un método que nos permite agrupar los datos del DataFrame según los valores de una o unas columnas dadas, tranformándose estas en el nuevo índice de los grupos. Por ejemplo, si quisieramos agrupar por:

1. "direccion": corremos `df.groupby(['direccion'])` obteniendo una tabla con valores agrupados por "direccion", siendo esta columna el nuevo índice.

2.  "direccion" y "sexo": corremos `df.groupby(['direccion', 'sexo'])` obteniendo una tabla con valores agrupados por "direccion" y "sexo", siendo ambas columnas el nuevo índice.

![Ejemplo de groupby()](./imgs/unidad_6/groupby.png)

Una vez obtenidos los grupos que deseamos analizar, podemos realizar una función de agregación `agg()` utilizando algunas o todas las columnas restantes. Estas funciones pueder ser suma, media, mínimo, máximo, contar valores no nulos, entre otras. Veamos algunos ejemplos:

```{python}
# Agrupar por "direccion" y contar los valores no nulos de todas las columnas
df.groupby(['direccion']).agg('count')
```

```{python}
# Agrupar por "direccion" y "sexo" y contar los valores no nulos de alguna columnas
df.groupby(['direccion', 'sexo'])[['edad', 'peso']].agg('count')
```

También se puede asignar para cada columna, una operación distinta:

```{python}
# Agrupar por "direccion" y "sexo" y calcular el valor máximo de la columna "colesterol" y el promedio de "peso"
df.groupby(['direccion', 'sexo']).agg({'colesterol': ['max'], 'peso': ['mean']})
```

```{python}
# Agrupar por "direccion" y "sexo" y calcular los valores máximos y mínimos de la columna "colesterol" y el promedio de "peso"
df.groupby(['direccion', 'sexo']).agg({'colesterol': ['min', 'max'], 'peso': ['mean']})
```

## Matplotlib

Matplotlib es probablemente la librería de Python más usada para crear gráficos, también llamados **plots**. Esta provee una forma rápida de graficar datos en varios formatos de alta calidad que pueden ser compartidos y/o publicados, resultando una alternativa open source de MATLAB. De hecho, matplotlib.pyplot es una colección de funciones que hacen que matplotlib funcione como MATLAB, con comandos análogos y argumentos similares.

Como ya se imagina, el primer paso es importar la librería. Por convención:

```{python}
import matplotlib.pyplot as plt
```

### Creación de gráficos con matplotlib

Para crear un gráfico con matplotlib, se deben seguir los siguientes pasos:

1. **Crear la figura** que contendrá el gráfico, utilizando las funciones `subplots()` o `figure()`. Se recomienda la primera, como se verá más adelante.

2. **Graficar los datos**, utilizando distintas funciones dependiendo del tipo de gráfico que se desea realizar:


| Función | Tipo de Gráfico |
| --- | --- |
| `plot()` | Gráfico de línea |
| `scatter()` | Gráfico de puntos |
| `bar()` | Gráfico de barras verticales |
| `barh()` | Gráfico de barras horizontales |
| `pie()` | Gráfico de torta |


3. **Personalizar el gráfico**. Este paso no es mandatorio, pero sí, muy recomendado para lograr un mejor entendimiento de la visualización

4. **Mostrar el gráfico**, utilizando la función `show()`

Esto quiere decir que, si deseamos visualizar datos rápidamente, podríamos realizarlo corriendo únicamente las siguientes tres líneas de código:

**Opción 1**
```
fig = plt.figure()  
plt.funcion_grafico_elegido()       # Reemplazar funcion_grafico_elegido() por una función
plt.show()  
```

**Opción 2**
```
fig, ax = plt.subplots()  
ax.funcion_grafico_elegido()        # Reemplazar funcion_grafico_elegido() por una función     
plt.show()  
```

Pero, **¿cuál debería usar?** Eso depende de lo que quieras hacer. A continuación, se verá el detalle de lo que está ocurriendo en cada línea, para que así puedas elegir qué es lo mejor para vos.

```{python}
plt.figure()
```

```{python}
plt.subplots()
```

Si bien no se puede ver un gráfico en ninguno de los outputs, analicemos lo que nos imprime:

1. `fig = plt.figure()` crea una **figura pero sin axes**, por lo que muestra `<Figure size 640x480 with 0 Axes>`.
2. `fig, ax = plt.subplots()` permite **crear ambos: figura y axes**, por lo que muestra `<Figure size 640x480 with 1 Axes>, <AxesSubplot: >)`.

Note además, que se ha seguido una convención al nombrarse la **figura** como `fig` y los **axes** como `ax`. Pero... **¿qué es una figura y un axes?**

Una **figura** es el marco que delimita la zona donde se trazan los gráficos, mientras que los **axes**, son lo que llamamos comunmente gráficos, es decir, son las áreas donde los puntos se pueden especificar en términos de coordenadas. **Por lo tanto, una figura puede contener muchos axes, pero un axes determinado sólo puede estar contenido en una única figura.**


![Esquema de figuras y axes](./imgs/unidad_6/fig_ax.png)

::: {.callout-note}
#### **¡Ojo! No confundir axes con axis** \
Los **Axis** son los ejes cartesianos que se encargan de establecer los límites, la escala y las dimensiones del gráfico: un axes puede tener 2 Axis, si es un gráfico plano, o 3, si es un gráfico en 3D.
:::

Entonces, con lo aprendido hasta el momento, volvamos a revisar las líneas de código anteriores:

**Opción 1**
```
fig = plt.figure()                  # Se crea una figura vacía sin Axes
plt.funcion_grafico_elegido()       # Se grafica según la función elegida
plt.show()                          # Mostrar 
```
Esta opción es más amigable para principiantes ya que es más conciso y resulta muy útil cuando simplemente se desea crear un gráfico para verificar resultados rápidamente.

**Opción 2**
```
fig, ax = plt.subplots()            # Se crea una figura con un único Axes
ax.funcion_grafico_elegido()        # Se grafica según la función elegida
plt.show()                          # Mostrar
```
Esta opción es ideal cuando necesitamos un enfoque más flexible, con gráficos más complejos o con un ajuste fino como los que veremos en este apunte.

### Partes de una Figura y personalización

Esta imagen, fue obtenida de la referencia de matplotlib y resume de manera fácil y visual las modificaciones que podemos hacerla a las figuras creadas.

![Partes de una Figura](./imgs/unidad_6/matplotlib.png)

Si desea conocer más detalle, puede ingresar a [https://matplotlib.org/stable/tutorials/introductory/quick_start.html](https://matplotlib.org/stable/tutorials/introductory/quick_start.html).

Con lo aprendido hasta el momento, vamos a realizar nuestro primer gráfico para luego mostrar cómo modificar su aspecto. La función que usaremos es `plot()`, con la que se obteniene un gráfico de línea; esta recibe los vectores X e Y para formar puntos en el plano cartesiano que son unidos con una línea. 

```{python}
# Grafico elemental
x = [0,2,10,11,18,25]
y = [0,1,2,3,4,5]

fig, ax = plt.subplots()

# Gráfico de línea
ax.plot(x, y)
plt.show()
```

#### Cambiar el aspecto de los gráficos:
Para diferenciar las curvas o simplemente para modificar los gráficos según nuestros gustos personales, se pueden definir los distintos parámetros dentro de `plot()`, estableciendo el tipo de línea y puntos, el grosor, el color, etc:

*  **color =** nombre del color, por ejemplo: `'blue', 'green', 'red'`, etc.
*   **marker =** forma de los puntos o marcadores, por ejemplo: `'^', 'o', 'v'`, etc.
*   **linestyle =** estilo de línea, por ejemplo: `'solid', 'dashed', 'dotted'` o sus equivalentes:` '-', '--', ':',` entre otros.
*   **markersize, linewidth =** con un número, establecemos el tamaño del marcador y el espesor de la línea respectivamente.

Note que si no le asignamos un valor, se establecen los predefinidos.

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)
plt.show()
```

Para ver las múltiples opciones disponibles, les dejamos el siguiente link de consulta: 
[https://matplotlib.org/2.1.1/api/_as_gen/matplotlib.pyplot.plot.html](https://matplotlib.org/2.1.1/api/_as_gen/matplotlib.pyplot.plot.html)

#### Grilla o cuadrícula:
Para leer facilmente el valor de cada punto, podemos agregar una cuadrícula usando `grid()`.

Si deseamos modificarle, por ejemplo, el color, el estilo de línea, o sólo queremos ver uno de los ejes, podemos indicarlo utilizando parámetros muy similares a los vistos anteriormente pero en la funcion `grid()`.

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)

# Grilla preestablecida
ax.grid()
plt.show()
```

```{python}
#Gráfica con la grilla preestablecida
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)

#Grilla modificada
ax.grid(axis = 'y', color = 'gray', linestyle = 'dashed')
plt.show()
```

#### Títulos
Una de las partes más importantes para que un gráfico se pueda entender es ponerle un título y explicar qué significa cada eje. Eso se hace con las funciones `set_xlabel()`, `set_ylabel()` y `set_title()`. Cada una recibe un string que se usará como etiqueta del eje X, etiqueta del eje Y o título, respectivamente.

Siendo que los valores de **x** son el tiempo medido en minutos y los de **y** una distancia en metros, entonces:

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)

# Mostrar el título del gráfico
ax.set_title("Gráfico de posición")

# Mostrar el título de los ejes
ax.set_xlabel('Tiempo (min)')
ax.set_ylabel('Distancia (m)')

# Grilla preestablecida
ax.grid()
plt.show()
```

#### Referencias
El gráfico con el que estamos trabajando sólo tiene una línea, pero si contara con más de una, el uso de referencias sería escencial para lograr el entendimiento del mismo. Para rotular las líneas, dentro de `plot()` se debe definir la referencia como `label`. Luego se coloca `legend()`

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, label='Objeto 1', color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)

# Mostrar el título del gráfico
ax.set_title("Gráfico de posición")

# Mostrar el título de los ejes
ax.set_xlabel('Tiempo (min)')
ax.set_ylabel('Distancia (m)')

# Agregar la refencia
ax.legend()

# Grilla preestablecida
ax.grid()
plt.show()
```

#### Características de los ejes:
Como podemos identificar en los gráficos anteriores, Python decidió las características de los ejes:

-   **Eje x**: se extiende del 0 a 25, de 5 en 5.
-   **Eje y**: se extiende del 0 a 5, de 1 en 1.

Podemos establecer los limites del eje x e y usando `set_xlim()` y `set_ylim()` respectivamente.

```{python}
x = [0,2,10,11,18,25]   # Tiempo (min)
y = [0,1,2,3,4,5]       # Distancia (m)

fig, ax = plt.subplots()

ax.plot(x, y, label='Objeto 1', color='green', marker='^', linestyle='--',
        markersize=8, linewidth=1.2)

# Mostrar el título del gráfico
ax.set_title("Gráfico de posición")

# Mostrar el título de los ejes
ax.set_xlabel('Tiempo (min)')
ax.set_ylabel('Distancia (m)')

# Establecer los límites de los ejes
ax.set_xlim(0, 30)
ax.set_ylim(0, 6)

# Agregar la refencia
ax.legend()

# Grilla preestablecida
ax.grid()
plt.show()
```

### Tipos de gráficos

A continuación, vamos a ver ejemplos de los tipos de gráficos más comunes, las funciones que son necesarias para crearlos y cuándo se debe utilizar cada uno de ellos. 

Para estos ejemplos, los datos a graficar son valores de listas únicamente por fines didácticos, ya que podría tratarse de arrays o columnas de DataFrames. Además, recuerden que mucho de lo aprendido para modificar el aspecto de un gráfico, como agregar títulos, cuadrículas, límites a los ejes, etc., se puede aplicar también en estas figuras.:

#### Gráfico de línea

El gráfico de línea permite visualizar cambios en los valores lo largo de un rango continuo (tendencias), como puede ser el tiempo o la distancia. Para crearlo, se utiliza la función `plot()`, como vimos anteriormente:

```{python}
x = [0,2,10,11,18,25]
y = [0,1,2,3,4,5]

fig, ax = plt.subplots()

ax.plot(x, y)
plt.show()
```

#### Gráfico de dispersión o puntos

El gráfico de dispersión o puntos permite visualizar la relación entre las variables. Para crearlo, se utiliza la función `scatter()`:

```{python}
x = [5,7,8,7,2,17,2,9,4,11,12,9,6]
y = [99,86,87,88,111,86,103,87,94,78,77,85,86]

fig, ax = plt.subplots()

ax.scatter(x, y)
plt.show()
```

#### Gráfico de barras

El gráfico de barras permite visualizar proporciones, comparando dos o más valores entre sí. Para crearlo, se utiliza la función `bar()`, la cual primero recibe, en primer lugar, las etiquetas de las barras que se van a mostrar y en segundo lugar, la altura correspondiente a cada una de estas barras.

```{python}
peso = [340, 115, 200, 200, 270]
ingredientes = ['chocolate', 'manteca', 'azúcar', 'huevo', 'harina']

fig, ax = plt.subplots()

ax.bar(ingredientes, peso)

ax.set_xlabel('Ingredientes')
ax.set_ylabel('Masa (g)')

ax.set_title("Receta")

plt.show()
```

Note que con la función anterior, las barras adquieren una dirección vertical: si quisieramos verlas de manera horizontal, debemos usar la función `barh()` y cambiar los títulos de los ejes según corresponda:

```{python}
peso = [340, 115, 200, 200, 270]
ingredientes = ['chocolate', 'manteca', 'azúcar', 'huevo', 'harina']

fig, ax = plt.subplots()

ax.barh(ingredientes, peso)

ax.set_ylabel('Ingredientes')
ax.set_xlabel('Masa (g)')

ax.set_title("Receta")

plt.show()
```

#### Gráfico de torta

El gráfico de torta, como el de barras, permite visualizar y comparar proporciones pero de manera circular y como partes de un todo. Para crearlo, se utiliza la función `pie()`, la cual podría recibir solamente números pero es útil también saber qué simboliza cada parte. Por eso, para referenciar cada porción se usa el parámetro `labels`. Por otro lado, el parámetro `autopct` establece cómo se mostrará el porcentaje: por ejemplo, `%1.1f%%` le indica que el porcentaje tendrá un decimal, mientras que `%1.2f%%` tendrá dos decimales.

```{python}
peso = [340, 115, 200, 200, 270]
ingredientes = ['chocolate', 'manteca', 'azúcar', 'huevo', 'harina']

fig, ax = plt.subplots()

ax.pie(peso, labels= ingredientes, autopct='%1.1f%%')

ax.set_title("Receta")

plt.show()
```

### Gráficos múltiples

En los casos anteriores, creamos siempre un sólo gráfico con una curva, en una figura. Pero... **¿Cómo podríamos graficar varias curvas en un mismo gráfico?**

```{python}
# Valores que se desean graficar
x = [0, 1, 2, 3, 4, 5]
y_linear = [0, 1, 2, 3, 4, 5]
y_quadratic = [0, 1, 4, 9, 16, 25]
y_cubic = [0, 1, 8, 27, 64, 125]

fig, ax = plt.subplots(figsize=(5, 3))

ax.plot(x, y_linear, label='Lineal')
ax.plot(x, y_quadratic, label='Cuadrático')
ax.plot(x, y_cubic, label='Cúbico')

ax.set_title("Gráfico de múltiples curvas")
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.legend()

plt.show()
```

Note que se agregan nuevos datos al mismo axes, por lo que siempre usamos `plot()` pero con distintos valores de `y`. Asimismo, se estableció un tamaño de la figura con `figsize=(width, height)`

### Grilla de gáficos

También podríamos querer ver varios axes en una misma figura. Para ello, tenemos que definir, como si se tratase de una matriz o tabla, cuántas columnas `ncols` y cuantas `nrows` de gráficos deseamos. Por ejemplo, supongamos que quiero ver dos gráficos en una misma fila:

```{python}
fig, ax = plt.subplots(nrows=1, ncols=2)   # o simplemente plt.subplots(1,2)
```

De manera análoga, podemos representar las 3 curvas anteriores pero viendo 3 filas de gráficos en una única columna:

```{python}
# Valores que se desean graficar
x = [0, 1, 2, 3, 4, 5]
x_linear = [0, 1, 2, 3, 4, 5]
x_quadratic = [0, 1, 4, 9, 16, 25]
x_cubic = [0, 1, 8, 27, 64, 125]

fig, ax = plt.subplots(nrows=3, ncols=1)

ax[0].plot(x, x_linear)
ax[0].set_title('Lineal')

ax[1].plot(x, x_quadratic)
ax[1].set_title('Cuadrático')

ax[2].plot(x, x_cubic)
ax[2].set_title('Cúbico')

plt.show()
```

Entonces, lo único que debemos hacer es **indicar la posición del axes con números dentro del corchete** . Si tengo varias columnas y filas, dentro del corchete, se indica primero la fila y luego la columna: `ax[fila, columna]`.

```{python}
fig, ax = plt.subplots(nrows=3, ncols=3)
fig.subplots_adjust(wspace=0.5, hspace=0.5) # Con esto indicamos el espacio libre entre los subplots

ax[0, 1].plot(x, x_linear)
plt.show()
```

### Funciones de Gráficas

En términos generales, si nos encontramos en la situacion de copiar y pegar las mismas líneas de código para realizar gráficos similares, trendríamos que pensar en crear una función que simplifique esta tarea. Por ejemplo:

```{python}
x = [0, 1, 2, 3, 4, 5]
x_linear = [0, 1, 2, 3, 4, 5]
x_quadratic = [0, 1, 4, 9, 16, 25]
x_cubic = [0, 1, 8, 27, 64, 125]

fig, ax=plt.subplots(3)
ax[0].plot(x,x_linear,label="$x$",color="r")
ax[0].set_xlabel("eje x")
ax[0].set_ylabel("eje y")
ax[0].legend()
ax[0].grid()


ax[1].plot(x,x_quadratic,label="$x^2$",color="b")
ax[1].set_xlabel("eje x")
ax[1].set_ylabel("eje y")
ax[1].legend()
ax[1].grid()


ax[2].plot(x,x_cubic,label="$x^3$",color="g")
ax[2].set_xlabel("eje x")
ax[2].set_ylabel("eje y")
ax[2].legend()
ax[2].grid()
plt.show()
```

Para evitar lo anterior, definimos una función a la que le debemos entregar los valores a graficar:

```{python}
def crear_grafico(x, y, label, ax, xlabel, ylabel, title, color):
  """Crea un gráfico a partir de vectores con valores de los ejes x e y.
    Recibe además:
    - El texto para el label
    - El subplot a donde graficar
    - Un label para el eje x
    - Un label para el eje y
    - Un título para el gráfico
    - Un color
    El color y el eje pueden ser None. En ese caso toman valores por default"""

  if color == None:
    color = "blue"

  # Si sólo haremos un gráfico, no necesito indicarle la posición
  if ax == None:
      fig, ax = plt.subplots()

  # Definimos el gráfico
  ax.plot(x, y, label=label, color=color)
  ax.set_xlabel(xlabel)
  ax.set_ylabel(ylabel)
  ax.set_title(title)

  return ax
```

```{python}
fig , ax = plt.subplots(3)

# En vez de copiar y pegar el código, llamo a la función crear_grafico():
crear_grafico(x, x_linear, "x", ax[0], "Eje x", "Eje y", "Lineal", color="green")
crear_grafico(x, x_quadratic, "$x^2$", ax[1], "Eje x", "Eje y", "Cuadrática", color="red")
crear_grafico(x, x_cubic, "$x^3$", ax[2], "Eje x", "Eje y", "Cúbica", None)

# Hacemos un for para agregar la cuadrícula y las referencias en cada axes:
for axes in fig.axes[:]:
  axes.grid()
  axes.legend()
```

Como comentamos dentro de la función, también podemos usar `crear_grafico()` para un único gráfico:

```{python}
crear_grafico(x, x_linear, "x", None, "", "", "", "green")
```

### Gráficos utilizando NumPy y Pandas

- **NumPy:**

Cuando se realizó el gráfico lineal, cuadrático y cúbico de x, se utilizaron listas de Python. A continuación puede ver lo fácil que podría realizarse
utilizando NumPy:

```{python}
x = np.arange(0, 6)
y_linear = x
y_quadratic = x**2
y_cubic = x**3

fig, ax = plt.subplots(figsize=(5, 3))

ax.plot(x, y_linear, label='Lineal')
ax.plot(x, y_quadratic, label='Cuadrático')
ax.plot(x, y_cubic, label='Cúbico')

ax.set_title("Gráfico de múltiples curvas")
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.legend()

plt.show()
```

- **Pandas:**

Si deseamos visualizar los datos contenidos en un DataFrame, podemos realizarlo facilmente. Definimos df:

```{python}
data = {'animal': ['gato','chinchilla', 'perro'],
        'edad': [2.5, 3, 7],
        'visitas': [1, 3, 2],
        'prioridad': ['si', 'si', 'no']}

df = pd.DataFrame(data)
df
```

```{python}
# Determino las columnas del DataFrame que queremos graficar
x_values = df['animal']
y_values = df['edad']

fig, ax = plt.subplots()

ax.bar(x_values, y_values)

ax.set_xlabel('Animal')
ax.set_ylabel('Edad (años)')

ax.set_title("Mascotas")

plt.show()
```

