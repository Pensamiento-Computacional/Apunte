[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pensamiento Computacional",
    "section": "",
    "text": "Pensamiento Computacional\nBienvenidos y bienvenidas a la cátedra de Pensamiento Computacional del Ciclo Básico Común de la Facultad de Ingeniería - UBA.",
    "crumbs": [
      "Pensamiento Computacional"
    ]
  },
  {
    "objectID": "index.html#docentes-de-la-cátedra",
    "href": "index.html#docentes-de-la-cátedra",
    "title": "Pensamiento Computacional",
    "section": "Docentes de la Cátedra",
    "text": "Docentes de la Cátedra\n\nProf. Titular: Méndez, Mariano\nAreco, Lucas\nBulacios, Juan\nCáceres, Fernando\nCapón, Lucía\nCorti, Bautista\nDuchen, Leonardo\nDuzac, Emilia\nFulco, Victoria\nGinestet, Joaquin\nJuarez Goldemberg, Mariana\nLourengo Caridade, Lucía Gabriela\nMaciel, Laura\nMaxwell, Julian\nNotari, Pablo\nOrtielli, Bruno\nPratto, Florencia\nPonti, Julieta\nRastrelli, Aldana\nRetamozo, Melina\nSzischik, Mariana",
    "crumbs": [
      "Pensamiento Computacional"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "La Materia",
    "section": "",
    "text": "Fundamentación\nEl pensamiento computacional es una disciplina que ha sido definida como “el conjunto de procesos de pensamiento implicados en la formulación de problemas y sus soluciones, de manera que dichas soluciones sean representadas de una forma que puedan ser efectivamente ejecutadas por un agente de procesamiento de información”, entendiendo por esto último a un humano, una máquina o una combinación de ambos.\nReconoce antecedentes en trabajos de la Carnegie Mellon University de la década de 1960 y del Massachusetts Institute of Technology de alrededor de 1980, aunque su auge en la educación superior llegó con la primera década del siglo XXI.\nLas herramientas básicas en las que se funda el pensamiento computacional son la descomposición, la abstracción, el reconocimiento de patrones y la algoritmia. Está ampliamente aceptado que estas herramientas no sirven solamente a los profesionales de Ciencias de la Computación y de Informática, sino a cualquier persona que deba resolver problemas, con lo cual el pensamiento computacional deviene una técnica de resolución de problemas. Actualmente, los y las profesionales de la Ingeniería requieren de una capacidad analítica que les permita resolver problemas, y en ese sentido el pensamiento computacional se convierte en un soporte invaluable de esa competencia (cada vez más las ciencias de la computación y la informática constituyen una ciencia básica para todas las ingenierías).\nSi bien el pensamiento computacional no necesariamente requiere del uso de computadoras, la programación de computadoras se convierte en su complemento ideal. En primer lugar, porque permite comprobar, mediante la codificación de un algoritmo en un programa, la validez de la solución encontrada al problema, de manera sencilla y prácticamente inmediata. En segundo lugar, porque la programación incentiva la creatividad, la capacidad para la auto organización y el trabajo en equipo. En tercer lugar, porque la programación constituye un recurso habitual del trabajo en el campo profesional de la ingeniería.",
    "crumbs": [
      "La Materia"
    ]
  },
  {
    "objectID": "intro.html#objetivos-generales",
    "href": "intro.html#objetivos-generales",
    "title": "La Materia",
    "section": "Objetivos Generales",
    "text": "Objetivos Generales\nEl objetivo general de la asignatura es que los/as estudiantes adquieran habilidades de resolución de problemas de ingeniería mediante el soporte de un lenguaje de programación multiparadigma.",
    "crumbs": [
      "La Materia"
    ]
  },
  {
    "objectID": "rules.html",
    "href": "rules.html",
    "title": "Regimen de Cursada, Calendario y Cursos",
    "section": "",
    "text": "Calendario y Cursos\nSe puede acceder al calendario de la cursada y a las aulas y horarios de los cursos a través del siguiente link.",
    "crumbs": [
      "Regimen de Cursada, Calendario y Cursos"
    ]
  },
  {
    "objectID": "rules.html#formas-de-evaluación",
    "href": "rules.html#formas-de-evaluación",
    "title": "Regimen de Cursada, Calendario y Cursos",
    "section": "Formas de Evaluación",
    "text": "Formas de Evaluación\nLa cursada de la materia cuenta con dos parciales:\n\nPrimer Parcial\n\nUnidad 1\nUnidad 2\nUnidad 3\nUnidad 4 (rangos, cadenas, tuplas y listas)\n\nSegundo Parcial\n\nUnidad 4 (diccionarios)\nUnidad 5\nUnidad 6\n\n\nCada parcial cuenta con un único recuperatorio.",
    "crumbs": [
      "Regimen de Cursada, Calendario y Cursos"
    ]
  },
  {
    "objectID": "rules.html#aprobación-de-la-cursadamateria",
    "href": "rules.html#aprobación-de-la-cursadamateria",
    "title": "Regimen de Cursada, Calendario y Cursos",
    "section": "Aprobación de la Cursada/Materia",
    "text": "Aprobación de la Cursada/Materia\nSe tiene dos formas de aprobación de la cursada:\n\nRegularización\nPromoción\n\n\nRegularización\nPara regularizar la cursada, se deben aprobar los dos parciales (o recuperatorios) con un mínimo de nota de 4 (cuatro) en cada uno.\n\nLa cursada regularizada habilita a rendir el examen final integrador, para el cual se tienen 3 (tres) oportunidades de rendir (más información abajo).\n\n\nPromoción\nPara promocionar la materia, se debe tener un promedio entre los dos parciales (o recuperatorios) de 7 (siete).\n\n\n\n\n\n\n\nRendir Recuperatorios para Promoción\n\n\n\n\n\nSi se desea rendir el recuperatorio para intentar subir la nota para la promoción, se debe tener en cuenta que la cátedra considerará únicamente válida la nota del último examen que se haya rendido.\nEjemplo:\n# caso 1\nparcial1 = 5\nrecuperatorio1 = 7\n=&gt; nota final parcial1 = 7\n\n# caso 2\nparcial1 = 5\nrecuperatorio1 = 4\n=&gt; nota final parcial1 = 4\n\n\n\n\n\nExamen Final Integrador\nEl examen final integrador consta de una evaluación que incluye todos los temas de la materia. Los mismos se rinden al final del cuatrimestre. Se aprueba con una nota mayor o igual a 4 (cuatro).\n\n\n\n\n\n\nDesaprobación de la Materia\n\n\n\nSi se desaprueba alguno de los parciales, el mismo puede recuperarse una sola vez.\nSi se desaprueba un recuperatorio, se debe volver a cursar la materia el cuatrimestre siguiente.\nSi se desaprueba 3 (tres) veces el examen final integrador, se debe volver a cursar la materia el cuatrimestre siguiente.",
    "crumbs": [
      "Regimen de Cursada, Calendario y Cursos"
    ]
  },
  {
    "objectID": "material.html",
    "href": "material.html",
    "title": "Videos y Diapositivas",
    "section": "",
    "text": "Taller de Herramientas\nLa parte teórica de la materia incluye ver los videos y leer los apuntes que se encuentran en esta página. Los apuntes contienen información que se tendrá en cuenta al momento de evaluar la materia en los parciales.\nLas clases teóricas son virtuales y asincrónicas. Los videos se encuentran en el  canal de Youtube de la materia, cada uno con su lista de reproducción correspondiente.\nLas clases prácticas son presenciales. Las diapositivas usadas en la práctica se encuentran en siguiente link y están organizadas por curso.\nLa materia cuenta con un “Taller de Herramientas” en el  canal de Youtube.\nEn esta lista de videos, se explica cómo utilizar las herramientas de la materia como Discord, la página oficial y Google Colab.",
    "crumbs": [
      "Videos y Diapositivas"
    ]
  },
  {
    "objectID": "unidad_1.html",
    "href": "unidad_1.html",
    "title": "1  Introducción a la Algoritmia y a la Programación",
    "section": "",
    "text": "1.1 Introducción\nComo en todas las disciplinas, la Ingeniería de Software y la Programación de Sistemas en general tienen un lenguaje técnico específico. La utilización de ciertos términos y el compartir de ciertos conceptos agiliza el diálogo y mejora la comprensión con los pares.\nEn este capítulo vamos a hacer una breve introducción de ciertos conceptos, ideas y modelos que van a permitirnos establecer acuerdos y manejar un lenguaje común.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la Algoritmia y a la Programación</span>"
    ]
  },
  {
    "objectID": "unidad_1.html#introducción",
    "href": "unidad_1.html#introducción",
    "title": "1  Introducción a la Algoritmia y a la Programación",
    "section": "",
    "text": "1.1.1 La Computadora\nUna computadora es un dispositivo físico de procesamiento de datos, con un propósito general. Todos los programas que escribiremos serán ejecutados (o corridos) en una computadora. Una computadora es capaz de procesar datos y obtener nueva información o resultados.\n\n\n1.1.2 Software y Hardware\nToda computadora funciona con software y hardware. El software es el conjunto de herramientas abstractas (programas), y se le llama componente lógica del modelo computacional. El hardware es el componente físico del dispositivo. Básicamente, el software dice qué hacer, y el hardware lo hace.\n\n\n\n\n\n\n¿Es indispensable tener una computadora para crear un algoritmo?\n\n\n\n\nLa respuesta, sorprendentemente, es no: muchos de los algoritmos que se utilizan de forma computacional hoy en día fueron diseñados varias décadas atrás. Pero la implementación de un algoritmo depende del grado de avance del hardware y la tecnología disponible.\n\n\n\n\n1.1.3 Sistema Operativo\nEl sistema operativo es el programa encargado de administrar los recursos del sistema. Los recursos (como la memoria, por ejemplo) son disputados entre diferentes programas o procesos ejecutándose al mismo tiempo. El sistema operativo es el que decide cómo administrar y asignar los recursos disponibles.\nLos sistemas operativos más comunes el día de hoy son: Windows, Linux, iOS, Android; por ejemplo.\n\n\n1.1.4 Algoritmo\nUn algoritmo es una serie finita de pasos precisos para alcanzar un objetivo.\n\n“serie”: porque son continuados uno detrás del otro, de forma ordenada.\n“finita”: porque no pueden ser pasos infinitos, en algún momento deben terminar.\n“pasos precisos”: porque en un algoritmo se debe ser lo más específico posible.\n\n\nEjemplo Un algoritmo puede ser una receta de cocina: tiene una serie finita de pasos (son ordenados, uno detrás de otro, finitos porque en algún momento deben terminar), que son precisos (porque tienen indicaciones de cuánto agregar de cada ingrediente, cómo incorporarlo a la preparación, etc) y están orientados en alcanzar un objetivo (obtener una comida en particular).\n\n\n1.1.4.1 Creación de un Algoritmo\nLa forma en la que trabajaremos la creación de un algoritmo es siguiendo los siguientes pasos:\n\nAnálisis del problema: entender el objetivo y los posibles casos puntuales del mismo.\n\nPrimer borrador de solución: confeccionar una idea generalizada de cómo podría resolverse el problema.\n\nDivisión del problema en partes: dividir el problema en partes ayuda a descomponer un problema complejo en varios más sencillos.\n\nEnsamble de las partes para la versión final del algoritmo: acoplar todo el conjunto de partes del problema para lograr el objetivo general.\n\n\nEstos cuatro pasos podrán iterarse (repetirse) la cantidad de veces que sean necesarios, para poder lograr acercarnos más a la solución en cada iteración.\n\n\n\n1.1.5 Programa\nUn programa es un algoritmo escrito en un lenguaje de programación.\n\n\n1.1.6 Lenguaje de Programación\nUn lenguaje de programación es un protocolo de comunicación.\nUn protocolo es un conjunto de normas consensuadas.\n\\(\\implies\\) Entonces, un lenguaje de programación es un conjunto de normas consensuadas, entre la persona y la máquina, para poder comunicarse.\nCuando logramos que un lenguaje pueda ser comprendido por el humano y por la máquina, tenemos una comunicación efectiva en donde podremos hacer programas y pedirle a la máquina que los ejecute.\nUn buen ejemplo de cómo una computadora interpreta nuestras instrucciones sin pensar al respecto, sin tener sentido común y sin ambigüedades, es este video. La computadora lo único que hace es interpretar de forma explícita lo que nosotros le pedimos que haga.\nUn lenguaje de programación tiene reglas estrictas que se deben respetar y no se admiten ambiguedades o sobreentendidos.\n\n\n1.1.7 Entorno de Desarrollo\nUn entorno de desarrollo es un conjunto de herramientas que nos permiten escribir, editar, compilar y ejecutar programas.\n\nEn la materia utilizaremos un entorno de desarrollo llamado Google Colab, que nos permite escribir código en un editor de texto, compilarlo y ejecutarlo en un mismo lugar de forma online. Pero existen muchos otros entornos de desarrollo, como por ejemplo Visual Studio Code, Eclipse, NetBeans, etc.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la Algoritmia y a la Programación</span>"
    ]
  },
  {
    "objectID": "unidad_1.html#lenguaje-python",
    "href": "unidad_1.html#lenguaje-python",
    "title": "1  Introducción a la Algoritmia y a la Programación",
    "section": "1.2 Lenguaje Python",
    "text": "1.2 Lenguaje Python\nEn este curso utilizaremos el lenguaje de programación Python. Python es un lenguaje de programación de propósito general, que se utiliza en muchos ámbitos de la industria y la academia.\nPython es un lenguaje realmente fácil de aprender, con una curva de aprendizaje muy suave. Es un lenguaje de alto nivel, lo que significa que es un lenguaje que se asemeja mucho al lenguaje natural, y que no requiere de conocimientos de bajo nivel para poder utilizarlo.\n\n1.2.1 Hola, Mundo!\nEl primer programa que se escribe en cualquier lenguaje de programación es el programa “Hola, Mundo!”. Este programa es un programa que imprime en pantalla el texto “Hola, Mundo!”.\nEn Python, el programa “Hola, Mundo!” se escribe de la siguiente forma:\n\nprint(\"Hola, Mundo!\")\n\nHola, Mundo!\n\n\nprint es una función que imprime en pantalla el texto que se le pasa entre paréntesis. En este caso, el texto que se le pasa como parámetro es \"Hola, Mundo!\". Al escribir las comillas dobles, estamos indicando que el texto que se encuentra entre ellas es un texto literal.\nDe la misma forma, podremos imprimir cualquier otro mensaje en pantalla, como por ejemplo:\n\nprint(\"Hola, me llamo Rosita y soy programadora\")\n\nHola, me llamo Rosita y soy programadora\n\n\nAl igual que Rosita, al hacer nuestro primer ‘Hola, Mundo!’ nos convertimos en programadores. ¡Felicitaciones!\nA partir de la próxima clase, comenzaremos a ver cómo escribir programas más complejos, que nos permitan resolver problemas más interesantes.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la Algoritmia y a la Programación</span>"
    ]
  },
  {
    "objectID": "unidad_1.html#anexo-google-colab",
    "href": "unidad_1.html#anexo-google-colab",
    "title": "1  Introducción a la Algoritmia y a la Programación",
    "section": "1.3 Anexo: Google Colab",
    "text": "1.3 Anexo: Google Colab\n\n1.3.1 Cómo usar Google Colab\nPara usar Google Colab, debemos ingresar a este link. Si es necesario, debemos crear una cuenta de Google.\nAl abrir Google Colab por primera vez, vamos a ver lo siguiente:\n\n\n\nInicio en Google Colab\n\n\nVamos entonces a hacer click en “New Notebook”, y se va a abrir un archivo nuevo, con extensión .ipynb (que es la extensión de un archivo del tipo IPython Notebook). Vamos a cambiarle el nombre de ‘Untitled0’ a ‘Unidad_1’ o el nombre que prefieran.\n\n\n\nArchivo nuevo\n\n\n\n1.3.1.1 Celdas de Código\nCon Colab vamos a poder correr nuestro código. Colab se divide en celdas individuales: cada celda es un bloque de código que se puede correr por separado. Para agregar una celda nueva, se hace click en el botón de “+ Code” que aparece en la parte superior izquierda de la celda. Para correr la celda, se hace click en el botón de “play” que aparece a la izquierda de la celda. El output (la salida) de la celda va a aparecer debajo de la misma.\n\n\n\n\n\n\nCómo usar las celdas\n\n\n\nLes recomendamos que cada ejercicio de la guía esté en una celda separada. A medida que avance la materia vamos a terminar de entender bien por qué.\n\n\n\n\n\nEjecución de una celda de código\n\n\nSi tenemos varias celdas con código, podemos correrlas todas juntas haciendo click en “Runtime” o “Entorno de Ejecución” en el menú superior y luego en “Run all” (o “Ejecutar Todo”). Cada celda de código va a tener su propio output debajo de ella.\n\n\n\nEjecución simultánea de dos celdas de código\n\n\n\n\n1.3.1.2 Celdas de Texto\nAsí también como podemos agregar celdas de código, podemos agregar celdas de texto. Para eso, hacemos click en el botón de “+ Text” que aparece en la parte superior izquierda de la celda. Dentro podemos escribir texto con formato e incluso agregar imágenes.\n\n\n\n1.3.1.3 Opciones de Celdas\nPara reordenar, eliminar o copiar celdas, al seleccionar una celda aparece un menú a la derecha con distintos íconos. Podemos usar estas opciones para realizar estas distintas acciones.\n\n\n\n1.3.1.4 Aclaración IA\n\nPara desactivar las sugerencias con IA (recomendado hacerlo) pueden ir a: Herramientas &gt; Configuración &gt; Asistente IA &gt; Tildar “Ocultar funciones de IA generativa”.\n\n\n\n1.3.1.5 Beneficios de usar Google Colab\n\nGoogle Colab tiene una mejor interfaz para usar Pandas, mostrando el output en forma de tablas.\nPermite importar datos de Google Drive\nPermite compartir el código con otras personas, de tal forma que todas ellas puedan editar un mismo archivo\nPermite guardar los archivos en Google Drive, con guardado automático de cambios\nPermite exportar el archivo en distintos formatos, como PDF, HTML, etc.\nPermite intercalar código ejecutable con texto explicativo, lo que lo hace ideal para la creación de informes, presentaciones, o tutoriales.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introducción a la Algoritmia y a la Programación</span>"
    ]
  },
  {
    "objectID": "unidad_2.html",
    "href": "unidad_2.html",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "",
    "text": "2.1 Sentencias Básicas\nEn esta unidad vamos a centrarnos en la herramienta que vamos a emplear, que es Python. Vamos a hacer un programa sencillo, interactuar con el usuario y más.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tipos de Datos, Expresiones y Funciones</span>"
    ]
  },
  {
    "objectID": "unidad_2.html#sentencias-básicas",
    "href": "unidad_2.html#sentencias-básicas",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "",
    "text": "2.1.1 Flujo de Control de un Programa\nEl flujo de control de un programa es la forma en la que se ejecutan las instrucciones de un programa. En Python, el flujo de control es secuencial, es decir, se ejecutan las instrucciones una detrás de otra.\nEjemplo:\nEsta línea se ejecutaría primero        ↓\nEsta línea se ejecutaría después        ↓\nEsta línea se ejecutaría a lo último    \nEn este curso, la comunicación de los programas con el mundo exterior se realizará casi exclusivamente con el usuario por medio de la consola (o terminal, la presentamos en la unidad anterior en el anexo de Colab).\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nEsto no significa que todos los programas siempre se comuniquen con el usuario para todo. Pensemos en las aplicaciones que usamos generalmente, como instagram: imaginémonos si para cada acción que hiciéramos dentro de la app la misma nos preguntara si queremos hacerlo o no:\n\n- “¿Estás seguro/a de que querés iniciar sesión?”\n- “¿Estás seguro/a de que querés traer tu nombre de usuario para mostrarse en el perfil?”\n- “¿Estás seguro/a de que querés traer tu foto de usuario para mostrarse en el perfil?”\n\nSería extremadamente molesto. Uno simplemente inicia sesión, y hay un montón de cosas y procesos que se ejecutan uno detrás de otro, automáticamente.\n\nHay cosas que no necesitan de la interacción del usuario. Nosotros nos vamos a centrar en la interacción con el usuario en gran parte del curso, pero no es lo único que se puede hacer. Los programas pueden comunicarse con otros programas y las partes de un mismo programa pueden comunicarse con otras partes del mismo programa.  Más adelante vamos a ver un poco más de esta diferencia.\n\n\n\n\n2.1.2 Valores y Tipos\nSi tenemos la operación 7 * 5, sabemos que el resultado es 35. Decimos que tanto 7, 5 como 35 son valores. En los lenguajes de programación, cada valor tiene un tipo.\nEn este caso, 7, 5 y 35 son enteros (o integers en inglés). En Python, los enteros se representan con el tipo int.\nPython tiene dos tipos de datos numéricos:\n\nnúmero enteros\nnúmeros de punto flotante\n\nLos números enteros representan un valor entero exacto, como 42, 0, -5 o 10000.\nLos números de punto flotante tienen una parte fraccionaria, como 3.14159, 1.0 o 0.0.\nSegún los operandos (los valores que se operan) y el operador (el símbolo que indica la operación), el resultado puede ser de un tipo u otro. Por ejemplo, si tenemos 7 / 5, el resultado es 1.4, que es un número de punto flotante. Si tenemos 7 + 5, el resultado es 12, que es un número entero.\n\nprint(1 + 2)\n\n3\n\n\n\n\n\n\n\n\nNote\n\n\n\nprint es una función de Python que nos deja imprimir cosas por pantalla. Al hacer print(1+2), Python está calculando el resultado de 1+2 e imprimiéndolo para que podamos verlo.\n\n\nVamos a elegir usar enteros cada vez que necesitemos recordar, almacenar o representar un valor exacto, como pueden ser por ejemplo: la cantidad de alumnos, cuántas veces repetimos una operación, un número de documento, etc.\nVamos a elegir usar números de punto flotante cada vez que necesitemos recordar, almacenar o representar un valor aproximado, como pueden ser por ejemplo: la altura o el peso de una persona, la temperatura de un día, una distancia recorrida, etc.\n\nprint(0.1 + 0.2)\n\n0.30000000000000004\n\n\nComo vemos, cuando hay números de punto flotante, el resultado es aproximado. 0.1 + 0.2 nos debería dar 0.3, pero nos da 0.30000000000000004. Esto es porque los números de punto flotante son aproximados, y no pueden representar todos los valores de forma exacta. Esto es algo que vamos a tener que tener en cuenta cuando trabajemos con números de punto flotante.\n\n\n\n\n\n\nUso de punto\n\n\n\nNotemos que para representar números de punto flotante, usamos el punto (.) y no la coma (,). Esto es porque en Python, la coma se usa para separar valores, como vamos a ver más adelante.\n\n\nAdemás de efectuar operaciones matemáticas, Python nos permite trabajar con porciones de texto, que se llaman cadenas (o strings en inglés). Las cadenas se representan con el tipo str.\nLas cadenas se escriben entre comillas simples (') o dobles (\").\n\nprint( \"¡Hola!\" )\n\n¡Hola!\n\n\n\nprint( '¡Hola!' )\n\n¡Hola!\n\n\nLas cadenas también tienen operaciones disponibles, como por ejemplo la concatenación, que es la unión de dos cadenas en una sola. Esto se hace con el operador +.\n\nprint( \"¡Hola!\" + \" ¿Cómo estás?\" )\n\n¡Hola! ¿Cómo estás?\n\n\nVamos a ver más de estas operaciones más adelante.\n\n\n2.1.3 Variables\nPython nos permite asignarle un nombre a un valor, de forma tal que podamos “recordarlo” y usarlo más adelante. A esto se le llama asignación.\nEstos nombres se llaman variables, y son espacios de memoria donde podemos almacenar valores.\n\nLa asignación se hace con el operador = de la siguiente forma: &lt;nombre&gt; = &lt;valor o expresion&gt;.\nEjemplos: Vamos a guardar el valor 5 en la variable x. Luego, vamos a sumarle 2 y guardarlo en la variable y.\n\nx = 5\n\n\ny = x + 2\n\n\nprint(y)\n\n7\n\n\n\nprint(y * 2)\n\n14\n\n\n\nlenguaje = \"Python\"\n\ntexto = \"Estoy programando en \" + lenguaje\nprint(texto)\n\nEstoy programando en Python\n\n\nEn este ejemplo, creamos las siguientes variables:\n\nx\ny\nlenguaje\ntexto\n\ny las asociamos a los valores 5, 7, “Python” y “Estoy programando en Python” respectivamente. Luego podemos usar esas variables como parte de cualquier expresión, y en el momento de evaluarla, Python reemplazará las variables por su valor asociado.\n\n\n\n\n\n\nVariables y Constantes\n\n\n\nSi el dato es inmutable (no puede cambiar) durante la ejecución del programa, se dice que ese dato es una constante. Si tiene la habilidad de cambiar, se dice que es una variable. En Python, todas las variables son mutables, es decir, pueden cambiar su valor durante la ejecución del programa.\nY no sólo pueden cambiar su valor, sino también su tipo: x = 5 y x = \"Hola\" son dos asignaciones válidas, y se pueden hacer una debajo de la otra:\n\nx = 5\nx = \"Hola\"\nprint(x)\n\nHola\n\n\n\n\n\n\n\n\n\n\nNombres de Variables\n\n\n\nNo se puede usar el mismo nombre para dos datos diferentes a la vez; una variable puede referenciar un sólo dato por vez. Si se usa un mismo nombre para un dato diferente, se pierde la referencia al dato anterior.\n\n\n\n\n\n2.1.4 Funciones\nPara poder realizar algunas operaciones particulares, necesitamos introducir el concepto de función. Una función es un bloque de código que se ejecuta cuando se la llama.\nEs un fragmento de programa que permite efectuar una operación determinada. abs, print, max son ejemplos de funciones de Python: abspermite calcular el valor absoluto de un número, print permite mostrar un valor por pantalla y max permite calcular el máximo entre dos valores.\n\nUna función puede recibir cero o más parámetros o argumentos, que son valores que se le pasan a la función entre paréntesis y separados por comas, para que los use.\n\n\nabs(-5)\n\n5\n\n\n\nprint(\"¡Hola!\")\n\n¡Hola!\n\n\n\nmax(5, 7)\n\n7\n\n\nLa función recibe los parámetros, efectúa una operación y devuelve un resultado.\nPython viene equipado de muchas funciones predefinidas, pero nosotros como programadores debemos ser capaces de escribir nuevas instrucciones para la computadora. Las grandes aplicaciones como el correo electrónico, navegación web, chat, juegos, etc. no son más que grandes programas implementados introduciendo nuevas funciones a la máquina, escritas por uno o más programadores.\n\n\n\nUna función recibe parámetros y devuelve un resultado\n\n\n\n\n\n\n\n\nPython es Case Sensitive\n\n\n\nPython es Case Sensitive, es decir, distingue entre mayúsculas y minúsculas.\nEs muy importante respetar mayúsculas y minúsculas: PRINT() o prINT() no serán reconocidas. Esto aplica para todo lo que escribamos en nuestros programas.\n\n\nSi queremos crear una función que nos devuelva un saludo a Lucia cada vez que se la llama, debemos ingresar el siguiente conjunto de líneas en Python:\n\ndef saludar_lucia():\n  return \"Hola, Lucia!\"\n\nPodés copiar el código y pegarlo en Colab. Luego, apretá “Run”. Vas a notar que no pasa nada, ahora vamos a ver por qué.\nVarias cosas a notar del código:\n\nsaludar_lucia es el nombre de la función. Podría ser cualquier otro nombre, pero es una buena práctica que el nombre de la función describa lo que hace.\n\ndef es una palabra clave que indica que estamos definiendo una función.\n\nreturn indica el valor que devuelve la función. Es decir, el resultado. Puede devolverse una sola cosa, como en este caso, o varias cosas separadas por comas.\n\nLa sangría (el espacio inicial) en el renglón 2 le indica a Python que estamos dentro del cuerpo de la función. El cuerpo de la función es el bloque de código que se ejecuta cuando se llama a la misma.\n\n\n\n\n\n\n\n\nSangría\n\n\n\nLa sangría puede ingresarse utilizando dos o más espacios, o presionando la tecla Tab. Es importante prestar atención en no mezclar espacios con tabs, para evitar “confundir” al intérprete (en nuestro caso, Colab).\n\n\n\n\n\n\n\n\nFirma de la función\n\n\n\nLa firma de una función es la primera línea de la misma, donde se indica el nombre de la función y los parámetros que recibe. Así como la firma de una persona permite identificarla de otra, la firma de una función permite identificarla y diferenciarla de otra.\n\n\nComo vimos más arriba, el bloque de código anterior no hace nada. Para que la función haga algo, tenemos que llamarla. Para llamar a una función, escribimos su nombre, seguido de paréntesis y los parámetros que recibe (si es que recibe alguno), separados por comas.\nsaludar_lucia()\nSe dice que estamos invocando o llamando a la función. Y al invocar una función, se ejecutan las instrucciones que habíamos escrito en su cuerpo.\n\nPero de nuevo, vemos que no pasa nada. ¿Por qué? Porque la función usa return para devolver un valor. Pero nosotros no estamos haciendo nada con ese valor. Para poder verlo, tenemos que imprimirlo por pantalla.\n\nsaludo = saludar_lucia()\nprint(saludo)\n\nHola, Lucia!\n\n\nLo que hicimos fue asignar el resultado devuelto por saludar_lucia a la variable saludo, y luego imprimir el valor de la variable por pantalla (aunque el paso de guardado es opcional, podríamos imprimirlo directamente).\nBueno, ahora podemos saludar a Lucia. Pero vamos a querer saludar a otras personas también. ¿Tiene sentido hacer una función por cada persona? No, porque tendríamos muchas funciones (llamadas por ejemplo saludar_lucia, saludar_mariana, saludar_emilia, etc) que básicamente hacen lo mismo: saludar a alguien.\nUna de las características de una función es que sea una solución reutilizable a un problema. En nuestro caso, queremos saludar personas.\n¿Cómo hacemos entonces? Podemos hacer una función que reciba el nombre de la persona a saludar como parámetro. Un parámetro es un valor necesario para la ejecución de la función. En nuestro caso, indica a quién vamos a saludar:\n\ndef saludar(nombre):\n  return \"Hola, \" + nombre + \"!\"\n\nDe esta forma, podemos saludar a cualquier persona, pasando su nombre como parámetro.\n\n# Esta es otra forma de imprimir, sin necesidad de guardarnos\n# el resultado de la función en una variable,\n# simplemente la imprimimos\nprint(saludar(\"Lucia\"))\n\nHola, Lucia!\n\n\n\nprint(saludar(\"Serena\"))\n\nHola, Serena!\n\n\n\n\n\n\n\n\nReturn vs Print\n\n\n\n¿Qué significa que una función devuelva o retorne algo?\nQue una función devuelva o retorne algo, significa que no se está encargando de mostrar el resultado en pantalla. Pero, ¿está haciendo algo si no lo puedo ver en pantalla? Por supuesto, hay muchas cosas que ocurren “por detrás”, sin que nos demos cuenta, en una computadora. Si nosotros llamamos a la función saludar pasándole un nombre de esta forma saludar(\"Serena\"), la función está armando el saludo y devolviéndolo, aunque nosotros no estemos viendo nada en la pantalla. Incluso si lo guardáramos en una variable (saludo = saludar(\"Serena\")), también se está ejecutando y la variable saludo está almacenando el saludo, por más de que no veamos eso en ningún lado.  La gran mayoría de las funciones van a retornar valores calculados, pero no van a ser responsables de mostrarlos en pantalla. Eso es algo que vamos a tener que ocuparnos por fuera, si quisiéramos ver el resultado.\n\n\n\n2.1.4.1 Ejemplos\n\nEjemplo\nEscribir una función que calcule el doble de un número.\n\n\ndef obtener_doble(numero):\n  return numero * 2\n\nPara invocarla, debemos llamarla pasándole un número:\n\ndoble = obtener_doble(5)\nprint(doble)\n\n10\n\n\n\nEjemplo\nPensá un número, duplícalo, súmale 6, divídelo por 2 y resta el número que elegiste al comienzo. El número que queda es siempre 3.\n\n\ndef f(numero):\n  return ((numero * 2) + 6) / 2 - numero\n\n\nprint(f(5))\n\n3.0\n\n\n\n\n\n2.1.5 Ingreso de Datos por Consola\nHasta ahora, los programas que hicimos no interactuaban con el usuario. Pero para que nuestros programas puedan interactuar, vamos a querer que el usuario pueda ingresar datos, y que el programa pueda mostrarle datos por pantalla. Para esto, vamos a usar la función input.\ninput()\nInput es una función que bloquea el flujo del programa, esperando a que el usuario ingrese una entrada por consola y presione enter. Cuando el usuario presiona enter, la función devuelve el valor ingresado por el usuario.\n\ninput()\nprint(\"terminé!\")\nSi corremos el bloque de código anterior (te recomendamos que lo hagas), vamos a tener un comportamiento como este:\n\nLa consola va a quedar vacía, esperando el ingreso del usuario\nIngresamos un valor, el que tengamos ganas, y presionamos enter.\nLa consola muestra el mensaje “terminé!”.\n\n\n\n\nInput bloquea el flujo del programa\n\n\n\n\n\nIngresamos un valor (puede ser un número, texto, o ambos)\n\n\n\n\n\nAl presionar Enter, la consola muestra el mensaje “terminé!”\n\n\n\n2.1.5.1 Obteniendo el Valor Ingresado\nComo dijimos más arriba, la función input devuelve el valor ingresado por el usuario. Para poder usarlo, tenemos que guardarlo en una variable.\nnombre = input()\nprint(\"Hola, \" + nombre + \"!\")\n\n\n\nIngresamos “Mariana” y presionamos Enter.\n\n\nPara hacer nuestro programa más amigable, podemos mostrarle al usuario un mensaje antes de pedirle que ingrese un valor. Para esto, podemos pasarle un parámetro a la función input, que es el mensaje que queremos mostrarle al usuario.\nnombre = input(\"Ingresá tu nombre: \")\nprint(\"Hola, \" + nombre + \"!\")\n\n\n\nIngresamos “Mariana” y presionamos Enter.\n\n\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nA partir de la guía 2, a menos que el ejercicio diga específicamente “pedirle al usuario”, no se debe usar input, sino que todo tiene que recibirse por parámetro en la función.\nLo mismo con print: A menos que el ejercicio diga específicamente “imprimir”, todo siempre se tiene que devolver con un return.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tipos de Datos, Expresiones y Funciones</span>"
    ]
  },
  {
    "objectID": "unidad_2.html#buenas-prácticas-de-programación",
    "href": "unidad_2.html#buenas-prácticas-de-programación",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "2.2 Buenas Prácticas de programación",
    "text": "2.2 Buenas Prácticas de programación\n\n2.2.1 Sobre Comentarios\nLos comentarios son líneas que se escriben en el código, pero que no se ejecutan. Sirven para que el programador pueda dejar notas en el código, para que se entienda mejor qué hace el programa.\nLos comentarios se escriben con el símbolo #. Todo lo que esté a la derecha del # no se ejecuta. También se pueden encerrar entre tres comillas dobles (\"\"\") para escribir comentarios de varias líneas.\n# Esto es un comentario\n\n\"\"\" Esto es un comentario\nde varias líneas \"\"\"\nNo es correcto escribir comentarios que no aporten nada al código, o tener el código absolutamente plagado de comentarios. Los comentarios deben ser útiles, y deben aportar información que no se pueda inferir del código. Nuestro primer intento de hacer el código más entendible no tienen que ser los comentarios, sino mejorar el código en sí.\n\n\n2.2.2 Sobre Convención de Nombres\nPara nombres de variables y funciones, en Python se usa snake_case, que es básicamente dejar todas las palabras en minúscula y unirlas con un guión bajo. Ejemplos: numero_positivo, sumar_cinco, pedir_numero, etc.  Siempre emplear un nombre que nos remita al significado que tendrá ese dato, siempre en snake_case: numero, letra, letra2, edad_hermano, etc.\n\n2.2.2.1 Variables\nLas variables son cosas. Entonces sus nombres son sustantivos: nombre, numero, suma, resta, resultado, respuesta_usuario. La única excepción son las variables booleanas (ya las vamos a ver, son aquellas que pueden guardar dos posibles valores: verdadero o falso), que suelen tener nombres como es_par, es_cero, es_entero, porque su valor es true o false.\nA veces es útil alguna frase para identificar mejor el contenido:\nedad_mayor_hijo, apellido_conyuge\n\n\n2.2.2.2 Funciones\nLas funciones hacen algo. Entonces sus nombres son verbos. Se usan siempre verbos en infinitivo (terminan en -ar, -er, -ir): calcular_suma, imprimir_mensaje, correr_prueba, obtener_triplicado, etc.\nDe nuevo, las excepciones son las funciones que devuelven un valor booleano (V o F). Esas pueden llamarse como: es_par, da_cero, tiene_letra_a, porque devuelven verdadero o falso, y eso nos confirma o niega la afirmación que hace el nombre.\n\n\n\n2.2.3 Sobre Ordenamiento de Código\nCuando uno corre Python, lo que hace el lenguaje es leer línea a línea nuestro código. Lo que se puede ejecutar, lo ejecuta. Las funciones las guarda en memoria para poder usarlas luego.\nEntonces es más ordenado y prolijo primero poner todas las funciones, y después el código “ejecutable” (si van a dejar código suelto en el archivo, cosa que en general no se suele recomendar).\n\nAdemás, no olvidemos que Python tiene un flujo de control de arriba para abajo. Si intentamos invocar funciones antes de que estén definidas (def), Python no va a saber qué hacer, y nos va a tirar un error.\n\nEsto es correcto: \nEsto es incorrecto: \n\n\n2.2.4 Sobre uso de Parámetros en Funciones\nUna función se puede pensar como una caja cerrada o una fábrica. La función tiene dos puertas: una de entrada y una de salida.\nLa puerta de entrada son los parámetros y la de salida es el output (el resultado).\n\n\n\nCuando se llama o invoca a la función, la puerta de entrada se abre, permitiéndonos enviarle (pasarle) cero, uno o más parámetros a la función (según cómo esté definida). Los parámetros son datos que la función necesita para funcionar, y como ya dijimos, se le pasan a la misma entre los paréntesis de la llamada.\n\n\nEjemplo: saludar(nombre), imprimir_elementos(lista), sumar(numero1, numero2), etc.\n\n\n\n\nUna vez que la función se empieza a ejecutar, ambas puertas se cierran. Esto quiere decir que, mientras la función se está ejecutando, nada entra y nada sale de la misma.\nLa función debería trabajar únicamente con los datos que se le hayan pasado por parámetro o que se le pidan al usuario dentro de ella, pero no debería utilizar nada que esté por fuera de la misma.\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nPython nos deja usar cosas por fuera de la función y sin recibir los datos por parámetro, porque es un lenguaje muy benevolente. Pero está mal usar cosas que no se hayan recibido por parámetro: es una mala práctica.\n\n\n\n\n\nUna vez que la función terminó de ejecutarse, el o los valores de salida (resultados) se devuelven por el output. Una función puede retornar uno o más elementos, o podría simplemente no retornar nada.\nreturn suma, return numero1, numero2, return, etc.\n\n\n\nPodemos ver la diferencia entre enviar algo por parámetro y usarlo por fuera de la función a continuación:\n\n\n\nEsto está mal\n\n\nEsto está bien\n\n\n\n\ndef saludar():\n  print(\"Hola, \" + nombre + \"!\")\n\nnombre = \"Manuela\"\nsaludar()\n\n\ndef saludar(persona):\n  print(\"Hola, \" + persona + \"!\")\n\nnombre = \"Manuela\"\nsaludar(nombre)\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nComo podemos observar los nombres de los argumentos cuando se invoca y en la definición de la firma pueden ser los mismos o distintos. En este caso, la función sabe que está recibiendo algo como parámetro, y sabe que dentro de su cuerpo a este dato lo va a identificar como persona, pero no hace falta que la variable que nosotros le pasamos como parámetro también se llame persona: en este caso se llama nombre.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tipos de Datos, Expresiones y Funciones</span>"
    ]
  },
  {
    "objectID": "unidad_2.html#tipos-de-datos",
    "href": "unidad_2.html#tipos-de-datos",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "2.3 Tipos de Datos",
    "text": "2.3 Tipos de Datos\n\n2.3.1 Datos Simples\nLos programas trabajan con una gran variedad de datos. Los datos más simples son los que ya vimos: números enteros, números de punto flotante y cadenas.\nPero dependiendo de la naturaleza o el tipo de información, cabrá la posibilidad de realizar distintas transformaciones aplicando operadores. Por eso, a la hora de representar información no sólo es importante que identifiquemos al dato y podamos conocer su valor, sino saber qué tipo de tratamiento podemos darle.\nTodos los lenguajes tienen tipos predefinidos de datos. Se llaman predefinidos porque el lenguaje ya los conoce: sabe cómo guardarlos en memoria y qué transformaciones puede aplicarles.\nEn Python, tenemos los siguientes tipos de datos:\n\n\n\n\n\n\n\n\nTipo\nDescripción\nEjemplo\n\n\n\n\nint\nNúmeros enteros\n5, 0, -5, 10000\n\n\nfloat\nNúmeros de punto flotante o reales\n3.14159, 1.0, 0.0\n\n\ncomplex\nNúmeros complejos\n(1, 2j), (1.0,-2.0j), (0,1j). La componente con j es la parte imaginaria.\n\n\nbool\nValores booleanos o valores lógicos\nTrue, False\n\n\nstr\nCadenas de caracteres\n\"Hola\", \"Python\", \"¡Hola, mundo!\", \"\" (cadena vacía, no contiene ningún caracter)\n\n\n\n\n\n\n\n\n\n¿Por qué se llaman “cadenas de caracteres”?\n\n\n\nPorque son una cadena de caracteres, es decir, una secuencia de caracteres. Por ejemplo, la cadena “Hola” está formada por los caracteres “H”, “o”, “l” y “a”. Esto nos permite acceder a cada uno de los caracteres de la cadena por separado si quisiéramos, o a porciones de una cadena, como vamos a ver más adelante.\nMás aún, podemos ver que el texto “hola” no será igual a “aloh” ni a “Holá”, porque son cadenas distintas.\nUn string permite almacenar cualquier tipo de caracter unicode dentro (letras, números, símbolos, emojis, etc.).\n\n\n\n\n2.3.2 Operadores Numéricos\nLos operadores son símbolos que representan una operación. Por ejemplo, el operador + representa la suma.\n\nPara transformar datos numéricos, emplearemos los siguientes operadores:\n\n\n\nSímbolo\nDefinición\nEjemplo\n\n\n\n\n+\nSuma\n5 + 3\n\n\n-\nResta\n5 - 3\n\n\n*\nProducto\n5 * 3\n\n\n**\nPotencia\n5 ** 2\n\n\n/\nDivisión\n5 / 3\n\n\n//\nDivisión entera\n5 // 3\n\n\n%\nMódulo o Resto\n5 % 3\n\n\n+=\nSuma abreviada\nx = 0x += 3\n\n\n-=\nResta abreviada\nx = 0x -= 3\n\n\n*=\nProducto abreviado\nx = 0x *= 3\n\n\n/=\nDivisión abreviada\nx = 0x /= 3\n\n\n//=\nDivisión entera abreviada\nx = 0x //= 3\n\n\n%=\nMódulo o Resto abreviado\nx = 0x %= 3\n\n\n\nComo pasa en matemática, para alterar cualquier precedencia (prioridad de operadores) se pueden usar paréntesis.\n\n(5 + 3) * 2\n\n16\n\n\n\n5 + (3 * 2)\n\n11\n\n\nEl orden de prioridad de ejecución para los operadores va a ser el mismo que en matemática.\n\n\n2.3.3 Operadores de Texto\nPara transformar datos de texto, emplearemos los siguientes operadores:\n\n\n\n\n\n\n\n\nSímbolo\nDefinición\nEjemplo\n\n\n\n\n+\nConcatenación\n\"Hola\" + \" \" + \"Mundo\"\n\n\n*\nRepetición\n\"Hola\" * 3\n\n\n+=\nConcatenación abreviada\nx = \"Hola\"x += \" Mundo\"\n\n\n*=\nRepetición abreviada\nx = \"Hola\"x *= 3\n\n\n[k] o [-k]\nAcceso a un caracter\n\"Hola\"[0]\"Hola\"[-1]\n\n\n[k1:k2]\nAcceso a una porción\n\"Hola\"[0:2]\"Hola\"[1:]\"Hola\"[:2]\"Hola\"[:]\n\n\n\nDe nuevo, para alterar precedencias, se deben usar ().\n\n2.3.3.1 Manipulando Strings\nSi bien esto se va a ahondar en la siguiente sesión de la materia, es importante saber que los strings, como se dijo más arriba, son un conjunto de caracteres. Pero no sólo un conjunto, sino un conjunto ordenado. Esto quiere decir que cada caracter tiene una posición dentro de la cadena, y que esa posición es importante.\n\nPor ejemplo, la cadena \"Hola\" tiene 4 caracteres: \"H\", \"o\", \"l\" y \"a\".\nLa posición de cada caracter es la siguiente:\n\n\n\nPosición\n0\n1\n2\n3\n\n\n\n\nCaracter\n“H”\n“o”\n“l”\n“a”\n\n\n\nEntonces, si queremos acceder al caracter \"H\", tenemos que usar la posición 0. Si queremos acceder al caracter \"a\", tenemos que usar la posición 3.\n\n\n\n\n\n\n\nTip\n\n\n\nPara acceder a un caracter de una cadena, usamos los corchetes ([]) y dentro de ellos la posición del caracter que queremos acceder.\n\n\n\n\nletra = \"Hola\"[0]\nprint(letra)\n\nH\n\n\nPero no sólo puedo obtener los caracteres en las posicione de la palabra, sino que puedo obtener slices o porciones de la misma, usando algo que vemos por primera vez: los rangos.\nUn rango tiene tres partes:\n[start : end : step]\n\nstart es el índice de inicio del rango. Si no se especifica, se toma el índice 0. El caracter en la posición de inicio siempre se incluye.\nend es el índice de fin del rango. Si no se especifica, se toma el índice final de la cadena. El caracter en la posición de fin nunca se incluye.\nstep es el tamaño del paso. Si no se especifica, se toma el valor 1.\n\n\nEjemplos:\n\n\n\n\n\n\n\n\n2.3.4 Input y Casteo\nCuando usamos la función input, el valor que devuelve es siempre una cadena. Esto es porque el usuario puede ingresar cualquier cosa, y no sabemos qué tipo de dato es.\n\nPor ejemplo, si le pedimos al usuario que ingrese un número, el usuario puede ingresar un número entero, un número de punto flotante, un número complejo, o incluso un texto. Entonces, el valor que devuelve input es siempre una cadena, y nosotros tenemos que transformarla al tipo de dato que necesitemos.\n\nPor ejemplo:\nedad = input(\"Indique su edad:\")\nprint(\"Su edad es:\", edad_nueva)\n\n\n\n\n\n\nImprimiendo Strings y Variables (interpolación de Cadenas)\n\n\n\nExisten muchas formas de concatenar variables con texto.\n\nUsando el operador +: \"Su edad es: \" + edad\nUsando el método fstring: f\"Su edad es: {edad}\"\nUsando el caracter ,: print(\"Su edad es:\", edad)\n\nLa forma más recomendada es la segunda, usando fstring. Pero dependerá de cada caso.\n\n\nEl problema es que, si bien nuestro código anterior funciona, no podemos operar edad como si fuese un número, porque es un string.\nEl siguiente código va a fallar:\nedad = input(\"Indique su edad:\")\nedad_nueva = edad + 1\nprint(\"Edad siguiente:\", edad_nueva)\n\n\n\nEjecución del bloque de código\n\n\nComo vemos, la consola nos arroja un error, o en términos simples decimos que “explotó”.\n\n\n\n\n\n\n¿Qué es un error?\n\n\n\nLos errores son información que nos da la consola para que podamos corregir nuestro código.\n\n\nEn este caso, nos dice que no se puede concatenar un string con un int.\n¿Por qué nos dice eso? Porque edad es un string: \"25\", y estamos tratando de sumarle 1, que es un int: 1.\n\nPara poder operar con edad como si fuese un número, tenemos que transformarla a un número. Esto se llama castear.\n\nPara castear un valor a un tipo de dato, usamos el nombre del tipo de dato, seguido de paréntesis y el valor que queremos castear.\nint(\"25\")\nDe esta forma, podemos modificar nuestro código anterior:\nedad = int(input(\"Indique su edad:\")) # Le agregamos int\nedad_nueva = edad + 1\nprint(\"Edad siguiente:\", edad_nueva)\nY obtenemos un código que funciona correctamente.\n\n\n\nEjecución del bloque de código\n\n\nDe esta forma, podemos castear a varios tipos de datos:\nnumero_entero = int(input(\"Ingrese un número\"))\npunto_flotante = float(input(\"Ingrese un número\"))\n\npunto_flotante2 = float(numero_entero)\n\nnumero_en_str = str(numero_entero)\nEjemplo:\nnombre_menor = input('Ingresá el nombre de un conocido/a:')\nedad_menor = int(input(f'Ingresá la edad de { nombre_menor } '))\nnombre_mayor = input(f'Cómo se llama el hermano/a mayor de {nombre_menor}? ')\ndiferencia = int(input(f'Cuántos años más grande es {nombre_mayor}?  '))\n\nedad_mayor = edad_menor + diferencia\n\nprint(nombre_menor,'tiene',edad_menor,'años')\nprint(nombre_mayor,'es mayor y tiene', edad_mayor, 'años')\n\n\n\nEjecución del bloque de código",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tipos de Datos, Expresiones y Funciones</span>"
    ]
  },
  {
    "objectID": "unidad_2.html#bonus-track-algunas-funciones-predefinidas-de-python",
    "href": "unidad_2.html#bonus-track-algunas-funciones-predefinidas-de-python",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "2.4 Bonus Track: Algunas Funciones Predefinidas de Python",
    "text": "2.4 Bonus Track: Algunas Funciones Predefinidas de Python\n\n\n\n\n\n\nRecomendación\n\n\n\nTe recomendamos que te animes a probar estas funciones, para ver qué hacen y terminar de entenderlas.\n\n\n\n\n\n\n\n\n\n\nFunción\nDefinición\nEjemplo de uso\n\n\n\n\nprint()\nImprime un mensaje o valor en la consola\nprint(\"Hello, world!\")\n\n\ninput()\nLee una entrada de texto desde el usuario\nname = input(\"Enter your name: \")\n\n\nabs()\nDevuelve el valor absoluto de un número\nabs(-5)\n\n\nround()\nRedondea un número al entero más cercano\nround(3.7)\n\n\nint()\nConvierte un valor en un entero\nx = int(\"5\")\n\n\nfloat()\nConvierte un valor en un número de punto flotante\ny = float(\"3.14\")\n\n\nstr()\nConvierte un valor en una cadena de texto\nmessage = str(42)\n\n\nbool()\nConvierte un valor en un booleano\nis_valid = bool(1)\n\n\nlen()\nDevuelve la longitud (número de elementos) de un objeto\nlength = len(\"Hello\")\n\n\nmax()\nDevuelve el valor máximo entre varios elementos o una secuencia\nmax(4, 9, 2)\n\n\nmin()\nDevuelve el valor mínimo entre varios elementos o una secuencia\nmin(4, 9, 2)\n\n\npow()\nCalcula la potencia de un número\nresult = pow(2, 3)\n\n\nrange()\nGenera una secuencia de números\nnumbers = range(1, 5)\n\n\ntype()\nDevuelve el tipo de un objeto\ndata_type = type(\"Hello\")\n\n\nround()\nRedondea un número a un número de decimales específico\nrounded_num = round(3.14159, 2)\n\n\nisinstance()\nVerifica si un objeto es una instancia de una clase específica\nis_instance = isinstance(5, int)\n\n\nreplace()\nReemplaza todas las apariciones de un substring por otro\ntext = \"Hello, World!\"new_text = text.replace(\"Hello\", \"Hi\")\n\n\neval(&lt;expr&gt;)\nEvalúa una expresión\neval(\"2 + 2\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Tipos de Datos, Expresiones y Funciones</span>"
    ]
  },
  {
    "objectID": "unidad_3.html",
    "href": "unidad_3.html",
    "title": "3  Estructuras de Control",
    "section": "",
    "text": "3.1 Decisiones\nNecesitamos decidir de alguna forma si nuestro número \\(x\\) es positivo (&gt;0) o no. Para resolver este problema, introducimos una nueva instrucción, llamada condicional: if.\nDonde if es una palabra reservada, &lt;expresion&gt; es una condición y &lt;cuerpo&gt; es un bloque de código que se ejecuta sólo si la condición es verdadera.\nPor lo tanto, antes de seguir explicando sobre la instrucción if, debemos entender qué es una condición. Estas expresiones tendrán valores del tipo sí o no.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructuras de Control</span>"
    ]
  },
  {
    "objectID": "unidad_3.html#decisiones",
    "href": "unidad_3.html#decisiones",
    "title": "3  Estructuras de Control",
    "section": "",
    "text": "Ejemplo Leer un número y, si el número es positivo, imprimir en pantalla “Número positivo”.\n\n\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\n\n\n\n3.1.1 Expresiones Booleanas\nLas expresiones booleanas forman parte de la lógica binomial, es decir, sólo pueden tener dos valores: True (verdadero) o False (falso). Estos valores no tienen elementos en común, por lo que no se pueden comparar entre sí. Por ejemplo, True &gt; False no tiene sentido. Y además, son complementarios: algo que no es True, es False; y algo que no es False, es True. Son las únicas dos opciones posibles.\nPython, además de los tipos numéricos como inty float, y de las cadenas de caracteres str, tiene un tipo de datos llamado bool. Este tipo de datos sólo puede tener dos valores: True o False. Por ejemplo:\nn = 3 # n es de tipo 'int' y tiene valor 3\nb = True # b es de tipo 'bool' y tiene valor True\n\n\n3.1.2 Operadores de Comparación\nLas expresiones booleanas se pueden construir usando los operadores de comparación: sirven para comparar valores entre sí, y permiten construir una pregunta en forma de código.\nPor ejemplo, si quisiéramos saber si 5 es mayor a 3, podemos construir la expresión:\n\nprint(5 &gt; 3)\n\nTrue\n\n\nComo 5 es en efecto mayor a 3, esta expresión, al ser evaluada, nos devuelve el valor True.\nSi quisiéramos saber si 5 es menor a 3, podemos construir la expresión:\n\nprint(5 &lt; 3)\n\nFalse\n\n\nComo 5 no es menor a 3, esta expresión, al ser evaluada, nos devuelve el valor False.\nLas expresiones booleanas de comparación que ofrece Python son:\n\n\n\nExpresión\nSignificado\n\n\n\n\na == b\na es igual a b\n\n\na != b\na es distinto de b\n\n\na &lt; b\na es menor que b\n\n\na &gt; b\na es mayor que b\n\n\na &lt;= b\na es menor o igual que b\n\n\na &gt;= b\na es mayor o igual que b\n\n\n\nVeamos algunos ejemplos:\n5 == 5\n\n5 != 5\n\n5 &lt; 5\n\n5 &gt;= 5\n\n5 &gt; 4\n\n5 &lt;= 4\n\n\n\n\n\n\nTip\n\n\n\nTe recomendamos fuertemente probar estas expresiones para ver qué valores devuelven. Podés hacerlo de dos formas:\n\nGuardando el resultado de la expresión en una variable, para luego imprimirla:\n\nresultado = 5 == 5\nprint(resultado)\n\nImprimiendo directamente el resultado de la expresión:\n\nprint(5 == 5)\n\n\n\n\n3.1.3 Operadores Lógicos\nAdemás de los operadores de comparación, Python también tiene operadores lógicos, que permiten combinar expresiones booleanas para construir expresiones más complejas. Por ejemplo, quizás no sólo queremos saber si 5 es mayor a 3, sino que también queremos saber si 5 es menor que 10. Para esto, podemos usar el operador and:\n5 &gt; 3 and 5 &lt; 10\nPython tiene tres operadores lógicos: and, or y not. Veamos qué hacen:\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\na and b\nEl resultado es Truesolamente si a es True y b es True. Ambos deben ser True, de lo contrario devuelve False.\n\n\na or b\nEl resultado es True si a es True o b es True (o ambos). Si ambos son False, devuelve False.\n\n\nnot a\nEl resultado es True si a es False, y viceversa.\n\n\n\nAlgunos ejemplos:\n\n5 &gt; 2 and 5 &gt; 3\n\nTrue\n\n\n\n5 &gt; 2 or 5 &gt; 3\n\nTrue\n\n\n\n5 &gt; 2 and 5 &gt; 6\n\nFalse\n\n\n\n5 &gt; 2 or 5 &gt; 6\n\nTrue\n\n\n\n5 &gt; 6\n\nFalse\n\n\n\nnot 5 &gt; 6\n\nTrue\n\n\n\n5 &gt; 2\n\nTrue\n\n\n\nnot 5 &gt; 2\n\nFalse\n\n\n\n\n\n\n\n\nPrioridad de Operadores\n\n\n\n\n\nLas expresiones lógicas complejas (con más de un operador), se resuelven al igual que en matemática: respetando precedencias y de izquierda a derecha. También admiten el uso de () para alterar las precedencias.\nSin embargo, si no tenemos precedencias explícitas con (), Python prioriza resolver primero los and, luego los or y por último los not.\nEjemplos:\n\nTrue or False and False\n\nTrue\n\n\nPor la prioridad del and, primero se resuelve False and False, que da False. Luego, se resuelve True or False, que da True.\n\nTrue or False or False\n\nTrue\n\n\nComo no hay and, se resuelve de izquierda a derecha. Primero se resuelve True or False, que da True. Luego, se resuelve True or False, que da True.\n\n(True or False) and False\n\nFalse\n\n\nComo hay paréntesis, se resuelve primero lo que está dentro de los paréntesis. True or False da True. Luego, True and False da False.\n\n\n\n\n\n3.1.4 Comparaciones Simples\nVolvamos al problema inicial: Queremos saber, dado un número \\(x\\), si es positivo o no, e imprimir un mensaje en consecuencia.\nRecordemos la instrucción if que acabamos de introducir y que sirve para tomar decisiones simples. Esta instrucción tiene la siguiente estructura:\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\ndonde:\n\n&lt;expresion&gt;debe ser una expresión lógica.\n&lt;cuerpo&gt;es un bloque de código que se ejecuta sólo si la expresión es verdadera.\n\n\n\n\nDiagrama de Flujo para la instrucción if\n\n\nComo ahora ya sabemos cómo construir condiciones de comparación, vamos a comparar si nuestro número x es mayor a 0:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n\nPodemos probarlo:\n\nimprimir_si_positivo(5)\nimprimir_si_positivo(-5)\nimprimir_si_positivo(0)\n\nNúmero positivo\n\n\nComo vemos, si el número es positivo, se imprime el mensaje. Pero si el número no es positivo, no se imprime nada. Necesitamos además agregar un mensaje “Número no positivo”, si es que la condición no se cumple.\nModifiquemos el diseño: 1. Si \\(x&gt;0\\), se imprime “Número positivo”. 2. En caso contrario, se imprime “Número no positivo”.\nPodríamos probar con el siguiente código:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  if not x &gt; 0:\n      print(\"Número no positivo\")\n\nOtra solución posible es:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  if x &lt;= 0:\n      print(\"Número no positivo\")\n\nAmbas están bien. Si lo probamos, vemos que funciona:\n\nimprimir_si_positivo(5)\nimprimir_si_positivo(-5)\nimprimir_si_positivo(0)\n\nNúmero positivo\nNúmero no positivo\nNúmero no positivo\n\n\nSin embargo, hay una mejor forma de hacer esta función. Existe una condición alternativa para la estructura de decisión if, que tiene la forma:\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nelse:\n    &lt;cuerpo&gt;\ndonde if y else son palabras reservadas. Su efecto es el siguiente:\n\nSe evalúa la &lt;expresion&gt;.\nSi la &lt;expresion&gt; es verdadera, se ejecuta el &lt;cuerpo&gt; del if.\nSi la &lt;expresion&gt; es falsa, se ejecuta el &lt;cuerpo&gt; del else.\n\n\n\n\nDiagrama de Flujo para la instrucción if-else\n\n\nPor lo tanto, podemos reescribir nuestra función de la siguiente forma:\n\ndef imprimir_si_positivo_o_no(x): # le cambiamos el nombre\n  if x &gt; 0:\n      print(\"Número positivo\")\n  else:\n      print(\"Número no positivo\")\n\nProbemos:\n\nimprimir_si_positivo_o_no(5)\nimprimir_si_positivo_o_no(-5)\nimprimir_si_positivo_o_no(0)\n\nNúmero positivo\nNúmero no positivo\nNúmero no positivo\n\n\n¡Sigue funcionando!\nLo importante a destacar es que, si la condición del if es verdadera, se ejecuta el &lt;cuerpo&gt; del if y no se ejecuta el &lt;cuerpo&gt; del else. Y viceversa: si la condición del if es falsa, se ejecuta el &lt;cuerpo&gt; del else y no se ejecuta el &lt;cuerpo&gt; del if. Nunca se ejecutan ambos casos, porque son caminos paralelos que no se cruzan, como vimos en el diagrama de flujo más arriba.\n\n\n3.1.5 Múltiples decisiones consecutivas.\nSupongamos que ahora queremos imprimir un mensaje distinto si el número es positivo, negativo o cero. Podríamos hacerlo con dos decisiones consecutivas:\n\ndef imprimir_si_positivo_negativo_o_cero(x):\n  if x &gt; 0:\n      print(\"Número positivo\") # cuerpo del primer if\n  else:\n      if x == 0:                      #\n          print(\"Número cero\")        #\n      else:                           #\n          print(\"Número negativo\")    # todo esto es el cuerpo del primer else\n\nA esto se le llama anidar, y es donde dentro de unas ramas de la decisión (en este caso, la del else), se anida una nueva decisión. Pero no es la única forma de implementarlo. Podríamos hacerlo de la siguiente forma:\n\ndef imprimir_si_positivo_negativo_o_cero(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  elif x == 0:\n      print(\"Número cero\")\n  else:\n      print(\"Número negativo\")\n\nLa estructura elif es una abreviatura de else if. Es decir, es un else que tiene una condición. Su efecto es el siguiente:\n\n\n\nDiagrama de Flujo para la instrucción if-elif-else del ejemplo\n\n\n\nSe evalúa la &lt;expresion&gt; del if.\nSi la &lt;expresion&gt; es verdadera, se ejecuta el &lt;cuerpo&gt; del if.\nSi la &lt;expresion&gt; es falsa, se evalúa la &lt;expresion&gt; del elif.\nSi la &lt;expresion&gt; del elif es verdadera, se ejecuta su &lt;cuerpo&gt;.\nSi la &lt;expresion&gt; del elif es falsa, se ejecuta el &lt;cuerpo&gt; del else.\n\n\n\n\n\n\n\nSabías que… ?\n\n\n\n\n\nEn Python se consideran verdaderos (True) también todos los valores numéricos distintos de 0, las cadenas de caracteres que no sean vacías, y cualquier valor que no sea vacío en general. Los valores nulos o vacíos son falsos.\nif x == 0:\nes equivalente a:\nif not x:\nY además, existe el valor especial None, que representa la ausencia de valor, y es considerado falso. Podemos preguntar si una variable tiene el valor None usando el operador is:\nif x is None:\no también:\nif not x:\n\n\n\n\n\n\n\n\n\nEjercicio Desafío (opcional)\n\n\n\n\n\nDebemos calcular el pago de una persona empleada en nuestra empresa. El cálculo debe hacerse por la cantidad de horas trabajadas, y se le debe pedir al usuario la cantidad de horas y cuánto vale cada hora.\nAdicionalmente, se abona un plus fijo de guardería a todo empleado/a con infantes a su cargo. Y se paga un 10% de incentivo a todo empleado/a que haya trabajado 30 horas o más y no reciba el plus por guardería.\n\nPista: pensar los distintos tipos de liquidación:\na) Empleado/a con menos de 30 horas y sin infantes a cargo.\nb) Empleado/a con 30 horas o más y sin infantes a cargo.\nc) Empleado/a con menos de 30 horas y con infantes a cargo.\nd) Empleado/a con 30 horas o más y con infantes a cargo.\n\n\n\n\n\n\nAyuda: Flujo de la resolución\n\n\n\n\n\n\n\n\nDiagrama de Flujo para el desafío",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructuras de Control</span>"
    ]
  },
  {
    "objectID": "unidad_3.html#ciclos-y-rangos",
    "href": "unidad_3.html#ciclos-y-rangos",
    "title": "3  Estructuras de Control",
    "section": "3.2 Ciclos y Rangos",
    "text": "3.2 Ciclos y Rangos\nSupongamos que en una fábrica se nos pide hacer un procedimiento para entrenar al personal nuevo. Para comenzar se nos encarga la descripción de uno muy simple: descarga de cajas de material del camión del proveedor y almacenamiento en el depósito. Así que aplicamos lo que venimos aprendiendo hasta ahora sobre algoritmos y describimos la operación para la descarga de 3 cajas:\n1 Abrir la puerta del depósito y encender luces \n\n2 Ir al garage o playón donde estacionó el camión \n3 Abrir las puertas traseras de la caja del transporte\n4 Tomar una caja con ambas manos, asegurándola para no tirarla \n5 Caminar sosteniendo la caja hasta el depósito \n6 Colocar la caja sobre el piso en el sector correspondiente\n\n7 Ir al garage o playón donde estacionó el camión\n8 Tomar OTRA caja con ambas manos, asegurándola para no tirarla \n9 Caminar sosteniendo la caja hasta el depósito \n10 Colocar la caja sobre la caja anterior \n\n11 Ir al garage o playón donde estacionó el camión\n12 Tomar OTRA caja con ambas manos, asegurándola para no tirarla \n13 Caminar sosteniendo la caja hasta el depósito \n14 Colocar la caja sobre la caja anterior\n\n15 Apagar luces y cerrar puerta del depósito \n16 Ir al garage o playón donde estacionó el camión \n17 Cerrar y trabar puertas del camión \n18 Avisar fin de descarga al transportista\nYa lo tenemos. Ahora la persona a cargo dice que en el camión suelen venir entre 5 y 15 cajas de material y pide que definas el mismo procedimiento para todos los casos posibles. Notemos que se repiten las instrucciones 2, 3, 4, 5 y 6 para cada caja ¿Qué hacemos? ¿Vamos a seguir copiando y pegando las instrucciones para cada caja? ¿Y si algún día vienen más de 15 o menos de 5? ¿Vamos a tener una lista de instrucciones distinta para cada cantidad de cajas que puedan venir? Parece ser necesario hacer algo más genérico que le facilite la vida a todos. Una nueva versión:\n1 Abrir la puerta del depósito y encender luces \n2 Ir al garage o playón donde estacionó el camión \n3 Abrir las puertas traseras de la caja del transporte \n4 Tomar una caja con ambas manos, asegurándola para no tirarla \n5 Caminar sosteniendo la caja hasta el depósito \n6 Si es la primera caja, colocarla sobre el piso en el sector correspondiente;\nsi no, apilarla sobre la anterior;\nsalvo que ya haya 3 apiladas,\nen ese caso colocarla a la derecha sobre el piso \n7 Ir al garage o playón donde estacionó el camión \n\n8 Repetir 4,5,6,7 mientras queden cajas para descargar \n\n9 Cerrar y trabar puertas del camión \n10 Avisar fin de descarga al transportista \n11 Volver a depósito \n12 Apagar luces y cerrar puerta del depósito\nEsta descripción es bastante más compacta y cubre todas las posibles cantidades de cajas en un envío (habituales y excepcionales), de modo que con una única página en el manual de procedimientos será suficiente.\nSin embargo, los algoritmos que venimos escribiendo se parecen más al primer procedimiento que al segundo. ¿Cómo podemos mejorarlos?\n\n\n\n\n\n\nCiclos\n\n\n\nEl ciclo, bucle o sentencia iterativa es una instrucción que permite ejecutar un bloque de código varias veces. En Python, existen dos tipos de ciclos: while y for.\n\n\n\n3.2.1 Ciclo for\nLa instrucción for nos indica que queremos repetir un bloque de código una cierta cantidad de veces. Por ejemplo, si queremos imprimir los números del 1 al 10, podemos hacerlo de la siguiente forma:\n\nfor i in range(1, 11):\n    print(i)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nEl ciclo for incluye una línea de inicialización y una línea de &lt;cuerpo&gt;, que puede tener una o más instrucciones. El ciclo definido es de la forma:\nfor &lt;nombre&gt; in &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nEl ciclo se dice definido porque una vez evaluada la &lt;expresion&gt;, se sabe cuántas veces se va a ejecutar el &lt;cuerpo&gt;: tantas veces como elementos tenga la &lt;expresion&gt;.\nLa expresión puede indicarse con range:\n\nrange(n) devuelve una secuencia de números desde 0 hasta n-1.\nrange(a, b) devuelve una secuencia de números desde a hasta b-1.\nrange(a, b, c) devuelve una secuencia de números desde a hasta b-1, de a c en c.\n\nSe podría decir que el range puede recibir 3 valores: range(start, end, step) o range(inicio, fin, paso), donde:\n\nstart o inicio es el valor inicial de la secuencia. Por defecto es 0.\nend o fin es el valor final de la secuencia. No se incluye en la secuencia.\nstep o paso es el incremento entre cada elemento de la secuencia. Por defecto es 1.\n\nSi le pasamos un sólo parámetro, lo toma como end.\nSi le pasamos dos, los toma como start y end.\nY si le pasamos tres, los toma como start, end y step.\n\n\n\n\n\n\nNote\n\n\n\n¿Te suena quizás a algo que ya vimos? Quizás… ¿los slices de las cadenas de caracteres?\n\n\nAdemás, la variable &lt;nombre&gt; va a ir tomando el valor de cada elemento de la &lt;expresion&gt; en cada iteración. En nuestro ejemplo de imprimir los números del 1 al 10, vemos que i toma los valores 1, 2, 3, 4, 5, 6, 7, 8, 9 y 10, en ese orden.\n\n\nEjemplo\nSe pide una función que imprima todos los números pares entre dos números dados a y b. Se considera que a y b son siempre números enteros positivos, y que a es menor que b.\n\n\ndef imprimir_pares(a, b):\n  for i in range(a, b):\n    if i % 2 == 0: # si el resto de dividir por 2 es cero, es par\n      print(i)\n\nimprimir_pares(1,15)\n\n2\n4\n6\n8\n10\n12\n14\n\n\n\n\n\nEjemplo\nSe pide una función que imprima todos los números del 1 al 10, en orden inverso.\n\n\ndef imprimir_inverso():\n  for i in range(10, 0, -1):\n      print(i)\n\nimprimir_inverso()\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\n\n\n\n3.2.1.1 Iterables\nComo dijimos más arriba, la expresión del for puede ser cualquier expresión que devuelva una secuencia de valores. A estas expresiones se las llama iterables.\nUn ciclo for también podría iterar sobre elementos de una lista (tema que vamos a ver más adelante), o sobre caracteres de una palabra. Por ejemplo:\n\nfor num in [1, 3, 7, 5, 2]:\n    print(num)\n\n1\n3\n7\n5\n2\n\n\n\nfor c in \"Hola\":\n    print(c)\n\nH\no\nl\na\n\n\n\n\n\n3.2.2 Ciclo while\nLa instrucción while nos indica que queremos repetir un bloque de código mientras se cumpla una condición. Por ejemplo, si queremos imprimir los números del 1 al 10, podemos hacerlo de la siguiente forma:\n\ni = 1\nwhile i &lt; 11:\n    print(i)\n    i += 1\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nEl ciclo while incluye una línea de inicialización y una línea de &lt;cuerpo&gt;, que puede tener una o más instrucciones. El ciclo definido es de la forma:\nwhile &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nEl ciclo se dice indefinido porque una vez evaluada la &lt;expresion&gt;, no se sabe cuántas veces se va a ejecutar el &lt;cuerpo&gt;: se ejecuta mientras la &lt;expresion&gt; sea verdadera.\nPara usar la instrucción while, tenemos cuatro aspectos para armar y afinar correctamente:\n\nCuerpo\nCondición\nEstado Previo\nPaso\n\nAntes, para la instrucción for, sólo considerábamos el cuerpo y la condición. Ahora, además, tenemos que considerar el estado previo y el paso.\nEl cuerpo es la porción de código que se repetirá mientras la condición sea verdadera.\nLa condición es la expresión booleana que se evalúa para decidir si se ejecuta el cuerpo o no.\nEl estado previo es el estado de las variables antes de ejecutar el cuerpo. En general, se refiere al estado de las variables que participan de la condición.\nEl paso es la porción de código que modifica el estado previo. En general, se refiere a la modificación de las variables que participan de la condición.\n\n\n\n\n\n\n\nWarning\n\n\n\nCon los ciclos while hay que tener mucho cuidado de no caer en un loop infinito. Esto sucede cuando la condición siempre es verdadera, y el cuerpo no modifica el estado previo. Por ejemplo:\nwhile True: # más adelante sobre el uso de `while True`\n    print(\"Hola\")\no bien:\ni = 0\nwhile i &lt; 10:\n    print(i) # el valor de i nunca cambia\n\n\n\nEjercicio\nRepetir el ejercicio 7.b de la guía 2 usando un ciclo while. Repetir usando un ciclo for. ¿Qué diferencias hay entre ambos?  \n\n\n\n3.2.3 Break, Continue y Return\nbreak y continue son dos palabras clave en Python que se utilizan en bucles (tanto for como while) para alterar el flujo de ejecución del bucle.\n\n\n\n\n\n\nWarning\n\n\n\nSi bien son parte del apunte, desrecomendamos fuertemente su uso de forma ligera: el comportamiento de un ciclo while no debería depender ni de break ni de continue. Si es que decidimos usarlos, es porque le estamos dando funcionalidad adicional al código. Por ejemplo, si estamos intentando realizar operaciones y podemos encontrarnos con un error. En ese caso, tenemos la posibilidad de ignorar el error (continuar con el bucle) o cortar la ejecución (dejar de iterar). Pero esto lo vamos a ver más adelante.\n\n\n\n3.2.3.1 Break\nLa declaración break se usa para salir inmediatamente de un bucle antes de que se complete su iteración normal. Cuando se encuentra una declaración break dentro de un bucle, el bucle for o while se detiene inmediatamente y continúa con la ejecución de las instrucciones que están después del mismo.\nPor ejemplo, supongamos que queremos encontrar al primer número múltiplo de 3 entre 10 y 30:\n\nnumero = 10\nwhile numero &lt;= 30:\n  if numero % 3 == 0:\n      print(\"El primer número múltiplo de 3 es:\", numero)\n      break\n  numero += 1\n\nEl primer número múltiplo de 3 es: 12\n\n\n\nfor numero in range(10, 31):\n  if numero % 3 == 0:\n      print(\"El primer número múltiplo de 3 es:\", numero)\n      break\n\nEl primer número múltiplo de 3 es: 12\n\n\n\n\n3.2.3.2 Continue\nLa declaración continue se usa para omitir el resto del código dentro de una iteración actual del bucle y continuar con la siguiente iteración. Cuando se encuentra una declaración continue dentro de un bucle, el bucle for o while salta a la siguiente iteración del bucle sin ejecutar las instrucciones que están después del continue.\nPor ejemplo, supongamos que queremos imprimir todos los números entre 1 y 20, excepto los múltiplos de 4:\n\nnumero = 1\nwhile numero &lt;= 20:\n  if numero % 4 == 0:\n      numero += 1\n      continue\n  print(numero)\n  numero += 1\n\n1\n2\n3\n5\n6\n7\n9\n10\n11\n13\n14\n15\n17\n18\n19\n\n\n\nfor numero in range(1, 21):\n  if numero % 4 == 0:\n      continue\n  print(numero)\n\n1\n2\n3\n5\n6\n7\n9\n10\n11\n13\n14\n15\n17\n18\n19\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotemos que tanto para el uso de break como de continue, si el código se encuentra con uno de ellos en la ejecución, no ejecuta nada posterior a ellos: en el caso de break, corta o interrumpe la ejecución del bucle; en el case de continue, saltea el resto del código de esa iteración y pasa a la siguiente, volviendo a evaluar la condición si el bucle es while. Es por esto que en el último ejemplo no necesitamos un else, sino que con sólo tener un if alcanza: si se ejecuta el cuerpo del if, nos encontramos con un continue y el resto del código no se ejecuta (el print).\n\n\n\n\n3.2.3.3 Return\nCuando estamos dentro de una función, la instrucción return nos permite devolver un valor y salir de la función. Ahora, si además estamos dentro de un ciclo, también nos permite salir del mismo sin ejecutar el resto del código.\nPor ejemplo:\n\ndef obtener_primer_par_desde(n):\n  for num in range(n, n+10):\n    print(f\"Analizando si el número {num} es par\")\n    if num % 2 == 0:\n      return num\n  return None\n\n\nobtener_primer_par_desde(9)\n\nAnalizando si el número 9 es par\nAnalizando si el número 10 es par\n\n\n10\n\n\nComo vemos, la función obtener_primer_par_desde recibe un número n, y devuelve el primer número par que encuentra a partir de n. Si no encuentra ningún número par, devuelve None.\nSi encuentra un número par, no sigue analizando el resto de los números. Usa return para salir del ciclo y devuelve el número encontrado.\n\n\n\n3.2.4 Consideraciones del While\n\n3.2.4.1 No repitas\nEs importante no ser redundantes con el código y no “hacer preguntas” que ya sabemos.\nwhile &lt;condicion&gt;:\n  &lt;cuerpo&gt;\n\n&lt;codigo cuando ya no se cumple la condición&gt;\nVeamos un ejemplo:\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\nif numero == 3:\n  print(\"El número es 3\")\nelse:\n  print(\"El número no es 3\")\nEl output va a ser siempre el mismo:\n1\n2\n3\nEl número es 3\n¿Por qué? Porque nuestra condición del while es lo que dice “mientras esto se cumpla, yo repito el bloque del código de adentro”. Nuestra condición es que numero &lt; 3. En el momento en que numero llega a 3, el bucle whiledeja de cumplir con la condición, y la ejecución se corta, se termina con el bucle.\nEs decir, el bloque\nif numero == 3:\n  print(\"El número es 3\")\nsiempre se ejecuta.\nY el bloque\nelse:\n  print(\"El número no es 3\")\nnunca se ejecuta.\nPor lo tanto, podemos reescribir el código de la siguiente forma:\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\nprint(\"El número es 3\")\n\nDe la misma forma, no tendría sentido hacer algo así:\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n  continue\n\n  if numero == 3:\n    break\n\nif numero == 3 está absolutamente de más. Si numero es 3, el bucle while no se ejecuta, por lo que nunca se va a llegar a esa línea de código. No es necesario “re-chequear” la condición del while dentro del mismo, porque asumimos que si llegamos a esa línea de código, es porque la condición se cumplió. Por lo tanto, podemos reescribir el código de la siguiente forma:\n\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n  continue\n\nAhora, el continue está de más también, porque se usa cuando nosotros queremos forzar a que el ciclo pase a la siguiente iteración. Pero en este caso, el ciclo ya va a pasar a la siguiente iteración, porque estamos en la última línea del cuerpo.\n\nEste es nuestro código final, escrito de forma correcta:\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\n\n3.2.4.2 While True\nLa instrucción while está hecha para que se ejecute mientras la condición sea verdadera. Pero, ¿qué pasa si usamos while True? Lo que pasa al usar while True es que nuestro código se vuelve más propenso al error: si no tenemos cuidado, podemos caer en un loop infinito.\n\nComo no tenemos una condición a evaluar ni modificar en cada iteración, el bucle se ejecuta infinitamente. Dependería de nosotros, como programadores, que el bucle se corte en algún momento. Es decir, dependería de que nos acordemos de poner dentro del while alguna decisión que haga que el bucle se corte. Y si por alguna razón no nos acordamos, el bucle se ejecutaría infinitamente, dejando al programa “congelado” o “colgado”, sin responder, y usando todos los recursos de la computadora.\nEn pocas palabras, podemos afirmar que el uso de while True en Python es una mala práctica de programación, y en el transcurso de la materia, pedimos evitar usarla.\n\n\n3.2.4.3 Modificando la Condición\nwhile &lt;condicion&gt;:\n  &lt;cuerpo&gt;\nLa mejor decisión que se puede tomar para el  de un bloque while es asumir que, durante toda su ejecución exceptuando la última línea, la condición se cumple. Es decir, que el cuerpo del bucle se ejecuta mientras la condición sea verdadera. Por lo tanto, si queremos modificar la condición, debemos hacerlo en la última línea del cuerpo.\nPor ejemplo, esto no es correcto:\n\n# Se deben imprimir los números 0, 1, 2\nnumero = 0\nwhile numero &lt; 3:\n  numero += 1     # actualización de la condición\n  print(numero)\n\n1\n2\n3\n\n\nComo vemos, se imprimen los números 1, 2, 3; pero no el 0. Esto es porque estamos modificando la condición ni bien empieza el bucle, y no en la última línea del cuerpo.\nLa forma correcta de hacerlo sería:\n\n# Se deben imprimir los números 0, 1, 2\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1     # actualización de la condición\n\n0\n1\n2\n\n\nDe esta forma, todo lo que se encuentre antes de la última línea del cuerpo se ejecuta mientras la condición sea verdadera. Y la última línea del cuerpo es la que modifica la condición.\nUna forma genérica, bastante común, de plantear un problema es:\n&lt;setear condición&gt;\n\nwhile &lt;condición&gt;:\n  &lt;hacer algo&gt;\n  &lt;actualizar condición/es&gt;\nDonde:\n\nsetear condición es inicializar o setear variables que necesitemos para la condicion (es opcional).\ncondiciónes ‘qué se tiene que cumplir para que yo quiera repetir cierto comportamiento’.\nhacer algo es el comportamiento repetitivo que queremos tener si la condición se cumple.\nactualizar condición implica actualizar todas las variables (una o más) relacionadas a la condición del ciclo.\n\nPor ejemplo: Queremos imprimir un número, empezando de 0, siempre que sea menor a 10.\n\ni = 0 # setear condición\n\nwhile i &lt; 10: # condicion\n  print(i) # hacer algo\n  i += 1 # actualizar condición\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir un programa que pida al usuario un número entero positivo y muestre por pantalla todos los números pares desde 1 hasta ese número.\nResolver primero usando un ciclo while y luego usando un ciclo for.\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir un programa que pida al usuario un número par. Mientras el usuario ingrese números que no cumplan con lo pedido, se lo debe volver a solicitar.\nPista: resolver usando while.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Estructuras de Control</span>"
    ]
  },
  {
    "objectID": "unidad_4.html",
    "href": "unidad_4.html",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "",
    "text": "4.1 Introducción: Secuencias\nUna secuencia es una serie de elementos ordenados que se suceden unos a otros.\nUna secuencia en Python es un grupo de elementos con una organización interna, que se alojan de manera contigua en memoria.\nLas secuencias son tipos de datos que pueden ser iterados, y que tienen un orden definido. Las secuencias más comunes son los rangos, las cadenas de caracteres, las listas y las tuplas. En este capítulo vamos a ver las características de cada una de ellas y cómo podemos manipularlas.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos de Estructuras de Datos</span>"
    ]
  },
  {
    "objectID": "unidad_4.html#rangos",
    "href": "unidad_4.html#rangos",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.2 Rangos",
    "text": "4.2 Rangos\nLos rangos ya los hemos visto antes, pero lo que no habíamos comentado es que son secuencias. Los rangos representan específicamente una secuencia de números inmutable.\nLos rangos se definen con la función range(), que recibe como parámetros el inicio, el fin y el paso. El inicio es opcional y por defecto es 0, el paso también es opcional y por defecto es 1.\n\n\n\n\n\n\nNote\n\n\n\nPara más información de los rangos, ver la unidad 3.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos de Estructuras de Datos</span>"
    ]
  },
  {
    "objectID": "unidad_4.html#cadenas-de-caracteres",
    "href": "unidad_4.html#cadenas-de-caracteres",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.3 Cadenas de Caracteres",
    "text": "4.3 Cadenas de Caracteres\nUn string es un tipo de secuencia que sólo admite caracteres como elementos. Los strings son inmutables, es decir, no se pueden modificar una vez creados.\nInternamente, cada uno de los caracteres se almacenará de forma contigua en memoria. Es por esto que podemos acceder a cada uno de los caracteres de un string a través de su índice haciendo uso de [].\n\n\n\nÍndice\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nLetra\nH\no\nl\na\n\nM\nu\nn\nd\no\n\n\n\nHasta ahora, vimos que:\n\nLas cadenas de caracteres pueden ser concatenadas con el operador +:\n\n\nsaludo = \"Hola\"\ndespedida = \"Chau\"\nprint(saludo + despedida)\n\nHolaChau\n\n\n\nLas cadenas de caracteres pueden ser sliceadas o incluso acceder a un único elemento usando []:\n\n\nsaludo = \"Hola Mundo\"\nprint(saludo[0:4])\nprint(saludo[5])\n\nHola\nM\n\n\nPodemos agregar también que:\n\nLas cadenas de caracteres pueden ser multiplicadas por un número entero (y el resultado es la concatenación de la cadena consigo misma esa cantidad de veces):\n\n\nsaludo = \"Hola\"\nprint(saludo * 3)\n\nHolaHolaHola\n\n\nAdicional a esas 3 operaciones, las cadenas de caracteres tienen una gran cantidad de métodos que nos permiten manipularlas. Veamos algunos de ellos.\n\n4.3.1 Métodos de Cadenas de Caracteres\nTodos los métodos de las cadenas de caracteres devuelven una nueva cadena de caracteres o un valor, y no modifican la cadena original (ya que las cadenas de caracteres son inmutables).\n\n4.3.1.1 Longitud de una Cadena\nSe puede averiguar la cantidad de caracteres que conforman una cadena utilizando la función predefinida len():\n\nprint(len(\"Pensamiento Computacional\"))\n\n25\n\n\nExiste también una cadena especial, la cadena vacía (ya la hemos visto antes), que es la cadena que no contiene ningún caracter entre las comillas. La longitud de la cadena vacía es 0.\n\n\n\n\n\n\nTip: Len e Índices de la Cadena\n\n\n\n\n\nEs interesante notar lo siguiente: si tenemos una cadena de caracteres de longitud n, los índices de la cadena van desde 0 hasta n-1. Esto es porque el índice n no existe, ya que el primer índice es 0 y el último es n-1.\nVeámoslo con un ejemplo: tenemos el caracter Hola.\n\n\n\nÍndice\n0\n1\n2\n3\n\n\n\n\nLetra\nH\no\nl\na\n\n\n\nLa longitud de la cadena es 4, pero el último índice es 3. Si intentamos acceder al índice 4, nos dará un error:\nsaludo = \"Hola\"\nprint(saludo[4])\nIndexError: string index out of range\nLo que nos indica el error es que el índice está fuera del rango de la cadena. Esto es porque el índice 4 no existe, ya que el último índice es 3. El largo de la cadena es 4, y el último índice disponible es 4-1=3.\n\nLos índices positivos (entre 0 y len(s) - 1) son los caracteres de la cadena del primero al último.\nLos índices negativos (entre -len(s) y -1) proveen una notación que hace más fácil indicar cuál es el último caracter de la cadena: s[-1] es el último caracter, s[-2] es el penúltimo, y así sucesivamente.\n\n\nsaludo = \"Hola\"\nprint(saludo[-1])\nprint(saludo[-2])\nprint(saludo[-3])\nprint(saludo[-4])\n\na\nl\no\nH\n\n\nAdemás, el uso de índices negativos también es válido para slices:\n\nsaludo = \"Hola\"\nprint(saludo[-3:-1])\n\nol\n\n\nAl usar índices negativos, es importante no salirse del rango de los índices permitidos.\n\n\n\n\n\n4.3.1.2 Recorriendo Cadenas de Caracteres\nDijimos que los strings son secuencias, y por lo tanto podemos iterar sobre ellos. Esto significa que podemos recorrerlos con un ciclo for:\n\nsaludo = \"Hola Mundo\"\nfor caracter in saludo:\n    print(caracter)\n\nH\no\nl\na\n \nM\nu\nn\nd\no\n\n\nSi bien esto ya lo habíamos nombrado en la sección anterior como una posibilidad, ahora sabemos por qué: todas las secuencias son iterables, y por lo tanto, podemos recorrerlas.\n\n\n4.3.1.3 Buscando Subcadenas\nEl operador in nos permite saber si una subcadena se encuentra dentro de otra cadena. En la guía de la unidad 3 te pedimos que investigues acerca del operador in y not in para el ejercicio de vocales y consonantes.\na in b es una expresión (¿qué era una expresión?, repasar de ser necesario la unidad 3) que devuelve True si a es una subcadena de b, y False en caso contrario.\n\nprint( \"Hola\" in \"Hola Mundo\")\n\nTrue\n\n\nAl ser una expresión booleana, se puede usar como condición tanto de un if como de un while:\n\nif \"Hola\" in \"Hola Mundo\":\n    print(\"Se encontró una subcadena!\")\n\nSe encontró una subcadena!\n\n\n\nEjercicio\n1. Investigar, para un string dado \\(s\\), cuál es el resultado del slice s[:]\n2. Investigar, para un string dado \\(s\\), cuál es el resultado del slice s[j:] con \\(j\\) un número entero negativo.\n\n\n\n4.3.1.4 Inmutabilidad\nLas cadenas son inmutables. Esto significa que no se pueden modificar una vez creadas. Por ejemplo, si queremos cambiar un caracter de una cadena, no podemos hacerlo:\nsaludo = \"Hola Mundo\"\nsaludo[0] = \"h\"\nTypeError: 'str' object does not support item assignment\nSi queremos realizar una modificación sobre una cadena, lo que tenemos que hacer es crear una nueva cadena con la modificación que queremos:\n\nsaludo = \"Hola Mundo\"\nsaludo = \"h\" + saludo[1:]\nprint(saludo)\n\nhola Mundo\n\n\n\n\n4.3.1.5 Otros Métodos de Cadenas de Caracteres\nLas cadenas de caracteres tienen una gran cantidad de métodos que nos permiten manipularlas. Algunos ya los vimos, como len(), in y not in. Veamos otros.\n\n\n\n\n\n\nRecomendación\n\n\n\nTe recomendamos que te animes a probar estas funciones, para ver qué hacen y terminar de entenderlas.\n\n\n\n\n\n\n\n\n\n\nMétodo\nDescripción\nEjemplo\n\n\n\n\ncount(subcadena)\nDevuelve la cantidad de veces que aparece la subcadena en la cadena\n\"Hola mundo\".count(\"o\") devuelve 2\n\n\nfind(subcadena)\nDevuelve el índice de la primera aparición de la subcadena en la cadena, o -1 si no se encuentra. Cada vez que se llama, devuelve la primer aparición. Puede recibir un parámetro adicional para buscar a partir de una posición particular.\n\"Hola mundo\".find(\"mundo\") devuelve 5.\"Hola mundo\".find(\"Hola\",6) devuelve -1.\n\n\nupper()\nDevuelve una copia de la cadena con todos los caracteres en mayúscula\n\"Hola mundo\".upper() devuelve \"HOLA MUNDO\"\n\n\nlower()\nDevuelve una copia de la cadena con todos los caracteres en minúscula\n\"Hola mundo\".lower() devuelve \"hola mundo\"\n\n\nreplace(subcadena1, subcadena2)\nDevuelve una copia de la cadena reemplazando todas las apariciones de la subcadena1 por la subcadena2\n\"Hola mundo\".replace(\"mundo\", \"amigos\") devuelve \"Hola amigos\"\n\n\nsplit()\nDevuelve una lista de subcadenas separando la cadena por los espacios en blanco\n\"Hola mundo  \".split() devuelve [\"Hola\", \"mundo\"]\n\n\nsplit(separador)\nDevuelve una lista de subcadenas separando la cadena por el separador\n\"Hola, mundo\".split(\", \") devuelve [\"Hola\", \"mundo\"]\n\n\nisdigit()\nDevuelve True si todos los caracteres de la cadena son dígitos, False en caso contrario\n\"123\".isdigit() devuelve True\n\n\nisalpha()\nDevuelve True si todos los caracteres de la cadena son letras, False en caso contrario\n\"Hola\".isalpha() devuelve True\n\n\nindex(subcadena)\nDevuelve el índice de la primera aparición de la subcadena en la cadena, o produce un error si no se encuentra\n\"Hola mundo\".index(\"mundo\") devuelve 5",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos de Estructuras de Datos</span>"
    ]
  },
  {
    "objectID": "unidad_4.html#tuplas",
    "href": "unidad_4.html#tuplas",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.4 Tuplas",
    "text": "4.4 Tuplas\nLas tuplas son una secuencia de elementos inmutable. Esto significa que no se pueden modificar una vez creadas. En Python, el tipo de dato asociado a las tuplas se llama tuple y se definen con paréntesis ():\ntupla = (1, 2, 3)\nLas tuplas pueden tener elementos de cualquier tipo, es decir, pueden ser heterogéneas. Por ejemplo, podemos tener una tupla con un número, un string y un booleano:\ntupla = (1, \"Hola\", True)\nUna tupla de un sólo elemento (unitaria) debe definirse de la siguiente manera:\ntupla = (1,)\nLa coma al final es necesaria para diferenciar una tupla de un número entre paréntesis (1).\n\nEjemplos de tuplas podrían ser:\n\nUna fecha, representada como una tupla de 3 elementos: día, mes y año: (1, 1, 2020)\nDatos de una persona: (nombre, edad, dni): (\"Carla\", 30, 12345678)\n\nIncluso es posible anidar tuplas, como por ejemplo guardar, para una persona, la fecha de nacimiento: (\"Carla\", 30, 12345678, (1, 1, 1990))\n\n4.4.1 Tuplas como Secuencias\nComo las tuplas son secuencias, al igual que las cadenas, podemos utilizar la misma notación de índices para obtener cada uno de sus elementos y, de la misma forma que las cadenas, los elementos comienzan a enumerarse en su posición desde el 0:\n\nfecha = (1, 12, 2020)\nprint(fecha[0])\n\n1\n\n\nTambién podemos usar la notación de rangos, o slices, para obtener subconjuntos de la tupla. Esto es algo típico de las secuencias:\n\nfecha = (1, 12, 2020)\nprint(fecha[0:2])\n\n(1, 12)\n\n\n\n\n4.4.2 Tuplas como Inmutables\nAl igual que con las cadenas, las componentes de las tuplas no pueden ser modificadas. Es decir, no puedo cambiar los valores de una tupla una vez creada:\nfecha = (1, 12, 2020)\nfecha[0] = 2\nTypeError: 'tuple' object does not support item assignment\n\n\n4.4.3 Longitud de una Tupla\nLa longitud de una tupla se puede obtener con la función predefinida len(), que devuelve la cantidad de elementos o componentes que tiene esa tupla:\n\nfecha = (1, 12, 2020)\nprint(len(fecha))\n\n3\n\n\nUna tupla vacía es una tupla que no tiene elementos: (). La longitud de una tupla vacía es 0.\n\nEjercicio Calcular la longitud de la tupla anidada (\"Carla\", 30, 12345678, (1, 1, 1990)). ¿Cuántos elementos tiene?\n\n\n\n4.4.4 Empaquetado y desempaquetado de tuplas\nSi a una variable se le asigna una secuencia de valores separados por comas, el valor de esa variable será la tupla formada por esos valores. Ejemplo:\n\na = 1\nb = 2\nc = 3\nd = a, b, c\n\nprint(d)\n\n(1, 2, 3)\n\n\nA esto se le llama empaquetado.\n\nDe forma similar, si se tiene una tupla de largo \\(k\\), se puede asignar cada uno de los elementos de la tupla a \\(k\\) variables distintas. Esto se llama desempaquetado.\n\nd = (1, 2, 3)\na, b, c = d\n\nprint(a)\nprint(b)\nprint(c)\n\n1\n2\n3\n\n\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nSi estamos desempaquetando una tupla de largo \\(k\\), pero lo hacemos en una cantidad de variables menor a \\(k\\), se producirá un error.\nd = (1, 2, 3)\na, b = d\nObtendremos:\nValueError: too many values to unpack\no\nValueError: not enough values to unpack",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos de Estructuras de Datos</span>"
    ]
  },
  {
    "objectID": "unidad_4.html#listas",
    "href": "unidad_4.html#listas",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.5 Listas",
    "text": "4.5 Listas\nLas listas, al igual que las tuplas, también pueden usarse para modelar datos compuestos, pero cuya cantidad y valor varían a lo largo del tiempo. Son secuencias mutables, y vienen dotadas de una variedad de operaciones muy útiles.\nLa notación para lista es una secuencia de valores entre corchetes y separados por comas.\nlista = [1, 2, 3]\n\nlista_vacia = []\n\n4.5.1 Longitud de una Lista\nLa longitud de una lista se puede obtener con la función predefinida len(), que devuelve la cantidad de elementos que tiene esa lista:\n\nlista = [1, 2, 3]\nprint(len(lista))\n\n3\n\n\n\n\n4.5.2 Listas como Secuencias\nDe la misma forma que venimos haciendo con las cadenas y las tuplas, podremos acceder a los elementos de una lista a través de su índice, slicear y recorrerla con un ciclo for.\n\nlista = [1, 2, 3]\nprint(lista[0])\n\n1\n\n\n\nlista = [\"Civil\", \"Informática\", \"Química\", \"Industrial\"]\nprint(lista[1:3])\n\n['Informática', 'Química']\n\n\n\nlista = [\"Civil\", \"Informática\", \"Química\", \"Industrial\"]\nfor elemento in lista:\n    print(elemento)\n\nCivil\nInformática\nQuímica\nIndustrial\n\n\n\n\n4.5.3 Listas como Mutables\nA diferencia de las tuplas, las listas son mutables. Esto significa que podemos modificar sus elementos una vez creadas.\n\nPara cambiar un elemento de una lista, se usa la notación de índices:\n\n\nlista = [1, 2, 3]\nlista[0] = 4\nprint(lista)\n\n[4, 2, 3]\n\n\n\nPara agregar un elemento al final de una lista, se usa el método append():\n\n\nlista = [1, 2, 3]\nlista.append(4)\nprint(lista)\n\n[1, 2, 3, 4]\n\n\n\nPara agregar un elemento en una posición específica de una lista, se usa el método insert():\n\n\nlista = [1, 2, 3]\nlista.insert(0, 4)\nprint(lista)\n\n[4, 1, 2, 3]\n\n\nEl método ingresa el número 4 en la posición 0 de la lista, y desplaza el resto de los elementos hacia la derecha.\n\nlista = [1, 2, 3]\nlista.insert(1, 3)\nprint(lista)\n\n[1, 3, 2, 3]\n\n\nEl método ingresa el número 3 en la posición 1 de la lista, y desplaza el resto de los elementos hacia la derecha.\nLas listas no controlan si se insertan elementos repetidos, por lo que si queremos exigir unicidad, debemos hacerlo mediante otras herramientas en nuestro código.\n\nPara eliminar un elemento de una lista, se usa el método remove():\n\n\nlista = [1, 2, 3]\nlista.remove(2)\nprint(lista)\n\n[1, 3]\n\n\nRemove busca el elemento 2 en la lista y lo elimina. Si el elemento no existe, se produce un error.\nSi el valor está repetido, se eliminará la primera aparición del elemento, empezando por la izquierda.\n\nlista = [1, 2, 3, 2]\nlista.remove(2)\nprint(lista)\n\n[1, 3, 2]\n\n\n\nPara quitar el último elemento de una lista, se usa el método pop():\n\n\nlista = [1, 2, 3]\nlista.pop()\nprint(lista)\n\n[1, 2]\n\n\nEl método pop() devuelve el elemento que se eliminó de la lista. Si la lista está vacía, se produce un error.\n\nlista = [1, 2, 3]\nelemento = lista.pop()\nprint(elemento)\n\n3\n\n\n\nPara quitar un elemento de una lista en una posición específica, se usa el método pop() con un índice:\n\n\nlista = [1, 2, 3]\nlista.pop(1)\nprint(lista)\n\n[1, 3]\n\n\nAl igual que antes, el método pop() devuelve el elemento que se eliminó de la lista. Si la lista está vacía, se produce un error.\n\n\n4.5.4 Referencias de Listas\n\na = [1,2,3,4]\nb = a\na.pop()\n\nprint(b)\n\n[1, 2, 3]\n\n\nSe dice que b es una referencia a a. Esto significa que b no es una copia de a, sino que es a misma. Por lo tanto, si modificamos a, también modificamos b.\nUna forma de crear una copia de una lista es usando el método copy():\n\na = [1,2,3,4]\nb = a.copy()\na.pop()\n\nprint(b)\n\n[1, 2, 3, 4]\n\n\n\n\n4.5.5 Búsqueda de Elementos en una Lista\n\nPara saber si un elemento se encuentra en una lista, se puede utilizar el operador in:\n\n\nlista = [1, 2, 3]\nprint(2 in lista)\n\nTrue\n\n\nComo vemos, el operador in es válido para todas las secuencias, incluyendo tuplas y cadenas.\n\nPara averiguar la posición de un valor dentro de una lista, usaremos el método index():\n\n\nlista = [\"a\", \"b\", \"t\", \"z\"]\nprint(lista.index(\"t\"))\n\n2\n\n\nSi el valor no se encuentra en la lista, se produce un error.\nSi el valor se encuentra repetido, se devuelve la posición de la primera aparición del elemento, empezando por la izquierda.\n\n\n4.5.6 Iterando sobre Listas\nLas listas son secuencias, y por lo tanto podemos iterar sobre ellas. Esto significa que podemos recorrerlas con un ciclo for:\n\nlista = [1, 2, 3]\nfor elemento in lista:\n    print(elemento)\n\n1\n2\n3\n\n\nEsta forma de recorrer elementos usando for es utilizable con todos los tipos de secuencias.\n\n\n4.5.7 Ordenando Listas\nNos puede interesar que los elementos de una lista estén ordenados según algún criterio. Python provee dos operaciones para obtener una lista ordenada a partir de la desordenada.\n\nsorted(s) devuelve una lista ordenada con los elementos de la secuencia s. La secuencia s no se modifica.\n\n\nlista = [3, 1, 2]\nlista_nueva = sorted(lista)\n\nprint(lista)\nprint(lista_nueva)\n\n[3, 1, 2]\n[1, 2, 3]\n\n\n\ns.sort() ordena la lista s en el lugar. Es decir, modifica la lista s y no devuelve nada.\n\n\nlista = [3, 1, 2]\nlista.sort()\n\nprint(lista)\n\n[1, 2, 3]\n\n\nTanto el método sort() como el método sorted() ordenan la lista en orden ascendente. Si queremos ordenarla en orden descendente, podemos usar el parámetro reverse:\n\nlista = [3, 1, 2]\nlista.sort(reverse=True)\nprint(lista)\n\n[3, 2, 1]\n\n\nExiste un método reverse (no disponible en todos los ambientes de codeo) que invierte la lista sin ordenarla. Una forma de reemplazarlo es usando slices, como ya vimos: lista[::-1].\n\n\n\n\n\n\n¡Cuidado con los Ordenamientos!\n\n\n\n\n\n\nTodos los elementos de la secuencia deben ser comparables entre sí. Si no lo son, se producirá un error. Por ejemplo, no se puede ordenar una lista que contenga números y strings.\nAl ordenar, las letras en minúscula no valen lo mismo que las letras en mayúscula. Si queremos ordenar “hola” y “HOLA” (por ejemplo), tenemos que compararlas convirtiendo todo a minúscula o todo a mayúscula.\nDe lo contrario, se ordena poniendo las mayúsculas primero y luego las minúsculas. Es decir, para una lista con los valores [\"hola\", \"HOLA\"], el ordenamiento será [\"HOLA\", \"hola\"].\n\n¿Existe una forma mejor de hacerlo? Sí. Usando keys de ordenamiento:\n\nlista = [\"hola\", \"HOLA\"]\nlista.sort(key=str.lower)\nprint(lista)\n\n['hola', 'HOLA']\n\n\nLo importante de momento es que sepas que existe esta forma de ordenar. A key se le puede pasar una función que se va a aplicar a cada elemento de la lista antes de ordenar. En este caso, la función str.lower convierte todo a minúscula antes de intentar ordenar.\n\n\n\n\n\n4.5.8 Listas anidadas\nLas listas también puede estar anidadas, es decir, una lista puede contener a otras listas. Por ejemplo, podemos tener una lista de listas de números:\nvalores = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nAquí \\(valores\\) es una lista que contiene 3 elementos, que a su vez son también listas. Entonces, valores[0] sería la lista [1,2,3]. Si quisiéramos, por ejemplo, acceder al número 2 de dicha lista, tendríamos que volver a acceder al índice 1 de la lista valores[0]:\n\nvalores = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nnumero = valores[0][1]\nprint(numero)\n\n2\n\n\n\n\n\n\n\n\nGeneralización\n\n\n\nEste concepto de listas anidadas se puede generalizar a cualquier secuencia anidada. Por ejemplo, una tupla de tuplas, o una lista de tuplas, o una tupla de listas, etc.\n\ntupla = ((1, 2, 3), (4, 5, 6), (7, 8, 9))\nnumero = tupla[1][2]\nprint(numero)\n\n6\n\n\n\nlista = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nnumero = lista[2][0]\nprint(numero)\n\n7\n\n\n\ntupla = ([1, 2, 3], [4, 5, 6], [7, 8, 9])\nnumero = tupla[0][1]\nprint(numero)\n\n2\n\n\nIncluso se puede reemplazar un elemento anidado por otro:\n\ntupla = ([1, 2, 3], [4, 5, 6], [7, 8, 9])\ntupla[0][1] = 10\nprint(tupla)\n\n([1, 10, 3], [4, 5, 6], [7, 8, 9])\n\n\nEsto es válido siempre y cuando el elemento a reemplazar esté dentro de una secuencia mutable. En el caso de arriba, estamos cambiando el valor de una lista, que se encuentra dentro de la tupla. La tupla no cambia: sigue teniendo 3 listas guardadas.\nSi quisiéramos editar una tupla guardada dentro de una lista, no funcionaría:\nlista = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nlista[0][1] = 10\nprint(lista)\nTypeError: 'tuple' object does not support item assignment\n\n\nLas listas anidadas suelen usarse para representar matrices. Para ello, se puede pensar que cada lista representa una fila de la matriz, y cada elemento de la lista representa un elemento de la fila. Por ejemplo, la matriz:\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}\n\\]\nse puede representar como la lista de listas:\nmatriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir una función que reciba una cantidad de filas y una cantidad de columnas y devuelva una matriz de ceros de ese tamaño.\nEjemplo: matrix(2,3) devuelve [[0, 0, 0], [0, 0, 0]]\n\n\n\n\n\nEjemplo Dada una lista de tuplas de dos elementos (precio, producto), desempaquetar la lista en dos listas separadas: una con los precios y otra con los productos.\n\n\nlista = [(100, \"Coca Cola\"), (200, \"Pepsi\"), (300, \"Sprite\")]\n\nprecios = []\nproductos = []\n\nfor precio, producto in lista: # Acá estamos desempaquetando: precio, producto\n    precios.append(precio)\n    productos.append(producto)\n\nprint(precios)\nprint(productos)\n\n[100, 200, 300]\n['Coca Cola', 'Pepsi', 'Sprite']",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos de Estructuras de Datos</span>"
    ]
  },
  {
    "objectID": "unidad_4.html#listas-y-cadenas",
    "href": "unidad_4.html#listas-y-cadenas",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.6 Listas y Cadenas",
    "text": "4.6 Listas y Cadenas\nVimos que las cadenas tienen el método split, que nos permite separar una cadena en una lista de subcadenas. Por ejemplo:\n\ncadena = \"Esta es una      cadena con    espacios   varios\"\nlista = cadena.split()\n\nprint(lista)\n\n['Esta', 'es', 'una', 'cadena', 'con', 'espacios', 'varios']\n\n\nTambién podemos hacer lo contrario: podemos unir una lista de subcadenas en una cadena usando el método join:\n\nlista = [\"Esta\", \"es\", \"una\", \"cadena\", \"con\", \"espacios\", \"varios\"]\ncadena = \" \".join(lista)\n\nprint(cadena)\n\nEsta es una cadena con espacios varios\n\n\nLa sintaxis del método join es:\n&lt;separador&gt;.join(&lt;lista&gt;)\nEl separador es el caracter que se va a usar para unir los elementos de la lista. En el ejemplo, el separador es un espacio \" \", pero puede ser cualquier caracter. La lista contiene a las subcadenas que se van a unir.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos de Estructuras de Datos</span>"
    ]
  },
  {
    "objectID": "unidad_4.html#operaciones-de-las-secuencias",
    "href": "unidad_4.html#operaciones-de-las-secuencias",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.7 Operaciones de las Secuencias",
    "text": "4.7 Operaciones de las Secuencias\nTanto las cadenas, como las tuplas y las listas son secuencias, y por lo tanto comparten una serie de operaciones que podemos realizar sobre ellas.\n\n\n\n\n\n\n\nOperación\nDescripción\n\n\n\n\nx in s\nDevuelve True si el elemento x se encuentra en la secuencia s, False en caso contrario \n\n\ns + t\nConcatena las secuencias s y t\n\n\ns * n\nRepite la secuencia s n veces\n\n\ns[i]\nDevuelve el elemento de la secuencia s en la posición i\n\n\ns[i:j:k]\nDevuelve un slice de la secuencia s desde la posición i hasta la posición j (no incluída), con pasos de a k\n\n\nlen(s)\nDevuelve la cantidad de elementos de la secuencia s\n\n\nmin(s)\nDevuelve el elemento mínimo de la secuencia s\n\n\nmax(s)\nDevuelve el elemento máximo de la secuencia s\n\n\nsum(s)\nDevuelve la suma de los elementos de la secuencia s\n\n\ncount(x)\nDevuelve la cantidad de veces que aparece el elemento x en la secuencia s\n\n\nindex(x)\nDevuelve el índice de la primera aparición del elemento x en la secuencia s\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nTe recomendamos que pruebes cada una de estas operaciones con las distintas secuencias que vimos en este capítulo.\n\n\nAdemás, es posible crear una lista o tupla a partir de cualquier otra secuencia, usando las funciones list y tuple respectivamente:\n\nlista = list(\"Hola\")\nprint(lista)\n\n['H', 'o', 'l', 'a']\n\n\n\ntupla = tuple(\"Hola\")\nprint(tupla)\n\n('H', 'o', 'l', 'a')\n\n\n\nlista = list( (1, 2, 3) ) # Convertimos una tupla en una lista\nprint(lista)\n\n[1, 2, 3]\n\n\nEsta última es particularmente útil cuando necesitamos trabajar con una tupla, pero como son inmutables, la convertimos a lista para manipularla sin problemas.\n\nEjercicio Escribir una función que le pida al usuario que ingrese números enteros positivos, los vaya agregando a una lista, y que cuando el usuario ingrese un 0, devuelva la lista de números ingresados.\n\ndef ingresar_numeros():\n    numeros = []\n    numero = int(input(\"Ingrese un número: \"))\n\n    while numero != 0:\n        numeros.append(numero)\n        numero = int(input(\"Ingrese un número: \"))\n    return numeros\n\n\n\n\n\n\nEjercicio Escribir una función que cuente la cantidad de letras que tiene una cadena de caracteres, y devuelva su valor.\nLuego, usar esa función como key para ordenar la siguiente lista: [\"Año\", \"Onomatopeya\", \"Murcielago\", \"Arañas\", \"Messi\", \"Camiseta\"].\n\n\ndef contar_letras(cadena):\n    return len(cadena)\n\nlista = [\"Año\", \"Onomatopeya\", \"Murcielago\", \"Arañas\", \"Messi\", \"Camiseta\"]\nlista.sort(key=contar_letras)\n\nprint(lista)\n\n['Año', 'Messi', 'Arañas', 'Camiseta', 'Murcielago', 'Onomatopeya']\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir una función que cuente la cantidad de vocales que tiene una cadena de caracteres, y devuelva su valor. Debe considerar mayúsculas y minúsculas. Pista: podés usar la función para saber si una letra es vocal que hiciste en la unidad 3.\nLuego, usar esa función como key para ordenar la siguiente lista: [\"Año\", \"Onomatopeya\", \"Murcielago\", \"Arañas\", \"Messi\", \"Camiseta\"].\n\n\n\n\n\n\n\n\n\n4.7.1 Map\nLa función map aplica una función a cada uno de los elementos de una secuencia, y devuelve una nueva secuencia con los resultados.\n\ndef obtener_cuadrado(x):\n  return x**2\n\nlista = [1, 2, 3, 4]\nlista_cuadrados = list(map(obtener_cuadrado, lista))\nprint(lista_cuadrados)\n\n[1, 4, 9, 16]\n\n\nLa sintaxis es:\nmap(&lt;funcion&gt;, &lt;secuencia&gt;)\nLa función map devuelve un objeto de tipo map, por lo que en general lo vamos a convertir a una lista usando list(). Sin embargo, el tipo map es iterable, por lo que podríamos recorrerlo con un ciclo for:\n\nfor n in lista_cuadrados:\n  print(n)\n\n1\n4\n9\n16\n\n\n\n\n\n\n\n\nTip\n\n\n\nLas funciones a pasar como parámetro a map devuelven valores transformados del elemento original. Lo que hace map es aplicar la función a cada uno de los elementos de la secuencia original.\n\n\n\n\n4.7.2 Filter\nLa función filter aplica una función a cada uno de los elementos de una secuencia, y devuelve una nueva secuencia con los elementos para los cuales la función devuelve True.\n\ndef es_par(x):\n  return x % 2 == 0\n\nlista = [1, 2, 3, 4]\nlista_pares = list(filter(es_par, lista))\nprint(lista_pares)\n\n[2, 4]\n\n\nLa sintaxis es:\nfilter(&lt;funcion&gt;, &lt;secuencia&gt;)\nLa función filter devuelve un objeto de tipo filter, por lo que en general lo vamos a convertir a una lista usando list(). Sin embargo, el tipo filter es iterable, por lo que podríamos recorrerlo con un ciclo for:\n\nfor n in lista_pares:\n  print(n)\n\n2\n4\n\n\n\n\n\n\n\n\nTip\n\n\n\nLas funciones a pasar como parámetro a filter devuelven valores booleanos del elemento original. Lo que hace filter es filtrar la secuencia original y quedarse sólo con los valores para los cuales la función devuelve True.\n\n\n\nEjemplo Escribir una función que reciba una lista de números y devuelva una lista con los números positivos de la lista original.\n\n\ndef es_positivo(x):\n  return x &gt; 0\n\ndef quitar_negativos_o_cero(lista):\n  return list(filter(es_positivo, lista))\n\nlista = [1, -2, 3, -4, 5, 0]\nlista_positivos = quitar_negativos_o_cero(lista)\nprint(lista_positivos)\n\n[1, 3, 5]\n\n\n\nEjemplo Escribir una función que reciba una lista de nombres y devuelva una lista con los mismos nombres pero con la primer letra en mayúscula.\n\n\ndef capitalizar_nombre(nombre):\n  return nombre.capitalize()\n\ndef capitalizar_lista(lista):\n  return list(map(capitalizar_nombre, lista))\n\nlista = [\"pilar\", \"barbie\", \"violeta\"]\nlista_capitalizada = capitalizar_lista(lista)\nprint(lista_capitalizada)\n\n['Pilar', 'Barbie', 'Violeta']\n\n\n\n\n\n\n\n\nNote\n\n\n\nTanto map como filter son aplicables a cualquiera de las secuencias vistas (rangos, cadena de caracteres, listas, tuplas).\n\n\n\n\n\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nSe está procesando una base de datos para entrenar un modelo de Machine Learning. La base de datos contiene información de personas, y cada persona está representada por una tupla de 2 elementos: nombre, edad.\nEscribir una función que reciba una lista de estas tuplas. La función debe devolver la lista ordenada por edad; y filtrada de forma que sólo queden los nombres de las personas mayores de edad (&gt;18). Además, los nombres deben estar en mayúscula.\nEjemplo:\nSi se tiene [(\"sol\", 40), (\"priscila\", 15), (\"agostina\", 30)]\nuna vez ejecutada, la función debe devolver: [(\"AGOSTINA\",30), (\"SOL\",40)]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos de Estructuras de Datos</span>"
    ]
  },
  {
    "objectID": "unidad_4.html#diccionarios",
    "href": "unidad_4.html#diccionarios",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.8 Diccionarios",
    "text": "4.8 Diccionarios\nUn diccionario es una colección de pares clave-valor. Es una estructura de datos que nos permite guardar información de forma organizada, y acceder a ella de forma eficiente. Cada clave está asociada a un valor determinado.\n\n\n\nDiccionario cuyas claves son dominios de internet (.ar, .es, .tv) y cuyos valores asociados son los países correspondientes.\n\n\nLas claves deben ser únicas, es decir, no puede haber dos claves iguales en un mismo diccionario. Los valores pueden repetirse. Si se asigna un valor a una clave ya existente, se reemplaza el valor anterior.\nPodemos acceder a un valor a través de su clave porque las claves son únicas, pero no a la inversa. Es decir, no podemos acceder a una clave a través de su valor, porque los valores pueden repetirse y podría haber varias claves asociadas al mismo valor.\nAdemás, los diccionarios no tienen un orden interno particular. Se consideran entonces iguales dos diccionarios si tienen las mismas claves asociadas a los mismos valores, independientemente del orden en que se hayan agregado.\nAl igual que las listas, los diccionarios son mutables. Esto significa que podemos modificar sus elementos una vez creados.\n\nCualquier valor de tipo inmutable puede ser clave de un diccionario: cadenas, enteros tuplas.\nNo hay restricciones para los valores, pueden ser de cualquier tipo: cadenas, enteros, tuplas, listas, otros diccionarios, etc.\n\n\n4.8.1 Diccionarios en Python\nPara definir un diccionario, se utilizan llaves {} y se separan las claves de los valores con dos puntos :. Cada par clave-valor se separa con comas ,.\n\ndominios = {\"ar\": \"Argentina\", \"es\": \"España\", \"tv\": \"Tuvalu\"}\n\nEl tipo asociado a los diccionarios es dict:\n\nprint(type(dominios))\n\n&lt;class 'dict'&gt;\n\n\nPara declararlo vacío y luego ingresar valores, se lo declara como un par de llaves vacías. Luego, haciendo uso de la notación de corchetes [], se le asigna un valor a una clave:\n\nmaterias = {}\nmaterias[\"lunes\"] = [6103, 7540]\nmaterias[\"martes\"] = [6201]\nmaterias[\"miércoles\"] = [6103, 7540]\nmaterias[\"jueves\"] = []\nmaterias[\"viernes\"] = [6201]\n\nEn el código de arriba, se está creando una variable materias de tipo dict, y se le están asignando valores a las claves \"lunes\", \"martes\", \"miércoles\", \"jueves\" y \"viernes\".\nLos valores asociados a cada clave son listas con los códigos de las materias que se dan esos días. El diccionario se ve algo así:\n{\n    \"lunes\": [6103, 7540],\n    \"martes\": [6201],\n    \"miércoles\": [6103, 7540],\n    \"jueves\": [],\n    \"viernes\": [6201]\n}\n\n\n4.8.2 Accediendo a los Valores de un Diccionario\nPara acceder a los valores de un diccionario, se utiliza la notación de corchetes [] con la clave correspondiente:\n\ncods_lunes = materias[\"lunes\"]\nprint(cods_lunes)\n\n[6103, 7540]\n\n\nVeamos que la clave “lunes” no va a ser igual a la clave “Lunes” o “LUNES”, porque como ya dijimos antes, Python es case sensitive.\n\n\n\n\n\n\n¡Cuidado! Acceso a Claves que no Existen\n\n\n\nSi intentamos acceder a una clave que no existe en el diccionario, se produce un error:\nprint(materias[\"sábado\"])\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: 'sábado'\n\n\n\nPara evitar tratar de acceder a una clave que no existe, podemos verificar si una clave se encuentra o no en el diccionario haciendo uso del operador in:\n\nif \"sábado\" in materias:\n    print(materias[\"sábado\"])\nelse:\n    print(\"No hay clases el sábado\")\n\nNo hay clases el sábado\n\n\nTambién podemos usar la función get, que recibe una clave ky un valor por omisión v, y devuelve el valor asociado a la clave k, en caso de existir, o el valor v en caso contrario.\n\nprint(materias.get(\"sábado\", \"Error de clave: sábado\"))\n\nError de clave: sábado\n\n\n\nprint(materias.get(\"domingo\",[]))\n\n[]\n\n\nComo vemos el valor por omisión puede ser de cualquier tipo.\n\n\n4.8.3 Iterando Elementos del Diccionario\n\n4.8.3.1 Por Claves\nPara iterar sobre las claves de un diccionario, podemos usar un ciclo for:\n\nfor dia in materias:\n    print(f\"El {dia} tengo que cursar las materias {materias[dia]}\")\n\nEl lunes tengo que cursar las materias [6103, 7540]\nEl martes tengo que cursar las materias [6201]\nEl miércoles tengo que cursar las materias [6103, 7540]\nEl jueves tengo que cursar las materias []\nEl viernes tengo que cursar las materias [6201]\n\n\nTambién podemos obtener las claves del diccionario como una lista usando el método keys():\n\nfor dia in materias.keys():\n    print(f\"El {dia} tengo que cursar las materias {materias[dia]}\")\n\nEl lunes tengo que cursar las materias [6103, 7540]\nEl martes tengo que cursar las materias [6201]\nEl miércoles tengo que cursar las materias [6103, 7540]\nEl jueves tengo que cursar las materias []\nEl viernes tengo que cursar las materias [6201]\n\n\n\n\n4.8.3.2 Por Valores\nPara iterar sobre los valores de un diccionario, podemos usar el método values():\n\nfor codigos in materias.values():\n    print(codigos)\n\n[6103, 7540]\n[6201]\n[6103, 7540]\n[]\n[6201]\n\n\nNótese que en este último ejemplo, no podemos obtener la clave a partir de los valores. Por eso no imprimimos los días.\n\n\n4.8.3.3 Por Clave-Valor\nPara iterar sobre los pares clave-valor de un diccionario, podemos usar el método items(), que nos devuelve un conjunto de tuplas donde el primer elemento de cada una es una clave y el segundo, su valor asociado (clave,valor):\n\nfor tupla in materias.items():\n  dia = tupla[0]\n  codigos = tupla[1]\n  print(f\"El {dia} tengo que cursar las materias {codigos}\")\n\nEl lunes tengo que cursar las materias [6103, 7540]\nEl martes tengo que cursar las materias [6201]\nEl miércoles tengo que cursar las materias [6103, 7540]\nEl jueves tengo que cursar las materias []\nEl viernes tengo que cursar las materias [6201]\n\n\nTambién podemos desempaquetar las tuplas como vimos previamente:\n\nfor dia, codigos in materias.items():\n  print(f\"El {dia} tengo que cursar las materias {codigos}\")\n\nEl lunes tengo que cursar las materias [6103, 7540]\nEl martes tengo que cursar las materias [6201]\nEl miércoles tengo que cursar las materias [6103, 7540]\nEl jueves tengo que cursar las materias []\nEl viernes tengo que cursar las materias [6201]\n\n\n\n\n\n\n\n\nNote\n\n\n\nComo los diccionarios no son secuencias, no tienen orden interno específico, por lo que no podemos obtener porciones de un diccionario usando slices o [:] como hacíamos con otras estructuras de datos.\n\n\n\n\n\n\n\n\nAcerca de la Iteración de un Diccionario\n\n\n\nEl mayor beneficio de los diccionarios es que podemos acceder a sus valores de forma eficiente, a través de sus claves.\nSi la única funcionalidad que necesitamos de un diccionario es iterarlo, entonces no estamos aprovechando su potencial. En ese caso, es preferible usar una o más listas o tuplas, que es más simple y más eficiente.\nIterar un diccionario es una funcionalidad adicional que nos brinda Python, pero no es su principal uso.\n\n\n\n\n\n4.8.4 Usos de un Diccionario\nLos diccionarios son muy versátiles. Se puede utilizar un diccionario para, por ejemplo, contar cuántas apariciones de cada palabra hay en un texto, o cuántas apariciones por cada letra.\nTambién se puede usar un diccionario para tener una agenda de contactos, donde la clave es el nombre de la persona y el valor el número de teléfono.\n\n\n\n\n\n\nHashmaps: Dato interesante\n\n\n\n\n\nLos diccionarios de Python son implementados usando una estructura de datos llamada hashmap.\nPara cada clave, se le calcula un valor numérico llamado hash, que es el que se usa para acceder al valor asociado a esa clave.\nCuando se recibe una clave, se le calcula su hash y se busca en el diccionario el valor asociado a ese hash.\n\n\n\n\n\n\n4.8.5 Operaciones de los Diccionarios\n\n\n\n\n\n\n\nOperación\nDescripción\n\n\n\n\nd[k]\nDevuelve el valor asociado a la clave k\n\n\nd[k] = v\nAsigna el valor v a la clave k. Si la clave no existe, la agrega al diccionario. Si ya existe, le actualiza el valor asociado.\n\n\ndel d[k]\nElimina la clave k y su valor asociado del diccionario d\n\n\nk in d\nDevuelve True si la clave k se encuentra en el diccionario d, False en caso contrario\n\n\nlen(d)\nDevuelve la cantidad de pares clave-valor del diccionario d\n\n\nd.keys()\nDevuelve una lista con las claves del diccionario d\n\n\nd.values()\nDevuelve una lista con los valores del diccionario d\n\n\nd.items()\nDevuelve una lista de tuplas con los pares clave-valor del diccionario d\n\n\nd.copy()\nDevuelve una copia del diccionario d\n\n\nd.pop(k)\nElimina la clave k y su valor asociado del diccionario d, y devuelve el valor asociado\n\n\nd.get(k, v)\nDevuelve el valor asociado a la clave k si la clave existe, o el valor v en caso contrario\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nExisten más métodos de diccionarios, pero estos son los más utilizados y los que vamos a ver en la materia. Recomendamos que pruebes cada uno de ellos con los diccionarios que vimos en este capítulo.\n\n\n\n\n4.8.6 Diccionarios y Funciones\nLos diccionarios son mutables, por lo que podemos pasarlos como parámetros a funciones y modificarlos dentro de la función.\n\ndef agregar_alumno(alumnos, nombre, legajo):\n  alumnos[nombre] = legajo\n\nalumnos = {}\nagregar_alumno(alumnos, \"Juan\", 1234)\nagregar_alumno(alumnos, \"María\", 5678)\nprint(alumnos)\n\n{'Juan': 1234, 'María': 5678}\n\n\n\n\n4.8.7 Ordenamiento de Diccionarios\nTenemos algunas operaciones que nos permiten ordenar un diccionario:\n\n\n\n\n\n\n\nOperación\nDescripción\n\n\n\n\ndict()\nCrea un diccionario vacío\n\n\nsorted(d)\nDevuelve una lista ordenada con las claves del diccionario d\n\n\ndict(sorted(d.items()))\nDevuelve un diccionario ordenado con las claves del diccionario d\n\n\n\nSi lo que necesitamos es ordenar diccionarios entre sí (por ejemplo, teniendo una lista de diccionarios), vamos a usar el parámetro key de la función sorted:\n\ndef obtener_nombre(alumno):\n  return alumno[\"nombre\"]\n\nalumnos = [\n  {\"nombre\": \"Priscila\", \"legajo\": 1234},\n  {\"nombre\": \"Iara\", \"legajo\": 5678},\n  {\"nombre\": \"Agostina\", \"legajo\": 9012}\n]\nalumnos_ordenados = sorted(alumnos, key=obtener_nombre)\nprint(alumnos_ordenados)\n\n[{'nombre': 'Agostina', 'legajo': 9012}, {'nombre': 'Iara', 'legajo': 5678}, {'nombre': 'Priscila', 'legajo': 1234}]\n\n\n\n\n\n\n\n\nNote\n\n\n\nEn el ejemplo de arriba, estamos ordenando una lista de diccionarios por el valor de la clave \"nombre\".\nEl parámetro key recibe una función que se va a aplicar a cada elemento de la lista antes de ordenar. En este caso, la función obtener_nombre devuelve el valor de la clave \"nombre\" de cada diccionario, y es lo que se usa para ordenar.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Tipos de Estructuras de Datos</span>"
    ]
  },
  {
    "objectID": "unidad_5.html",
    "href": "unidad_5.html",
    "title": "5  Entrada y Salida",
    "section": "",
    "text": "5.1 Archivos\nCuando un programa se está ejecutando los datos están en la memoria, pero cuando el programa termina los datos se pierden.\nPara almacenar los datos de forma permanente se hace uso de archivos. Cada archivo se identifica con un nombre único dentro de directorio o carpeta en que se encuentre. Por ejemplo dentro la carpeta Documentos puede existir solo un archivo con el nombre Apuntes.txt.\nLos archivos se utilizan para organizar los datos e intercambiarlos para distintos fines. El modo de trabajar con archivos es como trabajar con libros, se pueden abrir, leer, escribir y cerrar. Además se puede leer en orden o secuencialmente o yendo a un lugar específico.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Entrada y Salida</span>"
    ]
  },
  {
    "objectID": "unidad_5.html#archivos",
    "href": "unidad_5.html#archivos",
    "title": "5  Entrada y Salida",
    "section": "",
    "text": "Note\n\n\n\nToda la organización de las computadoras está basada en archivos y directorios.\n\n\n\n5.1.1 Abriendo un Archivo\nEn python para abrir un archivo utilizamos la función open\nruta_archivo = \"alumnos.txt\"\narchivo = open(ruta_archivo)\nEsta función intentara abrir el archivo “alumnos.txt” y si tiene éxito en la variable archivo quedara un tipo de dato que nos á manipularlo.\n\n\n5.1.2 Leyendo un Archivo\nLa operación más frecuente con los archivos es leerlos de forma secuencial\narchivo = open(ruta_archivo)\nlínea = archivo.readline()\n\nwhile línea != '':\n  # hacer algo con la línea\n  línea = archivo.readline()\n\narchivo.close()\nEste último bloque de código lee todas las líneas (renglones) del archivo hasta que no queden más.\nLa variable archivo, que mencionamos más arriba como un “tipo de dato que nos permitirá manipularlo” guarda cuál es la siguiente posición que debe leer y cuando se ejecuta archivo.readline() lee esa posición y avanza una posición más.\nLa función close() cierra el archivo, esta operación es importante para mantener la consistencia de la información. Volveremos más adelante sobre este tema.\n\nEjemplo “alumnos.txt”\n\nDNI;Nombre;Nota\n45000001;Mariana Szischik;9\n46000001;Emilia Duzac;8\n46000001;Lucia Capon;9\nEn el ejemplo anterior leímos el archivo línea por línea, pero existe otra forma de leer un archivo. Veamos otro ejemplo.\narchivo = open(ruta_archivo)\nlíneas = archivo.readlines()\narchivo.close()\n\nfor línea in líneas:\n  # hacer algo con la línea\n  print(línea)\nlínea número 0 \nlínea número 1 \nlínea número 2 \nlínea número 3 \nlínea número 4 \n¿Que diferencias hay entre el ejemplo de más arriba y éste?\nLa diferencia principal y que condiciona el resto de los cambios es que en lugar de leer línea por línea utilizamos la función readlines(). Esta función lee todo el contenido del archivo y devuelve una lista donde cada elemento de la lista es un renglón. Por otro lado se llama a la función close() inmediatamente después de leer todo el archivo. ¿Por qué? ¿Te animás a analizar todas las diferencias?\n\n5.1.2.1 Resumen\n\nread(): Lee todo el archivo y lo devuelve como una cadena de texto.\nreadline(): Lee una línea del archivo y la devuelve como una cadena de texto. Cuando se llega al final del archivo, devuelve una cadena vacía.\nreadlines(): Lee todas las líneas del archivo y las devuelve como una lista de cadenas de texto.\n\n\n\n\n5.1.3 Escribiendo en un archivo\nPython también tiene métodos para escribir archivos, los más comunes son:\n\nwrite(): Escribe una cadena de texto en el archivo.\nwritelines(): Escribe una lista de cadenas de texto en el archivo.\n\nruta_archivo_nuevo = \"saludo.txt\"\narchivo = open(ruta_archivo_nuevo, 'w')\n\narchivo.write(\"Hola!\\n\")\narchivo.writelines([\"¿Cómo estás?\\n\", \"Espero que bien.\\n\"])\narchivo.close()\n\n\n\n\n\n\nTip\n\n\n\nEn este ejemplo se puede ver el uso de \\n. Este caracter es lo que indica a los medios de salida de información que lo que se escribió finaliza con una nueva línea. Ninguno de los métodos de escritura agrega automáticamente un salto de línea al final de lo que se escribe, a menos que se lo indiquemos explícitamente.\nCuando leemos un archivo tenemos que tener en cuenta que el último caracter de cada línea va a ser \\n\n\n\nPero no todos los archivos pueden ser escritos, por ejemplo los archivos que se encuentran en modo lectura (‘r’). ¿De qué depende? Depende del tipo de acceso con el que se abrió el archivo.\n\n\n5.1.4 Tipos de acceso\nCuando se abre un archivo hay que especificar para qué lo estamos abriendo, las opciones en general son: leer o escribir. Por defecto, si no especificamos nada, tal como vimos en los ejemplos anteriores, se abre para leer.\n\n\n\nResumen de los tipos de acceso con los que se puede abrir un archivo.\n\n\nVeamos ejemplos de los casos más comunes\n\nEjemplo Write (w)\n\nruta_archivo_nuevo = \"alumnos_nuevo.txt\"\narchivo = open(ruta_archivo_nuevo, 'w')\n\nfor x in range(5):\n  # hacer algo con la línea\n  archivo.write(f\"línea número {x} \\n\")\n\narchivo.close()\n\nEjemplo Read (r)\n\narchivo = open(ruta_archivo_nuevo, 'r')\nlíneas = archivo.readlines()\narchivo.close()\n\nfor línea in líneas:\n  # hacer algo con la línea\n  print(línea)\n\nEjemplo Append (a)\n\narchivo = open(ruta_archivo_nuevo, 'a')\narchivo.write(\"línea número 5 \\n\") # agrega una nueva línea al final del archivo\narchivo.close()\n\n\n5.1.5 Close\nAl terminar de trabajar con un archivo, es importante cerrarlo, por diversos motivos: en algunos sistemas los archivos sólo pueden ser abiertos de a un programa por la vez; en otros, lo que se haya escrito no se guardará realmente hasta no cerrar el archivo.\narchivo = open(ruta_archivo)\nlíneas = archivo.readlines()\narchivo.close()\n\n\n\n\n\n\nWarning\n\n\n\nCuando abrimos un archivo, queremos dejarlo abierto siempre la menor cantidad de tiempo posible. Si abrimos un archivo y no lo cerramos, estamos ocupando recursos del sistema que podrían ser utilizados por otros programas. Por lo que tenemos que pensar muy bien la forma de armar nuestro código para que los archivos se abran y cierren sólo cuando los necesitamos usar.\n\n\nUna forma de asegurarse de que un archivo se cierre es utilizar la sentencia with. Esta sentencia se encarga de cerrar el archivo automáticamente al finalizar el bloque de código que se le pasa.\nwith open(ruta_archivo) as archivo:\n  líneas = archivo.readlines()\n\n# Acá el archivo ya se cerró sólo\n\n\n\n\n\n\nTip\n\n\n\n¿Te animás a probar que pasa si intentas escribir en un archivo que fue abierto para lectura (‘r’) y a leer en uno que fue abierto para escritura (‘w’)?\n\n\n\n\n5.1.6 Ejemplos\nVeamos un ejemplo en el que trabajaremos con dos archivos.\n\nEjemplo Obtener el promedio de un archivo de notas recibido por parámetro y guardarlo en un nuevo archivo llamado “promedio.txt”\n\nEjemplo de notas.txt:\n4\n7\n10\n5\n# Abrimos el archivo de notas\ndef calcular_guardar_promedio(ruta_notas): # La función puede recibir \"notas.txt\"\n  archivo = open(ruta_notas, 'r')\n  líneas = archivo.readlines()\n  archivo.close()\n\n  # Leemos línea por línea cada nota \n  suma_notas = 0\n  cantidad_notas = 0\n  for línea in líneas[1:]: # la primer línea no contiene datos, solo los nombres de los campos\n    nota = línea.split(\";\")[2].strip('\\n') # nos quedamos con la nota\n    suma_notas += int(nota)\n    cantidad_notas += 1\n\n  # Guardamos el promedio en un nuevo archivo\n  ruta_archivo_promedios = \"promedio.txt\"\n  archivo = open(ruta_archivo_promedios, 'w')\n  archivo.write(str(suma_notas/cantidad_notas))\n  archivo.close()\nOtra forma de resolverlo podría haber sido:\n# Abrimos el archivo de notas\ndef calcular_guardar_promedio(ruta_notas): # La función puede recibir \"notas.txt\"\n  archivo = open(ruta_notas, 'r')\n  líneas = archivo.readlines()\n  archivo.close()\n\n  # Leemos línea por línea cada nota \n  notas = []\n  for línea in líneas[1:]: # la primer línea no contiene datos, solo los nombres de los campos\n    nota = línea.split(\";\")[2].strip('\\n') # nos quedamos con la nota\n    notas.append(int(nota))\n\n  # Guardamos el promedio en un nuevo archivo\n  ruta_archivo_promedios = \"promedio.txt\"\n  archivo = open(ruta_archivo_promedios, 'w')\n  archivo.write(str(sum(notas)/len(notas)))\n  archivo.close()\nVeamos el contenido del archivo “promedio.txt”\nruta_archivo = \"promedio.txt\"\narchivo = open(ruta_archivo, 'r')\nlínea = archivo.readline() # o read\narchivo.close()\nprint(línea)\n6.5\nEn el ejemplo anterior hay al menos dos cosas que vale la pena remarcar: el uso de la función split()1 nos permite separar cada línea en una lista que tiene 3 elementos, a nosotros nos interesa el elemento que está en la posición 2, la nota; por otro lado también utilizamos la función strip()2, esto remueve el caracter de nueva línea \\n y nos permite leer la nota como un número.\nUn detalle que no hay que evadir cómo se recorre la lista teniendo en cuenta que la primer línea del archivo no nos interesa, ya que contiene los nombres de cada campo. Esto se explica en unidad 4.\n\n\n5.1.7 Tipos de archivos\nEn la sección anterior utilizamos para todos los archivos la extensión ‘.txt’ el uso de extensiónes es una convención, una manera de nombrar las cosas que nos da una idea de lo que hay en el contenido del archivo.\nComúnmente a los archivos que estuvimos usando como ejemplo se los nombra con la extensión ‘.csv’ las siglas de “comma separated values”3.\n\n\n5.1.8 Conclusiones\n\nPara utilizar un archivo desde un programa, es necesario abrirlo, y cuando ya no se lo necesite, se lo debe cerrar.\nLas instrucciones más básicas para manejar un archivo son leer y escribir.\nLos archivos de texto se procesan generalmente línea por línea y sirven para intercambiar información entre diversos programas o entre programas y humanos.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Entrada y Salida</span>"
    ]
  },
  {
    "objectID": "unidad_5.html#colab-y-archivos",
    "href": "unidad_5.html#colab-y-archivos",
    "title": "5  Entrada y Salida",
    "section": "5.2 Colab y Archivos",
    "text": "5.2 Colab y Archivos\nPara usar y crear archivos en Colab, se debe ingresar al último item del menú derecho, que tiene forma de carpeta.\n\n\n\nMenu Derecho\n\n\nAllí, con el menú interno de archivos vamos a poder:\n\nSubir un archivo que tengamos en la computadora / celular\nRefrescar los archivos para ver el contenido actualizado\nSubir un archivo desde Drive\nVer archivos ocultos (no vamos a usar esto)\n\n\n\n\nMenú Archivos\n\n\nTambién podemos crear un nuevo archivo usando el menú de “sample_data” (los tres puntitos) y seleccionando “Nuevo Archivo”.\n\n\n\nNuevo archivo en sample data\n\n\nEl archivo luego hay que arrastrarlo fuera de la carpeta de sample data para poder usar como ruta su nombre directamente.\n\nDe esta forma, podemos abrirlo usando como ruta su nombre: open(\"archivo_nuevo\").\nSi hacemos doble clic en el archivo, podemos verlo. Si además el archivo es del tipo txt, podemos editarlo. Los archivos CSV no pueden editarse, pero un truco sería cambiarle la extensión a txt, editarlo, y luego volver a cambiarle la extensión a CSV. No es lo ideal, pero nos permite realizar cambios manuales en un archivo para poder trabajar con mayor comodidad.\n\n\n\n\n\n\nWarning\n\n\n\n¡Los archivos creados en Colab no se guardan para siempre!\nTe recomendamos que si los vas a necesitar o vas a querer trabajar con ellos en un futuro, los descargues. Lo podés haciendo con clic derecho sobre el archivo, o con el menú del mismo (los tres puntitos).\n\n\nCon estos tips, ya podrías manejarte correctamente para hacer la guía de archivos en Colab.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Entrada y Salida</span>"
    ]
  },
  {
    "objectID": "unidad_5.html#manejo-de-errores",
    "href": "unidad_5.html#manejo-de-errores",
    "title": "5  Entrada y Salida",
    "section": "5.3 Manejo de errores",
    "text": "5.3 Manejo de errores\nCuando cometemos un error de tipeo o utilizamos mal una sentencia el intérprete nos muestra un error de sintaxis. En la práctica lo vemos como un SintaxisError, este tipo de errores se los llama errores sintácticos, la manera de resolverlo es revisar la sintaxis y corregirlo.\nEjemplo: Función mal definida\ndeff incrementar(n):\n  return n + 1\n File ...., line 1\n    deff incrementar(n):\n         ^^^^^^^^^^^\nSyntaxError: invalid syntax\nCuando un programa se está ejecutando y ocurre un error se crea una excepción, normalmente el programa detiene su ejecución y se imprime un mensaje. Este tipo de errores se los llama errores de ejecución, vamos a ver como manejarlos.\nEjemplo: División por cero\ndividendo = 10\ndivisor = 0\nresultado = dividendo/divisor \n---------------------------------------------------------------------------\nZeroDivisionError                         Traceback (most recent call last)\nFile ...\n      1 dividendo = 10\n      2 divisor = 0\n----&gt; 3 resultado = dividendo/divisor \nZeroDivisionError: division by zero\nEjemplo: Acceso a un elemento que no existe\nlista = [\"a\",\"b\"]\nsegundo_elemento = lista[2]\n---------------------------------------------------------------------------\nIndexError                                Traceback (most recent call last)\nFile /...\n      1 lista = [\"a\",\"b\"]\n----&gt; 2 segundo_elemento = lista[2]\nIndexError: list index out of range\nEjemplo: Abrir un archivo que no existe\narchivo = open(\"archivo_falso.txt\",\"r\")\nFileNotFoundError                         Traceback (most recent call last)\nFile ...\n----&gt; 1 archivo = open(\"archivo_falso.txt\",\"r\")\nFileNotFoundError: [Errno 2] No such file or directory: 'archivo_falso.txt'\nEn cada caso el mensaje de error tiene dos partes, la primera indica el tipo de error:\n\nZeroDivisionError\nIndexError\nFileNotFoundError\n\nLa segunda tiene una descripción:\n\ndivision by zero\nlist index out of range\nNo such file or directory\n\nAdemás nos da información contextual que puede indicar en la ejecución de qué línea se dio el error:\n\nlínea 3: ----&gt; 3 resultado = dividendo/divisor.\nlínea 2: ----&gt; 2 segundo_elemento = lista[2].\nlínea 1: ----&gt; 1 archivo = open(\"archivo_falso.txt\",\"r\").\n\nEn algunas ocasiones es parte del programa manejar operaciones que puedan lanzar este tipo de excepciones sin que el programa detenga su ejecución, para estos casos Python nos provee las sentencias tryy except.\nEjemplo\ndividendo = 10\ndivisor = 0\ntry:\n  resultado = dividendo/divisor \nexcept ZeroDivisionError:\n  print(\"No se puede dividir por cero.\")\nNo se puede dividir por cero.\nComo se ve en el ejemplo se “envuelve” la operación que puede generar ese tipo de excepción para que lo que resulte de esa operación se pueda controlar. Como vimos más arriba hay distintos tipos de excepciones, la lista completa se puede ver en excepciones.\n\n\n\n\n\n\nTip\n\n\n\nEs extremadamente importante que el bloque try sólo tenga dentro la porción de código que tiene posibilidad de romper. No es correcto colocar todo nuestro código dentro del try, porque si tenemos varios posibles puntos de falla, deberían tratarse por separado. Adicionalmente, es una mala práctica tener demasiado código dentro de un bloque try, cuando es innecesario.\n\n\n\n5.3.1 Validaciones\nLas validaciones son técnicas que permiten asegurar que los valores con los que se vaya a operar estén dentro de determinado conjunto de posibilidades o que tengan ciertas características.\nSi bien quien invoca una función debe preocuparse de cumplir con las precondiciones de ésta, si las validaciones están hechas correctamente pueden devolver información valiosa para que el invocante pueda actuar en consecuencia.\nTambién se debe tener en cuenta qué hará nuestro código cuando una validación falle, ya que queremos darle información al invocante que le sirva para procesar el error. El error producido tiene que ser fácilmente reconocible.\nEjemplo:\n\ndef convertir_a_int(ingreso_usuario):\n  try:\n    return int(ingreso_usuario)\n  except ValueError:\n    print(\"El valor ingresado no es un número\")\n\nconvertir_a_int(\"cuarenta\")\n\nEl valor ingresado no es un número\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nEn Python también tenemos una forma de arrojar nosotros un error, es decir, hacer que la función falle y devuelva un mensaje de error. Esto se hace con la sentencia raise. No lo vemos en la materia, pero se puede leer más en la documentación de Python.\nArrojar o levantar excepciones es un tema complejo, porque además de arrojarlas, debemos ser capaces de capturarlas y manejarlas. Es por esto que no se incluye en el temario de la materia.\n\n\n\n\n\n\n5.3.2 Varias Excepciones\nUna misma línea podría arrojar varios tipos de excepciones distintos. Existe una forma de atajar varios casos de error sobre un mismo try, pero no lo vemos en la materia. Cada par try-except debería hacer referencia a un sólo tipo de error.\n\n\n5.3.3 Conclusiones\n\nEl manejo de errores es un parte fundamental en el desarrollo de software, tan importante como la funciónalidad que se está programando.\nLos errores que se dan en tiempo de ejecución los podemos “atrapar” con el bloque try.\nHay tipos de excepciones que describen distintos tipos de errores de ejecución.\n\n\n\n5.3.4 Bonus Track: Tipos de Errores\nA continuación se presenta una tabla con los errores más comunes que se pueden encontrar al programar en Python.\n\n\n\n\n\n\n\n\nTipo de error\nDescripción\nMás Información\n\n\n\n\nSyntaxError\nError de sintaxis\nSuele ser un error de tipeo o de uso incorrecto de una sentencia\n\n\nZeroDivisionError\nDivisión por cero\nSe produce cuando se intenta dividir por cero\n\n\nNameError\nVariable no definida\nSe produce cuando se intenta utilizar una variable que no fue definida\n\n\nIndexError\nÍndice fuera de rango\nSe produce cuando se intenta acceder a un elemento de una secuencia, que no existe\n\n\nFileNotFoundError\nArchivo no encontrado\nSe produce cuando se intenta abrir un archivo que no existe\n\n\nTypeError\nTipo de dato incorrecto\nSe produce cuando se intenta realizar una operación con un tipo de dato incorrecto\n\n\nValueError\nValor incorrecto\nSe produce cuando se intenta realizar una operación con un valor incorrecto\n\n\nKeyError\nClave no encontrada\nSe produce cuando se intenta acceder a un elemento de un diccionario que no existe\n\n\nIOError\nError de entrada/salida\nSe produce cuando se intenta realizar una operación de entrada/salida que no se puede realizar (por ejemplo, intentar acceder a un archivo)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Entrada y Salida</span>"
    ]
  },
  {
    "objectID": "unidad_5.html#footnotes",
    "href": "unidad_5.html#footnotes",
    "title": "5  Entrada y Salida",
    "section": "",
    "text": "Split↩︎\nStrip↩︎\nCSV↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Entrada y Salida</span>"
    ]
  },
  {
    "objectID": "unidad_6.html",
    "href": "unidad_6.html",
    "title": "6  Bibliotecas de Python",
    "section": "",
    "text": "6.1 Introducción\nPython es un lenguaje de programación muy popular, poderoso y versátil que cuenta con una amplia gama de bibliotecas que ayudan a que la programación sea más fácil y eficiente. Pero, ¿qué son las bibliotecas? Las bibliotecas son conjuntos de módulos que contienen funciones, clases y variables relacionadas, que permiten realizar tareas sin tener que escribir el código desde cero y este se puede reutilizar en múltiples programas y proyectos.\nEntre las bibliotecas disponibles se encuentran las estándares, que se incluye con cada instalación de Python, y las de código abierto creadas por la gran comunidad de desarrolladores, que constantemente genera nuevas bibliotecas y mejora las existentes. Por ello es aconsejable que, al momento de utilizarlas, se verifique si existe alguna actualización en las guías de usuario.\nAsimismo, estas bibliotecas se pueden clasificar según su aplicación y funcionalidad en: procesamiento de datos, visualización, aprendizaje automático, desarrollo web, procesamiento de lenguaje y de imágenes, entre otras. En este capítulo se analizarán tres de las bibliotecas más reconocidas y ampliamente utilizadas de Python: NumPy y Pandas para procesamiento de datos y Matplotlib, para visualización.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Bibliotecas de Python</span>"
    ]
  },
  {
    "objectID": "unidad_6.html#introducción",
    "href": "unidad_6.html#introducción",
    "title": "6  Bibliotecas de Python",
    "section": "",
    "text": "6.1.1 ¿Cómo se utilizan las bibliotecas?\nPara acceder a una biblioteca y sus funciones, se debe instalar por única vez y luego, importar cada vez que la necesitemos.\nEn la parte superior de nuestro código debemos correr import {nombre_de_biblioteca} as {nombre_corto_de_biblioteca}. El alias o nombre corto de la biblioteca se suele agregar para lograr una mayor legibilidad del código, pero no es mandatorio.\nimport numpy as np\n\n\n\n\n\n\nNote\n\n\n\n\n\nEn nuestro caso, la instalación no es necesaria, ya que vamos a utilizar Google Colab, pero en caso de usar otro IDE (como por ejemplo, Visual Studio Code), se realiza desde el símbolo del sistema (o en inglés: “Command Prompt”, o terminal o consola), corriendo: pip install –nombre_de_biblioteca o similares.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Bibliotecas de Python</span>"
    ]
  },
  {
    "objectID": "unidad_6.html#adaptaciones-para-colab",
    "href": "unidad_6.html#adaptaciones-para-colab",
    "title": "6  Bibliotecas de Python",
    "section": "6.2 Adaptaciones para Colab",
    "text": "6.2 Adaptaciones para Colab\nA partir de esta guía es probable que debamos reutilizar ciertas cosas o adaptar la forma en la que venimos trabajando. Para esto, vamos a hacer una modificación:\nSi tenemos variables o imports definidos en otra celda y no la ejecutamos, al intentar usarla nos va a dar error. Es importante entonces o correr todas las celdas, o que cada celda tenga la información necesaria para poder correrse de forma independiente. Acá vemos cómo, al querer ejecutar sólo la segunda celda, nos da error porque la variable saludo está definida en la celda anterior (que no se ejecutó).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Bibliotecas de Python</span>"
    ]
  },
  {
    "objectID": "unidad_6.html#numpy",
    "href": "unidad_6.html#numpy",
    "title": "6  Bibliotecas de Python",
    "section": "6.3 NumPy",
    "text": "6.3 NumPy\nNumPy es una biblioteca de código abierto muy utilizada en el campo de la ciencia y la ingeniería. Permite trabajar con datos numéricos, matrices multidimensionales, funciones matemáticas y estadísticas avanzadas.\nComo ya se mencionó anteriormente, para utilizarse se debe instalar e importar. Por convención, se suele importar como:\n\nimport numpy as np\n\nNumPy incorpora una estructura de datos propia llamados arrays que es similar a la lista de Python, pero puede almacenar y operar con datos de manera mucho más eficiente: el procesamiento de los arrays es hasta 50 veces más rápido. Esta diferencia de velocidad se debe, en parte, a que los arrays contienen datos homogéneos, a diferencia de las listas que pueden contener distintos tipos de datos dentro.\n\n6.3.1 Arrays\nUn array es un conjunto de elementos del mismo tipo, donde cada uno de ellos posee una posición y esta es única para cada elemento. Como dijimos arriba, en Python vimos las listas, que es lo más parecido a un Array.\nAnalicemos el siguiente ejemplo: si pensamos en una matriz, lo primero que nos viene a la mente es una tabla con valores ordenados en filas y columnas, donde una fila es la línea horizontal y una columna es la vertical. Es decir, una matriz es un conjunto de elementos que posee una posición o índice determinado por la fila y la columna, por lo que sería un array.\nEn este capítulo se trabajará principalmente con vectores y matrices, ya que consideramos que les será útil para aplicar los conocimientos de Numpy en otras materias.\n\n6.3.1.1 Creación de un Array\nUn array se crea usando la función array() a partir de listas o tuplas. Por ejemplo:\n\na = np.array([1, 2, 3])\nprint(a)\n\n[1 2 3]\n\n\nTambién, se pueden crear arrays particulares, constituidos por ceros con zeros() o por unos con ones():\n\n# Creo un array de ceros con dos elementos\na_ceros = np.zeros(2)\nprint(a_ceros)\n\n[0. 0.]\n\n\n\n# Creo un array de unos con dos elementos\na_unos = np.ones(2)\nprint(a_unos)\n\n[1. 1.]\n\n\nAdemás, se pueden crear arrays con un rango de números, utilizando arange() o linspace():\n\n# Creo un array con un rango que empieza en 2 hasta 9 y va de 2 en 2.\na_rango = np.arange(2, 9, 2)\nprint(a_rango)\n\n[2 4 6 8]\n\n\n\n# Creo un array con un rango formado por 4 números\n# que empieza en 2 hasta 10 (incluidos). \na_rango_2 = np.linspace(2, 10, num=4)\nprint(a_rango_2)\n\n[ 2.          4.66666667  7.33333333 10.        ]\n\n\nEsto es muy parecido a los rangos que ya vimos en Python, con la sutil diferencia de que el final del rango en este caso sí se incluye.\nFinalmente, para crear arrays de más dimensiones, se utilizan varias listas:\n\nmatriz = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(matriz)\n\n[[1 2 3]\n [4 5 6]]\n\n\n\n\n6.3.1.2 Atributos de un array\n\n\n6.3.1.3 Dimensión\nPara caracterizar un array es necesario conocer sus dimensiones, utilizando ndim. De esta forma, se puede confirmar que el array llamado matriz, definido anteriormente, es bidimensional:\n\n# Número de ejes o dimensiones de la matriz\nmatriz.ndim\n\n2\n\n\n\n\n6.3.1.4 Forma\nOtra característica de interés es su forma o shape: para las matrices bidimensionales, se muestra una tupla (n, m) con el número de filas n y de columnas m:\n\n# (n = filas, m = columnas)\nmatriz.shape\n\n(2, 3)\n\n\n\n\n6.3.1.5 Tamaño\nEl tamaño de un array es el número total de elementos que contiene, y se obtiene con size:\n\n# Número total de elementos de la matriz: 2 filas x 3 columnas = 6 elementos\nmatriz.size\n\n6\n\n\n\n\n6.3.1.6 Posiciones\nAl elemento de una matriz A que se encuentra en la fila i-ésima y la columna j-ésima se llama \\(a_{ij}\\). Así, para acceder a un elemento de un array se debe indicar primero la posición de la fila y luego, de la columna:\n\nprint('Elemento de la primera fila y segunda columna: ', matriz[0, 1])\n\nElemento de la primera fila y segunda columna:  2\n\n\nNótese la diferencia con las matrices (listas de listas) de Python, donde se accedía a un elemento por separado, primero a la fila y luego a la columna: matriz[0][1].\nTambién se puede elegir un rango de elementos en una fila o columna particular:\n\nprint('Los elementos de la primera fila, columnas 0 y 1: ', matriz[0, 0:2])\n\nLos elementos de la primera fila, columnas 0 y 1:  [1 2]\n\n\n\nprint('Los elementos de la segunda columna, filas 0 y 1: ', matriz[0:2, 1])\n\nLos elementos de la segunda columna, filas 0 y 1:  [2 5]\n\n\n\n\n6.3.1.7 Modificar arrays\nDe forma similar a lo aprendido con las listas de Python, se pueden modificar los arrays utilizando ciertas funciones. Para entender y aplicar las mismas, definamos un vector llamado a:\n\na = np.array([2, 1, 5, 3, 7, 4, 6, 8])\n\nprint(a)\n\n[2 1 5 3 7 4 6 8]\n\n\n\n6.3.1.7.1 Reshape\nA este vector, se le puede modificar la forma: pasando de ser (8,) a (4,2), por dar un ejemplo:\n\na_reshape = a.reshape(2, 4) # 2 filas y 4 columnas\n\nprint(a_reshape)\n\n[[2 1 5 3]\n [7 4 6 8]]\n\n\n\n\n6.3.1.7.2 Insert\nTambién, se podría insertar una fila (axis = 0) o una columna (axis = 1) en una determinada posición. Por ejemplo:\n\n# Agregar fila de cincos en posición 1:\nprint(np.insert(a_reshape, 1, 5, axis=0))\n\n[[2 1 5 3]\n [5 5 5 5]\n [7 4 6 8]]\n\n\nA la función insert(), se le debe indicar:\n\n\nEl array que se desea modificar\n\nLa posición de la fila o columna que se desea agregar\n\nLos valores a insertar. ¡Ojo con las dimensiones! Para el ejemplo anterior, a_reshape tenía 2 filas, por lo que se debe agregar una columna con 2 elementos o una fila con 4.\n\nEl eje que se agrega: una fila (axis = 0) o una columna (axis = 1)\n\n\n\n# Agregar columna de cincos en posición 1:\nprint(np.insert(a_reshape, 1, 5, axis=1))\n\n[[2 5 1 5 3]\n [7 5 4 6 8]]\n\n\nO lo que es equivalente:\n\n# Agregar columna de cincos en posición 1:\nprint(np.insert(a_reshape, 1, [5, 5], axis=1))\n\n[[2 5 1 5 3]\n [7 5 4 6 8]]\n\n\n\n\n6.3.1.7.3 Append y Delete\nTambién podríamos agregar una fila o una columna utilizando append() al final, como ocurría con las listas:\n\n# Agregar una última fila\na_modificada = np.append(a_reshape, [[1, 2, 3, 4]], axis=0)\nprint(a_modificada)\n\n[[2 1 5 3]\n [7 4 6 8]\n [1 2 3 4]]\n\n\nO eliminarlas con delete()\n\n# Eliminar la fila de la posición 2.\nprint(np.delete(a_modificada, 2, axis=0))\n\n[[2 1 5 3]\n [7 4 6 8]]\n\n\n\n\n6.3.1.7.4 Concatenate y Sort\nFinalmente, podemos concatenar arrays, como los siguientes:\n\na = np.array([2, 1, 5, 3])\nb = np.array([7, 4, 6, 8])\n\n# Concatenar a y b:\nc = np.concatenate((a, b))\nprint(c)\n\n[2 1 5 3 7 4 6 8]\n\n\nY ordenar los elementos de un array como numérico o alfabético, ascendente o descendente.\n\nprint(np.sort(c))\n\n[1 2 3 4 5 6 7 8]\n\n\n\n\n\n\n6.3.2 Operaciones aritméticas utilizando array\nComo se ha mencionado anteriormente, Numpy tiene un gran potencial para realizar operaciones, muy superior al de las listas de Python. Por ejemplo, si quisiéramos sumar dos listas de python necesitaríamos realizar un for:\n\n# Definir listas\na = [2, 1, 5, 3]\nb = [7, 4, 6, 8]\nc = []\n\n# Sumar el primer elemento de a con el primero de b, el segundo elemento de a con el segundo de b y así sucesivamente\nfor i in range(len(a)):\n  c.append(a[i] + b[i])\nprint(c)\n\n[9, 5, 11, 11]\n\n\nUtilizando las funciones de Numpy, esto ya no es más necesario:\n\n# add() para sumar elemento a elemento de a y b\nc = np.add(a, b)\nprint(c)\n\n[ 9  5 11 11]\n\n\nTambién podemos realizar otras operaciones, como la resta, multiplicación y división. Usar un arreglo dentro de una ecuación nos devuelve otro arreglo, donde cada elemento es el resultado de aplicar la operación a los elementos correspondientes de los arreglos originales.\n\nx = np.array([0,  1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\ny = 3 * x + 2\nprint(y)\n\n[ 2  5  8 11 14 17 20 23 26 29 32]\n\n\nDe esta forma, podemos realizar operaciones aritméticas con arrays de Numpy de forma muy sencilla y rápida. Antes, en Python, para realizar estas operaciones debíamos recurrir a un ciclo for o a el uso de map. Numpy se ocupa de ahorrarnos el trabajo y calcular, para cada elemento del array, el resultado.\nAdemás, tenemos operaciones básicas que vienen predefinidas por Numpy. Las vamos a ver a continuación.\n\n6.3.2.1 Operaciones básicas:\nA continuación se muestra una lista con las operaciones básicas junto con sus operadores asociados, funciones y ejemplos.\n\n\n\nOperación\nOperador\nFunción\n\n\n\n\nSuma\n+\nadd()\n\n\nResta\n-\nsubtract()\n\n\nMultiplicación\n*\nmultiply()\n\n\nDivisión\n/\ndivide()\n\n\nPotencia\n**\npower()\n\n\n\nDefinimos los vectores a y b con los que operaremos y veremos ejemplos:\n\na = np.array([1, 3, 5, 7])\nb = np.array([1, 1, 2, 2])\n\n\nSuma:\n\n\nresultado_1 = a + b\nprint(\"Suma usando +:\", resultado_1) \n\nresultado_2 = np.add(a, b)\nprint(\"Suma usando add():\", resultado_2) \n\nSuma usando +: [2 4 7 9]\nSuma usando add(): [2 4 7 9]\n\n\n\nResta:\n\n\nresultado_1 = a - b\nprint(\"Resta usando -:\", resultado_1) \n\nresultado_2 = np.subtract(a, b)\nprint(\"Resta usando subtract():\", resultado_2) \n\nResta usando -: [0 2 3 5]\nResta usando subtract(): [0 2 3 5]\n\n\n\nMultiplicación:\n\n\nresultado_1 = a * b\nprint(\"Multiplicación usando *:\", resultado_1) \n\nresultado_2 = np.multiply(a, b)\nprint(\"Multiplicación usando multiply():\", resultado_2) \n\nMultiplicación usando *: [ 1  3 10 14]\nMultiplicación usando multiply(): [ 1  3 10 14]\n\n\n\nDivisión:\n\n\nresultado_1 = a / b\nprint(\"División usando /:\", resultado_1) \n\nresultado_2 = np.divide(a, b)\nprint(\"División usando divide():\", resultado_2) \n\nDivisión usando /: [1.  3.  2.5 3.5]\nDivisión usando divide(): [1.  3.  2.5 3.5]\n\n\n\nPotencia:\n\n\nresultado_1 = a ** b\nprint(\"Potencia usando **:\", resultado_1) \n\nresultado_2 = np.power(a, b)\nprint(\"Potencia usando power():\", resultado_2) \n\nPotencia usando **: [ 1  3 25 49]\nPotencia usando power(): [ 1  3 25 49]\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote que si quisiéramos operar con un vector b de elementos iguales, podríamos utilizar un escalar.\n\n\n\nb = np.array([2, 2, 2, 2])\n\nresultado_1 = a * b\nprint(\"Usando un vector b = [2, 2, 2, 2]:\", resultado_1) \n\nresultado_2 = a * 2\nprint(\"Usando un escalar b = 2:\", resultado_2) \n\nUsando un vector b = [2, 2, 2, 2]: [ 2  6 10 14]\nUsando un escalar b = 2: [ 2  6 10 14]\n\n\n\n\n6.3.2.2 Logaritmo:\nNumPy provee funciones para los logaritmos de base 2, 10 y e:\n\n\n\nBase\nFunción\n\n\n\n\n2\nlog2()\n\n\n10\nlog10()\n\n\ne\nlog()\n\n\n\nPor ejemplo:\n\n# Ejemplo log2()\nprint(\"Logaritmo base 2:\", np.log2([2, 4, 8, 16]))\n# Ejemplo log10()\nprint(\"Logaritmo base 10:\", np.log10([10, 100, 1000, 10000]))\n# Ejemplo log()\nprint(\"Logaritmo base e:\", np.log([1, np.e, np.e**2]))\n\nLogaritmo base 2: [1. 2. 3. 4.]\nLogaritmo base 10: [1. 2. 3. 4.]\nLogaritmo base e: [0. 1. 2.]\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote que el número de Euler o número e es una constante incluida en NumPy como: np.e\n\n\n\nnp.e\n\n2.718281828459045\n\n\n\n\n\n\n\n\nFunciones trigonométricas (opcional)\n\n\n\n\n\nEsta parte del apunte es opcional, es decir, no se evalúa en los exámenes. A continuación, una lista con las funciones trigonométricas más utilizadas, que toman los valores en radianes:\n\n\n\nFunción trigonométrica\nFunción\n\n\n\n\nseno\nsin()\n\n\ncoseno\ncos()\n\n\ntangente\ntan()\n\n\narcoseno\narcsin()\n\n\narcocoseno\narccos()\n\n\narcotangente\narctan()\n\n\n\nPor ejemplo:\n\n# Ejemplo de seno\nprint(\"Seno de π / 2:\", np.sin(np.pi / 2))\n\n# Ejemplo de arcoseno\nprint(np.arcsin(1))\n\nSeno de π / 2: 1.0\n1.5707963267948966\n\n\n\n# Ejemplo de coseno\nprint(\"Coseno de π:\", np.cos(np.pi))\n\n# Ejemplo de arcocoseno\nprint(\"Arcoseno de -1:\", np.arccos(-1))\n\nCoseno de π: -1.0\nArcoseno de -1: 3.141592653589793\n\n\n\n# Ejemplo de tangente:\nprint(\"Tangente de 0:\", np.tan(0))\n\n# Ejemplo de arcotangente:\nprint(\"Arcotangente de 0:\", np.arctan(0))\n\nTangente de 0: 0.0\nArcotangente de 0: 0.0\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote que el número π es una constante incluida en NumPy como: np.pi\n\n\n\nnp.pi\n\n3.141592653589793\n\n\nPara convertir los radianes a grados y viceversa, se utiliza deg2rad() y rad2deg() respectivamente:\n\nprint(\"De grados [90, 180, 270, 360] a radianes:\", \n      np.deg2rad([90, 180, 270, 360]))\n\nprint(\"De radianes [π/2, π, 1.5*π, 2*π] a grados:\", \n      np.rad2deg([np.pi/2, np.pi, 1.5*np.pi, 2*np.pi]))\n\nDe grados [90, 180, 270, 360] a radianes: [1.57079633 3.14159265 4.71238898 6.28318531]\nDe radianes [π/2, π, 1.5*π, 2*π] a grados: [ 90. 180. 270. 360.]\n\n\n\n\n\n\n\n6.3.2.3 Operaciones con matrices:\nA continuación, una lista con las operaciones que les pueden ser de interés mientras estudian álgebra matricial:\n\n\n\n\n\n\n\n\nFunción\nDescripción\nComentario\n\n\n\n\ndot()\nProducto escalar\nSe utiliza para obtener el producto escalar entre dos vectores. El resultado es un número.\n\n\ndot()\nProducto vectorial\nTambién se utiliza para multiplicar matrices. El resultado es una matriz\n\n\ntranspose()\nTraspuesta\nCambia las filas por las columnas y viceversa\n\n\nlinalg.inv()\nInversa\nInversa de una matriz\n\n\nlinalg.det()\nDeterminante\nDeterminante de una matriz\n\n\neye()\nMatriz identidad\nMatriz cuadrada con unos en la diagonal principal y ceros en el resto\n\n\n\nDefinimos los arreglos 1 y 2, y matrices 1 y 2 con los que operaremos y veremos ejemplos:\n\n# Crear arreglos\narreglo_1 = np.array([1, 2])\narreglo_2 = np.array([3, 4])\n\n# Crear matrices\nmatriz_1 = np.array([[1, 3], [5, 7]])\nmatriz_2 = np.array([[2, 6], [4, 8]])\n\n\nprint(\"Producto escalar entre el array 1 y 2: \\n\", np.dot(arreglo_1, arreglo_2))\n\nProducto escalar entre el array 1 y 2: \n 11\n\n\n\nprint(\"Producto vectorial entre la matriz 1 y 2: \\n\", np.dot(matriz_1, matriz_2))\n\nProducto vectorial entre la matriz 1 y 2: \n [[14 30]\n [38 86]]\n\n\n\nprint(\"Traspuesta de la matriz 1: \\n\", np.transpose(matriz_1))\n\nTraspuesta de la matriz 1: \n [[1 5]\n [3 7]]\n\n\n\nprint(\"Inversa de la matriz 1: \\n\", np.linalg.inv(matriz_1))\n\nInversa de la matriz 1: \n [[-0.875  0.375]\n [ 0.625 -0.125]]\n\n\n\nprint(\"Determinante de la matriz 1: \\n\", np.linalg.det(matriz_1))\n\nDeterminante de la matriz 1: \n -7.999999999999998\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote que así como existen constantes numéricas, existen las matrices particulares como las compuestas por ceros np.zeros(), por unos np.ones() y la matriz identidad np.eyes.\n\n\n\nprint(\"Matriz de identidad de 3x3: \\n\", np.eye(3))\n\nMatriz de identidad de 3x3: \n [[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n\n\n\n\n6.3.2.4 Más operaciones útiles:\n\n\n\n\n\n\n\n\nOperaciones\nFunción\nDescripción\n\n\n\n\nMáximo\nmax()\nValor máximo del array o del eje indicado\n\n\nMínimo\nmin()\nValor mínimo del array o del eje indicado\n\n\nSuma\nsum()\nSuma de todos los elementos o del eje indicado\n\n\nPromedio\nmean()\nPromedio de todos los elementos o del eje indicado\n\n\n\nUtilizando la matriz data como ejemplo:\n\ndata = np.array([[1, 2], [5, 3], [4, 6]])\n\n\nValor máximo\n\n\nprint(\"Valor máximo de todo el array: \", data.max())\nprint(\"Valores máximos de cada columna: \", data.max(axis=0))\n\nValor máximo de todo el array:  6\nValores máximos de cada columna:  [5 6]\n\n\n\nValor mínimo\n\n\nprint(\"Valor mínimo de todo el array: \", data.min())\nprint(\"Valores mínimos de cada fila: \", data.min(axis=1))\n\nValor mínimo de todo el array:  1\nValores mínimos de cada fila:  [1 3 4]\n\n\n\nSuma de elementos:\n\n\nprint(\"Suma de todos los elementos del array: \", data.sum())\nprint(\"Suma de los elementos de cada fila: \", data.sum(axis=1))\n\nSuma de todos los elementos del array:  21\nSuma de los elementos de cada fila:  [ 3  8 10]\n\n\n\nPromedio:\n\n\nprint(\"Promedio de todos los elementos del array: \", data.mean())\nprint(\"Promedio de los elementos de cada columna: \", data.mean(axis=0))\n\nPromedio de todos los elementos del array:  3.5\nPromedio de los elementos de cada columna:  [3.33333333 3.66666667]\n\n\n\n\n\n\n\n\nNote\n\n\n\nNumpy te va a ser muy útil cuando curses materias como Análisis Matemático, Álgebra, Física, Estadística, entre otras. Te va a permitir realizar operaciones de manera rápida y eficiente, y te va a ayudar a entender mejor los conceptos.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Bibliotecas de Python</span>"
    ]
  },
  {
    "objectID": "unidad_6.html#pandas",
    "href": "unidad_6.html#pandas",
    "title": "6  Bibliotecas de Python",
    "section": "6.4 Pandas",
    "text": "6.4 Pandas\nPandas es una biblioteca de código abierto diseñada específicamente para la manipulación y el análisis de datos en Python. Es una herramienta poderosa que puede ayudar a los usuarios a limpiar, transformar y analizar datos de una manera rápida y eficiente.\nAl igual que Numpy, se debe importar. Por convención:\n\nimport pandas as pd\n\nLos datos a trabajar en Pandas van a tener, en general, una forma muy similar a las tablas:\n\n\n\nEsquema de figuras y axes\n\n\nPandas es una biblioteca un poco más pesada, por lo que vamos a poder aprovechar mucho más Google Colab, que maneja grandes datos de forma rápida y eficiente.\n\n6.4.1 Serie\nPandas incorpora dos estructuras de datos nuevas llamadas: Series y DataFrames.\nUna serie es un vector capaz de contener cualquier tipo de dato, como por ejemplo, números enteros o decimales, strings, objetos de Python, etc.\n\n6.4.1.1 Creación de una Serie\nPara crearlas, se puede partir de un escalar, una lista, un diccionario, etc., utilizando pd.Serie():\n\n# Crear serie partiendo de una lista:\nlista = [1, \"a\", 3.5]\n\npd.Series(lista)\n\n0      1\n1      a\n2    3.5\ndtype: object\n\n\nEsto es análogo a lo que se hacía con los arrays de Numpy, pero con la diferencia de que las series de Pandas pueden contener datos de distinto tipo.\nNotemos que se ven dos líneas verticales de datos en el output. A la derecha se observa una columna con los elementos de la lista antes creada, y a la izquierda se encuentra el índice, formado por valores desde 0 a n-1, siendo n la cantidad de elementos. Este índice numérico es el predefinido, que nos muestra la posición de los elementos dentro de la Serie.\nTambién podríamos cambiarlo si quisiéramos. En ese caso, se puede establecer utilizando index.\nEl índice es de vital importancia ya que permite acceder a los elementos de la serie (muy parecido a cómo las claves nos permiten acceden a los valores de un diccionario). Al elegir índices personalizados, tenemos que tener en cuenta que su longitud debe ser acorde al número de elementos de la Serie. De lo contrario, se mostrará un ValueError.\n\n# Crear serie partiendo de una lista, indicando el índice\npd.Series(lista, index = [\"x\", \"y\", \"z\"])\n\nx      1\ny      a\nz    3.5\ndtype: object\n\n\nTambién podemos crear Series utilizando diccionarios, y en ese caso, sus claves (o keys) pasan a formar el índice.\n\n# Crear serie partiendo de un diccionario:\ndiccionario = {\"x\": 1, \"y\": \"a\", \"z\": 3.5}\n\na = pd.Series(diccionario)\na\n\nx      1\ny      a\nz    3.5\ndtype: object\n\n\n\n\n6.4.1.2 Accediendo a un elemento\nComo ya se debe estar imaginando, para acceder a un elemento de la serie, se debe indicar el valor del índice.\n\n# Acceder al elemento de índice y:\na[\"y\"]\n\n'a'\n\n\nSi los índices son numéricos, simplemente se le pasa entre corchetes un número.\n\n\n6.4.1.3 Operaciones con Series\nAsí como pasaba con los arrays de NumPy, las Series no requieren recorrer valor por valor en un ciclo for si queremos realizar operaraciones. Podemos usar directamente operadores con Series.\nPor ejemplo:\n\na + a\n\nx      2\ny     aa\nz    7.0\ndtype: object\n\n\n\na * 3\n\nx       3\ny     aaa\nz    10.5\ndtype: object\n\n\n\n\n\n6.4.2 DataFrame\nUn DataFrame es una estructura de datos tabular (bidimensional, en forma de tabla), compuesta por filas y columnas, que se parece mucho a una hoja de cálculo de Excel.\n\n6.4.2.1 Creando DataFrames\nPara crearlos, se utiliza DataFrame() y se ingresan diferentes estructuras como arrays, diccionarios, listas, series u otros dataframes.\nEn el siguiente ejemplo, se crea un Dataframe partiendo de un diccionario llamado data para las columnas y de una lista label para el índice:\n\ndata = {'columna_1': ['a', 'b', 'c', 'd', 'e', 'f'],\n        'columna_2': [2.5, 3, 0.5, None, 5, None],\n        'columna_3': [1, 3, 2, 3, 2, 3]}\n\nlabels = ['a1', 'a2', 'a3', 'a4', 'a5', 'a6']\n\ndf = pd.DataFrame(data, index=labels)\ndf\n\n\n\n\n\n\n\n\ncolumna_1\ncolumna_2\ncolumna_3\n\n\n\n\na1\na\n2.5\n1\n\n\na2\nb\n3.0\n3\n\n\na3\nc\n0.5\n2\n\n\na4\nd\nNaN\n3\n\n\na5\ne\n5.0\n2\n\n\na6\nf\nNaN\n3\n\n\n\n\n\n\n\nLo que vemos acá es el output de ejecutar el código de arriba en una celda: una tabla donde tenemos 3 columnas, y el índice de cada fila son los elementos de la lista labels.\nEn vez de tener un valor None, Pandas lo recibe y lo transforma en NaN, que significa “Not a Number”. Esto es muy útil para trabajar con datos faltantes, ya que Pandas nos permite realizar operaciones con ellos sin que nos de error (a diferencia de Python).\n\n\n6.4.2.2 Atributos y descripción de un Dataframe\nA continuación, se observa una tabla con métodos que nos permiten conocer las características de un determinado DataFrame.\n\n\n\nMétodo o atributo\nDescripción\n\n\n\n\n.info()\nResume la información del DataFrame\n\n\n.shape\nDevuelve una tupla con el número de filas y columnas\n\n\n.size\nNúmero de elementos, aunque también puede usarse len\n\n\n.columns\nLista con los nombres de las columnas\n\n\n.index\nLista con los nombres de las filas\n\n\n.head()\nMuestra las primeras filas\n\n\n.tail()\nMuestra las últimas filas\n\n\n.describe()\nBrinda métricas de las columnas numéricas\n\n\n\nPara ejemplificar los métodos y las funciones de Pandas, usaremos el DataFrame df definido en el siguiente bloque de código.\n\ndata = {'nombre': ['José Martínez', 'Rosa Díaz', 'Javier Garcíaz', 'Carmen López', 'Marisa Collado', 'Antonio Ruiz', 'Antonio Fernández', \n                   'Pilar González', 'Pedro Tenorio', 'Santiago Manzano', 'Macarena Álvarez', 'José Sanz', 'Miguel Gutiérrez', 'Carolina Moreno'],\n        'edad': [18, 32, 24, 35, 46, 68, 51, 22, 35, 46, 53, 58, 27, 20],\n        'genero': ['H', 'M', 'H', 'M', 'X', 'H', 'H', 'M', 'H', 'X', 'M', 'H', 'H', 'M'],\n        'peso': [85.0, 65.0, None, 65.0, 51.0, 66.0, 62.0, 60.0, 90.0, 75.0, 55.0, 78.0, 109.0, 61.0],\n        'altura': [1.79, 1.73, 1.81, 1.7, 1.58, 1.74, 1.72, 1.66, 1.94, 1.85, 1.62, 1.87, 1.98, 1.77],\n        'colesterol': [182.0, 232.0, 191.0, 200.0, 148.0, 249.0, 276.0, None, 241.0, 280.0, 262.0, 198.0, 210.0, 194.0]}\n\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\nnombre\nedad\ngenero\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n3\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n\n\n4\nMarisa Collado\n46\nX\n51.0\n1.58\n148.0\n\n\n5\nAntonio Ruiz\n68\nH\n66.0\n1.74\n249.0\n\n\n6\nAntonio Fernández\n51\nH\n62.0\n1.72\n276.0\n\n\n7\nPilar González\n22\nM\n60.0\n1.66\nNaN\n\n\n8\nPedro Tenorio\n35\nH\n90.0\n1.94\n241.0\n\n\n9\nSantiago Manzano\n46\nX\n75.0\n1.85\n280.0\n\n\n10\nMacarena Álvarez\n53\nM\n55.0\n1.62\n262.0\n\n\n11\nJosé Sanz\n58\nH\n78.0\n1.87\n198.0\n\n\n12\nMiguel Gutiérrez\n27\nH\n109.0\n1.98\n210.0\n\n\n13\nCarolina Moreno\n20\nM\n61.0\n1.77\n194.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nMuchas veces no vamos a querer modificar el dataframe original, pero sin manipularlo. En ese caso, podemos hacer una copia del dataframe original, de esta forma: df_copy = df.copy()\n\n\n\n6.4.2.2.1 Info, dtypes, columns e index\nCon info() se puede ver:\n\nel índice en la primera línea, que es un rango de 0 a 13\nel número total de columnas en la segunda línea\nel uso de la memoria en la última\nuna tabla con los nombres de las columnas en Column, la cantidad de valores no nulos en Non-Null Count y el tipo de dato en Dtype para cada una de ellas.\n\n\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 14 entries, 0 to 13\nData columns (total 6 columns):\n #   Column      Non-Null Count  Dtype  \n---  ------      --------------  -----  \n 0   nombre      14 non-null     object \n 1   edad        14 non-null     int64  \n 2   genero      14 non-null     object \n 3   peso        13 non-null     float64\n 4   altura      14 non-null     float64\n 5   colesterol  13 non-null     float64\ndtypes: float64(3), int64(1), object(2)\nmemory usage: 800.0+ bytes\n\n\nNote que utilizando columns e index se obtiene parte de esta información:\n\n# Nombre de cada columna\ndf.columns\n\nIndex(['nombre', 'edad', 'genero', 'peso', 'altura', 'colesterol'], dtype='object')\n\n\n\n# índice\ndf.index\n\nRangeIndex(start=0, stop=14, step=1)\n\n\n \n\n\n6.4.2.2.2 Shape y Size\nLa forma del DataFrame es de 14 filas y 6 columnas, por lo que contiene 84 elementos.\n\n# Forma del DataFrame (filas, columnas)\ndf.shape\n\n(14, 6)\n\n\n\n# Número de elementos del DataFrame\ndf.size\n\n84\n\n\n\n\n\n\n6.4.2.2.3 Head y Tail\nAsimismo, cuando no conocemos un DataFrame, puede ser importante ver las primeras 5 filas con head() o las últimas con tail(). Si se quisiera observar un número determinado, sólo hay que especificarlo, por ejemplo:\n\n# Mostrar las primeras 3 filas.\ndf.head(3)\n\n\n\n\n\n\n\n\nnombre\nedad\ngenero\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n\n\n\n\n\n\n# Mostrar las últimas 5 filas.\ndf.tail()\n\n\n\n\n\n\n\n\nnombre\nedad\ngenero\npeso\naltura\ncolesterol\n\n\n\n\n9\nSantiago Manzano\n46\nX\n75.0\n1.85\n280.0\n\n\n10\nMacarena Álvarez\n53\nM\n55.0\n1.62\n262.0\n\n\n11\nJosé Sanz\n58\nH\n78.0\n1.87\n198.0\n\n\n12\nMiguel Gutiérrez\n27\nH\n109.0\n1.98\n210.0\n\n\n13\nCarolina Moreno\n20\nM\n61.0\n1.77\n194.0\n\n\n\n\n\n\n\n\n\n\n\n6.4.2.2.4 Describe\nPor otro lado, describe() devuelve un resumen descriptivo de las columnas de valores numéricos, como “edad”, “peso”, “altura” y “colesterol”.\n\ndf.describe()\n\n\n\n\n\n\n\n\nedad\npeso\naltura\ncolesterol\n\n\n\n\ncount\n14.000000\n13.000000\n14.000000\n13.000000\n\n\nmean\n38.214286\n70.923077\n1.768571\n220.230769\n\n\nstd\n15.621379\n16.126901\n0.115016\n39.847948\n\n\nmin\n18.000000\n51.000000\n1.580000\n148.000000\n\n\n25%\n24.750000\n61.000000\n1.705000\n194.000000\n\n\n50%\n35.000000\n65.000000\n1.755000\n210.000000\n\n\n75%\n49.750000\n78.000000\n1.840000\n249.000000\n\n\nmax\n68.000000\n109.000000\n1.980000\n280.000000\n\n\n\n\n\n\n\nEstas métricas podrían obtenerse de forma puntual (tanto para todo el DataFrame como para sólo una columna) utilizando funciones determinadas, como:\n\n\ncount(): contabiliza los valores no nulos\nmean(): promedio\nmin(): valor mínimo\nmax(): valor máximo\n\nPor ejemplo:\n\ndf.count()\n\nnombre        14\nedad          14\ngenero        14\npeso          13\naltura        14\ncolesterol    13\ndtype: int64\n\n\n\ndf.min()\n\nnombre        Antonio Fernández\nedad                         18\ngenero                        H\npeso                       51.0\naltura                     1.58\ncolesterol                148.0\ndtype: object\n\n\n\ndf.max()\n\nnombre        Santiago Manzano\nedad                        68\ngenero                       X\npeso                     109.0\naltura                    1.98\ncolesterol               280.0\ndtype: object\n\n\n\n\n\n6.4.2.3 Accediendo a filas de un DataFrame\nFinalmente, como ocurre con las series, para acceder a los elementos de un DataFrame se puede indicar la posición o el nombre de la fila o columna.\nPara acceder a una fila en particular, utilizamos iloc[]. Podemos pasarle a iloc un entero, una lista de enteros, un rango de números (que indican las posiciones) o directamente el valor del índice.\n\n# Mostrar la fila de posición 0, usando doble corchete [[]]\n# Recibe una lista de elementos a mostrar (que contiene sólo al 0)\ndf.iloc[[0]]\n\n\n\n\n\n\n\n\nnombre\nedad\ngenero\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n\n\n\n\n\n Si queremos mostrar un rango, lo hacemos así: \n\n# Mostrar las filas de posición 0 y 3, usando doble corchete [[]]\n# Recibe una lista de elementos a mostrar\ndf.iloc[[0, 3]]\n\n\n\n\n\n\n\n\nnombre\nedad\ngenero\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n3\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n\n\n\n\n\n\n\n \n\n# Mostrar las filas de posiciones entre 0 hasta 3 (exclusive)\n# Usa slices\ndf.iloc[:3]\n\n\n\n\n\n\n\n\nnombre\nedad\ngenero\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n\n\n\n\n\n\n\n# El equivalente a df.iloc[:3] es el uso de head(3)\ndf.head(3)\n\n\n\n\n\n\n\n\nnombre\nedad\ngenero\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n\n\n\n\n\n\n\n\n6.4.2.4 Accediendo a columnas de un DataFrame\nA veces no queremos sólo acceder a filas, sino a columnas. Por ejemplo, para calcular sumas, promedios, máximos o mínimos, etc.\nPara acceder a una columna se pueden utilizar una lista con los nombres de las columnas que se quieren mostrar: DataFrame[[columna1, columna2]].\n\n# Mostrar la columna \"nombre\"\ndf[['nombre']]\n\n\n\n\n\n\n\n\nnombre\n\n\n\n\n0\nJosé Martínez\n\n\n1\nRosa Díaz\n\n\n2\nJavier Garcíaz\n\n\n3\nCarmen López\n\n\n4\nMarisa Collado\n\n\n5\nAntonio Ruiz\n\n\n6\nAntonio Fernández\n\n\n7\nPilar González\n\n\n8\nPedro Tenorio\n\n\n9\nSantiago Manzano\n\n\n10\nMacarena Álvarez\n\n\n11\nJosé Sanz\n\n\n12\nMiguel Gutiérrez\n\n\n13\nCarolina Moreno\n\n\n\n\n\n\n\n\n\n# Mostrar más de una columna: \"nombre\" y \"edad\":\ndf[['nombre', 'edad']]\n\n\n\n\n\n\n\n\nnombre\nedad\n\n\n\n\n0\nJosé Martínez\n18\n\n\n1\nRosa Díaz\n32\n\n\n2\nJavier Garcíaz\n24\n\n\n3\nCarmen López\n35\n\n\n4\nMarisa Collado\n46\n\n\n5\nAntonio Ruiz\n68\n\n\n6\nAntonio Fernández\n51\n\n\n7\nPilar González\n22\n\n\n8\nPedro Tenorio\n35\n\n\n9\nSantiago Manzano\n46\n\n\n10\nMacarena Álvarez\n53\n\n\n11\nJosé Sanz\n58\n\n\n12\nMiguel Gutiérrez\n27\n\n\n13\nCarolina Moreno\n20\n\n\n\n\n\n\n\nDe esta forma, podríamos hacer algo así:\n\n# calculamos el promedio para los valores de la columna 'edad'\ndf[['edad']].mean()\n\nedad    38.214286\ndtype: float64\n\n\n\n\n6.4.2.5 Modificar un Dataframe\nA la hora de modificar un DataFrame, tenemos distintas posibilidades:\n\n\nCambiar la estructura del mismo, como los nombres de las columnas y de los índices,\nAgregar una nueva filas o columna\nReemplazar un dato en una determinada posición.\n\nA continuación, se enumeran distintos métodos para llevar a cabo estos cambios.\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nrename()\nRenombra las columnas\n\n\ninsert()\nAgrega columnas\n\n\ndrop()\nElimina columnas y filas\n\n\nloc[fila]\nAgrega una fila en un índice dado\n\n\nloc[fila, columna]\nModifica un valor particular dado un índice y una columna\n\n\nmap()\nBusca un valor dado en una columna y lo reemplaza\n\n\nreplace()\nReemplaza un valor dado en una columna\n\n\n\n\n\n6.4.2.5.1 Rename, insert y drop\nPara renombrar una columna, se utiliza un diccionario: rename(columns={\"nombre_columna\": \"nuevo_nombre_columna\"})\n\n# Reemplazo \"nombre\" por \"nombre y apellido\"\ndf = df.rename(columns={\"nombre\": \"nombre y apellido\"})\ndf.head() # para que veamos el cambio de nombre en la columna\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n3\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n\n\n4\nMarisa Collado\n46\nX\n51.0\n1.58\n148.0\n\n\n\n\n\n\n\n Para agregar una nueva columna, existe el método insert(), que requiere indicar la posición de la nueva columna, el nombre de la nueva columna, y los valores de la misma.\nVamos a crear una lista llamada direccion con 14 valores, para cada una de las personas del DataFrame, y luego agregarla en la posición 3:\n\n# Valores de la nueva columna\ndireccion = [\"CABA\", \"Bs As\", \"Bs As\", \"Bs As\", \"CABA\", \"Bs As\", \"CABA\", \"CABA\", \"CABA\", \"CABA\", \"CABA\", \"Bs As\", \"CABA\", \"CABA\"]\n\n# Insertar la columna \"direccion\" en la posición 3 de columnas:\ndf.insert(3, \"direccion\", direccion)\ndf.head() # para que veamos que la columna nueva se agregó\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\nCABA\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\nBs As\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nBs As\nNaN\n1.81\n191.0\n\n\n3\nCarmen López\n35\nM\nBs As\n65.0\n1.70\n200.0\n\n\n4\nMarisa Collado\n46\nX\nCABA\n51.0\n1.58\n148.0\n\n\n\n\n\n\n\nPara agregar una nueva columna también podemos hacerlo directamente, como si fuera un diccionario: df['nueva_columna'] = valores.\nPor ejemplo, supongamos que queremos ingresar una columna con el índice de masa corporal de las personas., que se calcula de la siguiente manera:\n\\[IMC = \\frac{Peso(kg)}{Altura(m)^2}\\]\nEsto podemos hacerlo directamente trabajando sobre las columnas, como trabajábamos sobre los arrays de NumPy; y guardando el resultado en una nueva columna llamada “IMC”.\n\n# Crear la columna \"IMC\"\ndf[\"IMC\"] = df[\"peso\"] / df[\"altura\"]**2\ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n0\nJosé Martínez\n18\nH\nCABA\n85.0\n1.79\n182.0\n26.528510\n\n\n1\nRosa Díaz\n32\nM\nBs As\n65.0\n1.73\n232.0\n21.718066\n\n\n2\nJavier Garcíaz\n24\nH\nBs As\nNaN\n1.81\n191.0\nNaN\n\n\n3\nCarmen López\n35\nM\nBs As\n65.0\n1.70\n200.0\n22.491349\n\n\n4\nMarisa Collado\n46\nX\nCABA\n51.0\n1.58\n148.0\n20.429418\n\n\n\n\n\n\n\nEsto lo que va a hacer es tomar todos los valores de peso y altura de cada fila, calcular el IMC y guardarlo en una nueva columna de la línea, bajo el nombre “IMC”.\nDe manera similar, se puede crear la columna dni sin utilizar insert(), usando la lista dni:\n\ndf_copy = df.copy() # Hacemos una copia, para que no nos afecte el original\ndni = [12345678, 23456789, 34567890, 45678901, 56789012, 67890123, 78901234, 89012345, 90123456, 12345678, 23456789, 34567890, 45678901, 56789012]\ndf_copy[\"dni\"] = dni\ndf_copy.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\ndni\n\n\n\n\n0\nJosé Martínez\n18\nH\nCABA\n85.0\n1.79\n182.0\n26.528510\n12345678\n\n\n1\nRosa Díaz\n32\nM\nBs As\n65.0\n1.73\n232.0\n21.718066\n23456789\n\n\n2\nJavier Garcíaz\n24\nH\nBs As\nNaN\n1.81\n191.0\nNaN\n34567890\n\n\n3\nCarmen López\n35\nM\nBs As\n65.0\n1.70\n200.0\n22.491349\n45678901\n\n\n4\nMarisa Collado\n46\nX\nCABA\n51.0\n1.58\n148.0\n20.429418\n56789012\n\n\n\n\n\n\n\nPor lo que vemos que no es indispensable usar insert para poder agregar una nueva columna, pero insert nos permite decir en dónde queremos agregarla.\n\nPara eliminar una fila (axis=0) o columna (axis=1), se utiliza drop():\n# Elimino una columna llamada \"direccion\". También podría hacer: `del df[\"direccion\"]`\ndf = df.drop('direccion', axis=1)  \n\n# Elimino la fila 14\ndf = df.drop(14, axis=0) \n\n\n\n6.4.2.6 Insertar filas\nPara agregar una nueva fila, se utiliza loc[], que nos pide indicar el índice y los valores de la misma. Para ello, creamos una lista llamada nueva_fila con valores para cada columna del DataFrame.\n\n# Valores de la nueva fila\nnueva_fila = ['Carlos Rivas', 30, 'H', \"CABA\", 70.0, 1.75, 203.0, 22]\n\n# Insertamos al final del DataFrame\nlargo = len(df.index) # o también: largo = df.shape[0], para obtener la cantidad de filas\ndf.loc[largo] = nueva_fila\ndf.tail() # Para ver que se agregó al final\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n10\nMacarena Álvarez\n53\nM\nCABA\n55.0\n1.62\n262.0\n20.957171\n\n\n11\nJosé Sanz\n58\nH\nBs As\n78.0\n1.87\n198.0\n22.305471\n\n\n12\nMiguel Gutiérrez\n27\nH\nCABA\n109.0\n1.98\n210.0\n27.803285\n\n\n13\nCarolina Moreno\n20\nM\nCABA\n61.0\n1.77\n194.0\n19.470778\n\n\n14\nCarlos Rivas\n30\nH\nCABA\n70.0\n1.75\n203.0\n22.000000\n\n\n\n\n\n\n\n\n\n\n\n\n\n¿Por qué usamos ‘len’ arriba?\n\n\n\n\n\nA diferencia de Python, podemos agregar una fila en una posición que no existe aún. Por eso arriba pudimos hacer df.loc[largo].\n\n\n\n\n\n6.4.2.7 Modificar un valor\nFinalmente, para cambiar un valor determinado también se utiliza loc[], como por ejemplo, agregar el peso de Javier García (tercera fila), que antes tenía NaN:\n\ndf.loc[2, 'peso'] = 92\ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n0\nJosé Martínez\n18\nH\nCABA\n85.0\n1.79\n182.0\n26.528510\n\n\n1\nRosa Díaz\n32\nM\nBs As\n65.0\n1.73\n232.0\n21.718066\n\n\n2\nJavier Garcíaz\n24\nH\nBs As\n92.0\n1.81\n191.0\nNaN\n\n\n3\nCarmen López\n35\nM\nBs As\n65.0\n1.70\n200.0\n22.491349\n\n\n4\nMarisa Collado\n46\nX\nCABA\n51.0\n1.58\n148.0\n20.429418\n\n\n\n\n\n\n\n\nPara transformar los valores de una columna entera, podemos utilizar map() pasando un diccionario del estilo {valor_viejo: valor_nuevo}. Por ejemplo, modificar la columna “genero” reemplazando “H” por “M”, “M” por “F”:\n\ndf['genero'] = df['genero'].map({'H': 'M', 'M': 'F', 'X': 'X'})\ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n0\nJosé Martínez\n18\nM\nCABA\n85.0\n1.79\n182.0\n26.528510\n\n\n1\nRosa Díaz\n32\nF\nBs As\n65.0\n1.73\n232.0\n21.718066\n\n\n2\nJavier Garcíaz\n24\nM\nBs As\n92.0\n1.81\n191.0\nNaN\n\n\n3\nCarmen López\n35\nF\nBs As\n65.0\n1.70\n200.0\n22.491349\n\n\n4\nMarisa Collado\n46\nX\nCABA\n51.0\n1.58\n148.0\n20.429418\n\n\n\n\n\n\n\n\nOtra manera sería utilizando replace(). Por ejemplo, en la columna “direccion” vamos a modificar “Bs As” por “Buenos Aires”.\n\ndf['direccion'] = df['direccion'].replace('Bs As', 'Buenos Aires')\ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n0\nJosé Martínez\n18\nM\nCABA\n85.0\n1.79\n182.0\n26.528510\n\n\n1\nRosa Díaz\n32\nF\nBuenos Aires\n65.0\n1.73\n232.0\n21.718066\n\n\n2\nJavier Garcíaz\n24\nM\nBuenos Aires\n92.0\n1.81\n191.0\nNaN\n\n\n3\nCarmen López\n35\nF\nBuenos Aires\n65.0\n1.70\n200.0\n22.491349\n\n\n4\nMarisa Collado\n46\nX\nCABA\n51.0\n1.58\n148.0\n20.429418\n\n\n\n\n\n\n\n\n\n6.4.2.8 Filtrar un Dataframe\nPara filtrar los elementos de un DataFrame se suelen utilizar condiciones lógicas de la siguiente forma: DataFrame[ condicion ].\nPor ejemplo:\n\n# Seleccionar aquellas personas menores de 40 años\n# La condición es que la columna 'edad' del dataframe tenga valor menor a 40\ndf[ df['edad'] &lt; 40 ] \n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n0\nJosé Martínez\n18\nM\nCABA\n85.0\n1.79\n182.0\n26.528510\n\n\n1\nRosa Díaz\n32\nF\nBuenos Aires\n65.0\n1.73\n232.0\n21.718066\n\n\n2\nJavier Garcíaz\n24\nM\nBuenos Aires\n92.0\n1.81\n191.0\nNaN\n\n\n3\nCarmen López\n35\nF\nBuenos Aires\n65.0\n1.70\n200.0\n22.491349\n\n\n7\nPilar González\n22\nF\nCABA\n60.0\n1.66\nNaN\n21.773842\n\n\n8\nPedro Tenorio\n35\nM\nCABA\n90.0\n1.94\n241.0\n23.913275\n\n\n12\nMiguel Gutiérrez\n27\nM\nCABA\n109.0\n1.98\n210.0\n27.803285\n\n\n13\nCarolina Moreno\n20\nF\nCABA\n61.0\n1.77\n194.0\n19.470778\n\n\n14\nCarlos Rivas\n30\nM\nCABA\n70.0\n1.75\n203.0\n22.000000\n\n\n\n\n\n\n\n Cuando se requieren múltiples condiciones, se puede adicionar usando símbolos como & para and y | para or. Por ejemplo:\n\n# Seleccionar aquellas personas de genero femenino y menores de 40 años:\ndf[ (df['edad'] &lt; 40) & (df['genero'] == 'F') ]\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n1\nRosa Díaz\n32\nF\nBuenos Aires\n65.0\n1.73\n232.0\n21.718066\n\n\n3\nCarmen López\n35\nF\nBuenos Aires\n65.0\n1.70\n200.0\n22.491349\n\n\n7\nPilar González\n22\nF\nCABA\n60.0\n1.66\nNaN\n21.773842\n\n\n13\nCarolina Moreno\n20\nF\nCABA\n61.0\n1.77\n194.0\n19.470778\n\n\n\n\n\n\n\n\n\n# Seleccionar aquellas personas cuyo peso es 60kg o 90kg:\ndf[(df['peso'] == 60.0) | (df['peso'] == 90.0)]\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n7\nPilar González\n22\nF\nCABA\n60.0\n1.66\nNaN\n21.773842\n\n\n8\nPedro Tenorio\n35\nM\nCABA\n90.0\n1.94\n241.0\n23.913275\n\n\n\n\n\n\n\n\nTambién puedo filtrar las fillas por el valor NaN.\nPara eso, se utiliza la función isnull() que devuelve True si el valor de la columna es nulo o NaN. Por ejemplo:\n\ndf['IMC'].isnull()\n\n0     False\n1     False\n2      True\n3     False\n4     False\n5     False\n6     False\n7     False\n8     False\n9     False\n10    False\n11    False\n12    False\n13    False\n14    False\nName: IMC, dtype: bool\n\n\nPara visualizar aquellas filas donde el índice de masa corporal es nulo, filtramos:\n\ndf[df['IMC'].isnull()]\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n2\nJavier Garcíaz\n24\nM\nBuenos Aires\n92.0\n1.81\n191.0\nNaN\n\n\n\n\n\n\n\nEl método opuesto es notnull(), que devuelve True si el valor de la columna no es nulo o NaN. Por ejemplo:\n\ndf[df['IMC'].notnull()]\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n0\nJosé Martínez\n18\nM\nCABA\n85.0\n1.79\n182.0\n26.528510\n\n\n1\nRosa Díaz\n32\nF\nBuenos Aires\n65.0\n1.73\n232.0\n21.718066\n\n\n3\nCarmen López\n35\nF\nBuenos Aires\n65.0\n1.70\n200.0\n22.491349\n\n\n4\nMarisa Collado\n46\nX\nCABA\n51.0\n1.58\n148.0\n20.429418\n\n\n5\nAntonio Ruiz\n68\nM\nBuenos Aires\n66.0\n1.74\n249.0\n21.799445\n\n\n6\nAntonio Fernández\n51\nM\nCABA\n62.0\n1.72\n276.0\n20.957274\n\n\n7\nPilar González\n22\nF\nCABA\n60.0\n1.66\nNaN\n21.773842\n\n\n8\nPedro Tenorio\n35\nM\nCABA\n90.0\n1.94\n241.0\n23.913275\n\n\n9\nSantiago Manzano\n46\nX\nCABA\n75.0\n1.85\n280.0\n21.913806\n\n\n10\nMacarena Álvarez\n53\nF\nCABA\n55.0\n1.62\n262.0\n20.957171\n\n\n11\nJosé Sanz\n58\nM\nBuenos Aires\n78.0\n1.87\n198.0\n22.305471\n\n\n12\nMiguel Gutiérrez\n27\nM\nCABA\n109.0\n1.98\n210.0\n27.803285\n\n\n13\nCarolina Moreno\n20\nF\nCABA\n61.0\n1.77\n194.0\n19.470778\n\n\n14\nCarlos Rivas\n30\nM\nCABA\n70.0\n1.75\n203.0\n22.000000\n\n\n\n\n\n\n\n\n\n6.4.2.9 Ordenando y Contando\nA continuación, se muestra una lista con métodos que resultan muy útiles a la hora de analizar datos:\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nsort_values(by, ascending)\nOrdena el DataFrame considerando los valores de la o las columnas determinadas y devuelve un DataFrame nuevo (no modifica el original)\n\n\nvalue_counts()\nIndica los valores únicos de una determinada columna y el número de veces que aparece en ella\n\n\n\n\n6.4.2.9.1 Sort value:\nPara utilizar la función sort_values(by, ascending), se debe indicar en el parámetro by una lista con las columnas para ordenar el DataFrame y en ascending, True si el orden deseado es creciente o False para decreciente.\nEn el siguiente ejemplo ordenamos por “nombre y apellido” en forma alfabética:\n\ndf.sort_values(by=['nombre y apellido'], ascending=[True])\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n6\nAntonio Fernández\n51\nM\nCABA\n62.0\n1.72\n276.0\n20.957274\n\n\n5\nAntonio Ruiz\n68\nM\nBuenos Aires\n66.0\n1.74\n249.0\n21.799445\n\n\n14\nCarlos Rivas\n30\nM\nCABA\n70.0\n1.75\n203.0\n22.000000\n\n\n3\nCarmen López\n35\nF\nBuenos Aires\n65.0\n1.70\n200.0\n22.491349\n\n\n13\nCarolina Moreno\n20\nF\nCABA\n61.0\n1.77\n194.0\n19.470778\n\n\n2\nJavier Garcíaz\n24\nM\nBuenos Aires\n92.0\n1.81\n191.0\nNaN\n\n\n0\nJosé Martínez\n18\nM\nCABA\n85.0\n1.79\n182.0\n26.528510\n\n\n11\nJosé Sanz\n58\nM\nBuenos Aires\n78.0\n1.87\n198.0\n22.305471\n\n\n10\nMacarena Álvarez\n53\nF\nCABA\n55.0\n1.62\n262.0\n20.957171\n\n\n4\nMarisa Collado\n46\nX\nCABA\n51.0\n1.58\n148.0\n20.429418\n\n\n12\nMiguel Gutiérrez\n27\nM\nCABA\n109.0\n1.98\n210.0\n27.803285\n\n\n8\nPedro Tenorio\n35\nM\nCABA\n90.0\n1.94\n241.0\n23.913275\n\n\n7\nPilar González\n22\nF\nCABA\n60.0\n1.66\nNaN\n21.773842\n\n\n1\nRosa Díaz\n32\nF\nBuenos Aires\n65.0\n1.73\n232.0\n21.718066\n\n\n9\nSantiago Manzano\n46\nX\nCABA\n75.0\n1.85\n280.0\n21.913806\n\n\n\n\n\n\n\n¿Qué ocurre cuando ordenamos siguiendo varias columnas? Los valores del DataFrame se ordenan siguiendo la primera columna en primer lugar, luego la segunda, y así sucesivamente.\n\ndf.sort_values(by=['genero', 'nombre y apellido'], ascending=[True, True])\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\ngenero\ndireccion\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n3\nCarmen López\n35\nF\nBuenos Aires\n65.0\n1.70\n200.0\n22.491349\n\n\n13\nCarolina Moreno\n20\nF\nCABA\n61.0\n1.77\n194.0\n19.470778\n\n\n10\nMacarena Álvarez\n53\nF\nCABA\n55.0\n1.62\n262.0\n20.957171\n\n\n7\nPilar González\n22\nF\nCABA\n60.0\n1.66\nNaN\n21.773842\n\n\n1\nRosa Díaz\n32\nF\nBuenos Aires\n65.0\n1.73\n232.0\n21.718066\n\n\n6\nAntonio Fernández\n51\nM\nCABA\n62.0\n1.72\n276.0\n20.957274\n\n\n5\nAntonio Ruiz\n68\nM\nBuenos Aires\n66.0\n1.74\n249.0\n21.799445\n\n\n14\nCarlos Rivas\n30\nM\nCABA\n70.0\n1.75\n203.0\n22.000000\n\n\n2\nJavier Garcíaz\n24\nM\nBuenos Aires\n92.0\n1.81\n191.0\nNaN\n\n\n0\nJosé Martínez\n18\nM\nCABA\n85.0\n1.79\n182.0\n26.528510\n\n\n11\nJosé Sanz\n58\nM\nBuenos Aires\n78.0\n1.87\n198.0\n22.305471\n\n\n12\nMiguel Gutiérrez\n27\nM\nCABA\n109.0\n1.98\n210.0\n27.803285\n\n\n8\nPedro Tenorio\n35\nM\nCABA\n90.0\n1.94\n241.0\n23.913275\n\n\n4\nMarisa Collado\n46\nX\nCABA\n51.0\n1.58\n148.0\n20.429418\n\n\n9\nSantiago Manzano\n46\nX\nCABA\n75.0\n1.85\n280.0\n21.913806\n\n\n\n\n\n\n\nEn el ejemplo de arriba, primero se ordena de manera creciente por genero, resultando en tres grupos: “genero” = “F”, “M” y “X”. Luego, cada uno de esos grupos se ordena por “nombre y apellido” de forma creciente.\n\n\n\nEjemplo de sort_values()\n\n\n\n\n6.4.2.9.2 Value Count:\nUtilizando value_counts() se pueden contar las filas en cada grupo según “direccion”. Es decir, cuenta cuántas apariciones hay de cada valor en una columna.\n\ndf['direccion'].value_counts()\n\ndireccion\nCABA            10\nBuenos Aires     5\nName: count, dtype: int64\n\n\n\n\n\n\n6.4.3 Conclusiones\nPandas nos permite trabajar con datos de una manera muy sencilla y eficiente. Nos permite importar datos de distintas fuentes, limpiarlos, transformarlos y analizarlos. Además, nos permite visualizar los datos de una manera muy amigable, lo que nos va a permitir entender mejor los datos con los que estamos trabajando.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Bibliotecas de Python</span>"
    ]
  },
  {
    "objectID": "unidad_6.html#matplotlib",
    "href": "unidad_6.html#matplotlib",
    "title": "6  Bibliotecas de Python",
    "section": "6.5 Matplotlib",
    "text": "6.5 Matplotlib\n\n\n\n\n\n\nNote\n\n\n\nPara Matplotlib también vamos a usar Google Colab\n\n\nMatplotlib es probablemente la biblioteca de Python más usada para crear gráficos, también llamados plots. Esta biblioteca provee una forma rápida de graficar datos en varios formatos de alta calidad que pueden ser compartidos y/o publicados.\nEl primer paso es importar la biblioteca. Por convención:\n\nimport matplotlib.pyplot as plt\n\n\n6.5.1 Introducción\nPara crear un gráfico con matplotlib, se deben seguir los siguientes pasos:\n\nCrear la figura que contendrá el gráfico, utilizando las funciones subplots() o figure(). Se recomienda la primera, es la que va a utilizarse en la materia.\nGraficar los datos, utilizando distintas funciones dependiendo del tipo de gráfico que se desea realizar:\n\n\n\n\nFunción\nTipo de Gráfico\n\n\n\n\nplot()\nGráfico de línea\n\n\nscatter()\nGráfico de puntos\n\n\nbar()\nGráfico de barras verticales\n\n\nbarh()\nGráfico de barras horizontales\n\n\npie()\nGráfico de torta\n\n\n\n\nPersonalizar el gráfico. Este paso es muy recomendado para lograr un mejor entendimiento de la visualización. Esto incluye agregar etiquetas a los ejes, títulos, leyendas, etc. También podemos modificar el aspecto de las líneas, los puntos, los colores, y más (esto se deja en el final del apunte, y es opcional).\nMostrar el gráfico, utilizando la función show()\n\nplt.show()\n\n\n\n6.5.2 Creando una figura\nPara crear una figura, la función de gráfico recibe los datos a graficar y los parámetros necesarios para personalizarlo.\n\n6.5.2.1 Gráfico de línea\nEl gráfico de línea permite visualizar cambios en los valores lo largo de un rango continuo (tendencias), como puede ser el tiempo o la distancia.\nPara crear un gráfico de línea, se utiliza la función plot().\n\n# Grafico elemental\nx = [0,2,10,11,18,25]\ny = [0,1,2,3,4,5]\n\nfig, ax = plt.subplots()\n\n# Gráfico de línea\nax.plot(x, y)\nplt.show()\n\n\n\n\n\n\n\n\nEn este caso, se creó un gráfico de línea con los valores de x e y, tal que los puntos (0,0), (2,1), (10,2), (11,3), (18,4) y (25,5) están unidos por una línea recta.\n\n\n6.5.2.2 Gráfico de puntos\nEl gráfico de dispersión o puntos permite visualizar la relación entre las variables.\nPara crearlo, se utiliza la función scatter():\n\n# Gráfico de puntos\nfig2, ax2 = plt.subplots()\nax2.scatter(x, y)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrillas\n\n\n\n¿Ves cómo en el gráfico de puntos quizás no se entiende bien la ubicación de cada punto?\nEsto es porque no tenemos una guía que nos ayude. Para eso, vamos a agregar una grilla. La grilla se puede agregar con al función grid(), y es una buena forma de darle legibilidad a un gráfico como puede ser el de línea y el de puntos.\n\n\n\n\n# Gráfico de puntos\nfig, ax = plt.subplots()\nax.scatter(x, y)\nax.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n6.5.2.3 Gráficos de Barras\nEl gráfico de barras permite visualizar proporciones, comparando dos o más valores entre sí. Para crearlo, se utiliza la función bar(), la cual primero recibe, en primer lugar, las etiquetas de las barras que se van a mostrar y en segundo lugar, la altura correspondiente a cada una de estas barras.\nEn el caso de este tipo de gráfico, no hace falta que los valores de las etiquetas sean numéricos.\n\npeso = [340, 115, 200, 200, 270]\ningredientes = ['chocolate', 'manteca', 'azúcar', 'huevo', 'harina']\n\nfig, ax = plt.subplots()\n\nax.bar(ingredientes, peso) # Acá podría usarse también barh\n\nax.set_xlabel('Ingredientes')\nax.set_ylabel('Masa (g)')\n\nax.set_title(\"Receta\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n6.5.2.4 Gráfico de torta\nFinalmente, tenemos el gráfico de torta. El gráfico de torta, como el de barras, permite visualizar y comparar proporciones pero de manera circular y como partes de un todo.\nPara crearlo, se utiliza la función pie(), que recibe los valores de las porciones y las etiquetas de cada una. Para las etiquetas, se debe indicar la variable label, y si además queremos que se muestren los porcentajes, se puede utilizar autopct='%1.1f%%'. '%1.1f%%' significa que se mostrará un decimal y el símbolo de porcentaje.\n\npeso = [340, 115, 200, 200, 270]\ningredientes = ['chocolate', 'manteca', 'azúcar', 'huevo', 'harina']\n\nfig, ax = plt.subplots()\n\nax.pie(peso, labels= ingredientes, autopct='%1.1f%%')\n\nax.set_title(\"Receta\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n6.5.2.5 Cambio de Tamaño\nPodemos establecer el tamaño de la figura con el parámetro figsize dentro de la función subplots(). Este parámetro recibe una tupla con dos valores: el ancho y el alto de la figura, en pulgadas.\nVeamos este ejemplo: x es el tiempo medido en minutos e y una distancia en metros, entonces:\n\nx = [0,2,10,11,18,25]   # Tiempo (min)\ny = [0,1,2,3,4,5]       # Distancia (m)\n\nfig, ax = plt.subplots(figsize=(3, 5))\n\nax.plot(x, y)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n6.5.3 Títulos\nAsí como los nombres de las variables en nuestro código, es importante que nuestro gráfico tenga un Título descriptivo que nos ayude a entender qué es lo que estamos viendo. Lo mismo pasa con los ejes: queremos poder entender qué representa cada uno.\nPara setear un título, vamos a usar la función set_title(). Para los ejes, usaremos set_xlabel() y set_ylabel(). Cada una recibe un string que se usará como etiqueta del eje X, etiqueta del eje Y o título, respectivamente.\nSiguiendo el ejemplo anterior, vamos a agregar títulos a los ejes y al gráfico:\n\nx = [0,2,10,11,18,25]   # Tiempo (min)\ny = [0,1,2,3,4,5]       # Distancia (m)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y)\n\n# Mostrar el título del gráfico\nax.set_title(\"Gráfico de posición\")\n\n# Mostrar el título de los ejes\nax.set_xlabel('Tiempo (min)')\nax.set_ylabel('Distancia (m)')\n\n\nax.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n6.5.4 Referencias\nEl gráfico con el que estamos trabajando sólo tiene una línea, pero si contara con más de una (lo vamos a ver más adelante en este apunte), el uso de referencias sería muy importante para lograr el entendimiento del mismo. Para rotular las líneas, dentro de plot() se debe definir la referencia como label. Luego se coloca legend()\n\nx = [0,2,10,11,18,25]   # Tiempo (min)\ny = [0,1,2,3,4,5]       # Distancia (m)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, label='Objeto 1') # Agregar el label\n\nax.set_title(\"Gráfico de posición\")\nax.set_xlabel('Tiempo (min)')\nax.set_ylabel('Distancia (m)')\n\n# Agregar la refencia\nax.legend()\n\nax.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n6.5.5 Gráficos múltiples\nEn los casos anteriores, creamos siempre un sólo gráfico con una curva, en una figura. Pero También podríamos graficar varias curvas en un mismo gráfico.\nPara esto vamos a seguir el mismo procedimiento que antes, pero vamos a agregar más de un plot() al mismo axes. También vamos a darles un label a cada uno, y luego vamos a agregar una leyenda. Automáticamente, al estar en el mismo axes, matplotlib los va a agregar al mismo gráfico con distintos colores.\n\n# Valores que se desean graficar\nx = [0, 1, 2, 3, 4, 5]\ny_linear = [0, 1, 2, 3, 4, 5]\ny_quadratic = [0, 1, 4, 9, 16, 25]\ny_cubic = [0, 1, 8, 27, 64, 125]\n\nfig, ax = plt.subplots()\n\n# Usamos distintos tipos de y, con distintas labels\nax.plot(x, y_linear, label='Lineal')\nax.plot(x, y_quadratic, label='Cuadrático')\nax.plot(x, y_cubic, label='Cúbico')\n\nax.set_title(\"Gráfico de múltiples curvas\")\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\nNote que se agregan nuevos datos al mismo axes, por lo que siempre usamos plot() pero con distintos valores de y. Asimismo, se estableció un tamaño de la figura con figsize=(width, height)\n\n\n6.5.6 Uniendo Bibliotecas\n\n6.5.6.1 Matplotlib y Numpy\nPodemos usar arrays de numpy para simplificarnos el trabajo.\nRepetimos el gráfico anterior pero usando numpy, y vamos a ver que pudimos obtener muchos más valores sin tener que calcularlos nosotros y escribirlos en una lista de Python.\n\nimport numpy as np\n\nx = np.linspace(0, 5, 100) # Creamos un array de 100 valores entre 0 y 5\ny_linear = x # usamos x\ny_quadratic = x**2 # usamos x al cuadrado\ny_cubic = x**3 # usamos x al cubo\n\nfig, ax = plt.subplots()\n\n# Usamos distintos tipos de y\nax.plot(x, y_linear, label='Lineal')\nax.plot(x, y_quadratic, label='Cuadrático')\nax.plot(x, y_cubic, label='Cúbico')\n\nax.set_title(\"Gráfico de múltiples curvas\")\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.legend()\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n6.5.6.2 Matplotlib y Pandas\nTambién podemos usar columnas de Pandas como datos para crear un gráfico.\nSupongamos el siguiente dataframe de los datos de las mascotas en una veterinaria:\n\ndata = { 'nombre': ['Bola de Nieve', 'Jerry', 'Hueso'],\n        'especie': ['gato','chinchilla', 'perro'],\n        'edad': [2.5, 3, 7],\n        'visitas': [1, 3, 2],\n        'prioridad': ['si', 'si', 'no']}\n\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\nnombre\nespecie\nedad\nvisitas\nprioridad\n\n\n\n\n0\nBola de Nieve\ngato\n2.5\n1\nsi\n\n\n1\nJerry\nchinchilla\n3.0\n3\nsi\n\n\n2\nHueso\nperro\n7.0\n2\nno\n\n\n\n\n\n\n\nPodemos ahora crear un gráfico usando las columnas del dataframe:\n\n# Determino las columnas del DataFrame que queremos graficar\nx_values = df['nombre']\ny_values = df['edad']\n\nfig, ax = plt.subplots()\n\nax.bar(x_values, y_values)\n\nax.set_xlabel('Paciente')\nax.set_ylabel('Edad (años)')\n\nax.set_title(\"Mascotas\")\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n¿Qué pasa si nuestros labels no llegan a verse? (opcional)\n\n\n\n\n\nPuede pasar, sobre todo si tenemos muchos datos con nombres largos, que nuestros labels no lleguen a verse de forma correcta si los presentamos de forma horizontal.\nPor ejemplo:\n\nEn esos casos, podemos pedirle a matplotlib que los presente de forma vertical, para que no se superpongan. Para eso, usamos xticks() y rotation: plt.xticks(rotation=90).\nEl ángulo de rotación se mide en grados, por lo que rotation=90 significa que se rotarán 90 grados. De esta forma, los labels se presentarán de forma vertical. Podríamos también usar otro ángulo, y se mostrarían los labels de forma inclinada.\nEsta es la forma en que se visualizan los datos con los labels rotados:\n\n\n\n\n\n\n\n6.5.7 Bonus Track: Personalización (opcional)\n\n\n\n\n\n\n¿Qué significa opcional?\n\n\n\nSignifica que esta parte del apunte no es obligatoria. Pero si quieren leerla, les va a permitir hacer gráficos más bonitos y personalizados. También les va a permitir llevarse el conocimiento de qué otras herramientas tienen disponibles, y volver a este apunte a buscar información en un futuro si es que la necesitan.\n\n\nEsta imagen, fue obtenida de la referencia de matplotlib y resume de manera fácil y visual las modificaciones que podemos hacerla a las figuras creadas.\n\n\n\nPartes de una Figura. Si querés conocer más detalle, podés ingresar a este link.\n\n\nComo dijimos más arriba, las figuras pueden ser personalizadas de muchas maneras. Algunas son:\n\nColores\nEstilos de línea\nMarcadores\nGrilla personalizada\n\n¡y más!\n\n6.5.7.1 Girando los labels\nNo siempre nuestros labels van a tener todo el espacio disponible para mostrarse de forma correcta.\n\n\n\nLos labels son muy grandes y no hay espacio para mostrarlos correctamente\n\n\nPodemos darle un ángulo a los labels usando xticks: plt.xticks(rotation=90). El valor que le pasemos indica el ángulo de rotación que le vamos a dar a los labels. De esta forma, no se pisan.\n\n\n\nLos labels presentan un ángulo de 90 grados\n\n\n\n\n6.5.7.2 Cambiando colores y estilos\nPara cambiar los colores de los gráficos, podemos utilizar los parámetros color, marker, linestyle, markersize y linewidth dentro de la función plot().\n\ncolor = nombre del color, por ejemplo: 'blue', 'green', 'red', etc.\nmarker = forma de los puntos o marcadores, por ejemplo: '^', 'o', 'v', etc.\nlinestyle = estilo de línea, por ejemplo: 'solid', 'dashed', 'dotted' o sus equivalentes:'-', '--', ':', entre otros.\nmarkersize, linewidth = con un número, establecemos el tamaño del marcador y el espesor de la línea respectivamente.\n\nSi no le asignamos un valor, se establecen los predefinidos.\n\nx = [0,2,10,11,18,25]   # Tiempo (min)\ny = [0,1,2,3,4,5]       # Distancia (m)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n6.5.7.3 Grilla personalizada:\nSi deseamos modificarle a una grilla, por ejemplo, el color, el estilo de línea, o sólo queremos ver uno de los ejes, podemos indicarlo utilizando parámetros muy similares a los vistos anteriormente pero en la funcion grid().\n\nx = [0,2,10,11,18,25]   # Tiempo (min)\ny = [0,1,2,3,4,5]       # Distancia (m)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)\n\n#Grilla modificada\nax.grid(axis = 'y', color = 'gray', linestyle = 'dashed')\nplt.show()\n\n\n\n\n\n\n\n\n\nCon esto finalizamos los temas de la materia.\n¡Esperamos que hayas disfrutado de este recorrido!\nRecordá que si querés dejarnos feedback podés hacerlo en el formulario que está en la parte de Contacto.\nSi te interesa ser docente de la materia, podés ver los requisitos y escribirnos en la sección Ser Docente.\n¡Muchos éxitos! 👋",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Bibliotecas de Python</span>"
    ]
  },
  {
    "objectID": "guia.html",
    "href": "guia.html",
    "title": "Guía de Ejercicios",
    "section": "",
    "text": "Recomendaciones al realizar las guías",
    "crumbs": [
      "Guía de Ejercicios"
    ]
  },
  {
    "objectID": "guia.html#recomendaciones-al-realizar-las-guías",
    "href": "guia.html#recomendaciones-al-realizar-las-guías",
    "title": "Guía de Ejercicios",
    "section": "",
    "text": "Prestá atención al leer el enunciado. En particular:\n\nSi se pide una función que devuelva o calcule un valor, la función debe hacer uso de return.\nSi se pide una función que imprima un valor, la función debe tener un print.\nSi se pide una función que pida o pregunte algo al usuario, la función debe tener un input.\nA menos que se diga específicamente “pedirle al usuario”, no es necesario que el programa contenga input. En todo caso, hacer que la función reciba el o los datos por parámetro.\n\nCada ejercicio puede tener muchas soluciones posibles. Una vez que encuentres una solución, en lugar de pasar al siguiente ejercicio, pensá si se te ocurre una solución cuyo código sea más simple o incluso mejor en términos de calidad.\nEs muy importante que el código sea lo más claro y legible posible.\n\nEn particular, nombres de funciones y variables deben ser descriptivos.\nTambién prestá atención a los espacios en blanco y a la indentación.\n\nNo documentes en exceso, pero tampoco ahorres documentación necesaria.\nProbá siempre que el código cumpla con lo solicitado.\n\n\n\n\n\n\n\nDiscord\n\n\n\nLa materia usa Discord como plataforma adicional para la resolución de los ejercicios de las guías.\nTengan a bien leer con atención el mensaje de bienvenida y las reglas de convivencia. Pueden ingresar al servidor a través del siguiente link.",
    "crumbs": [
      "Guía de Ejercicios"
    ]
  },
  {
    "objectID": "guia.html#guía-1-introducción-a-la-algoritmia-y-la-programación",
    "href": "guia.html#guía-1-introducción-a-la-algoritmia-y-la-programación",
    "title": "Guía de Ejercicios",
    "section": "Guía 1: Introducción a la Algoritmia y la Programación",
    "text": "Guía 1: Introducción a la Algoritmia y la Programación\n\n\n\n\n\n\nRecomendación\n\n\n\nEn esta guía nos dedicaremos a introducirnos en los conceptos de programación y algoritmo. Para los primeros seis ejercicios, te recomendamos ver este video para recordar cómo entiende la computadora nuestras instrucciones.\n\n\n\nSe tiene que explicar a una máquina exactamente cómo servir un vaso de jugo (de los que vienen en cartón) de la heladera. Recordando la definición de algoritmo, hacer una descripción paso a paso de lo que se tiene que hacer y usar para lograr el objetivo. Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nSe tiene que explicar a una máquina exactamente cómo hacer una tostada con queso, pensá qué ingredientes se necesitan con sus cantidades, cómo tiene que ser el espacio de trabajo y los elementos que va a necesitar usar. Recordando la definición de algoritmo, hacer una descripción paso a paso de lo que se tiene que hacer y usar para hacer una tostada con queso. Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nSe te pide que organices una colecta de alimentos no perecederos por la Ciudad de Buenos Aires. Contamos con algunos automóviles y camionetas de voluntarios, un listado de donaciones, listado de los alimentos a donar, la disponibilidad horaria y la dirección en la cual se dejan los alimentos. La colecta se realiza en un solo día. ¿Cómo la organizarías? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nTenés que enviar invitaciones personalizadas para tu cumpleaños. Cada invitación tiene que mencionar el nombre de la persona y la cantidad de invitados adicionales con los que puede venir. Contamos con una impresora a la que le das el texto a enviar, un listado con los nombres de los invitados y los invitados adicionales que pueden ellos traer. ¿Cómo redactarías el texto de la invitación? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nSe te encargó definir qué datos son necesarios para el registro de estudiantes en un curso de inglés. ¿Qué datos crees que deberían ser obligatorios y cuáles opcionales? ¿Y si el curso es de cocina? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nContás con un listado de cosas a comprar y tenés que ir a un supermercado que cuenta con distintas góndolas o pasillos. Cada góndola o pasillo puede contar con varios, uno o ninguno de los productos de tu lista. ¿Cuál sería el listado de instrucciones para poder terminar lo más rápido posible? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nCon el anexo de Google Colab de la Unidad 1, realizá tu primer programa: hacé que se imprima por pantalla un “¡Hola mundo!”.",
    "crumbs": [
      "Guía de Ejercicios"
    ]
  },
  {
    "objectID": "guia.html#guía-2-tipos-de-datos-expresiones-y-funciones",
    "href": "guia.html#guía-2-tipos-de-datos-expresiones-y-funciones",
    "title": "Guía de Ejercicios",
    "section": "Guía 2: Tipos de Datos, Expresiones y Funciones",
    "text": "Guía 2: Tipos de Datos, Expresiones y Funciones\n\nGuardar el texto “Hola, Mundo!” en una variable e imprimirla por pantalla.\nGuardar los números 1, 2 y 3 en tres variables distintas e imprimirlos por pantalla.\n\nGuardar los números 1, 2 y 3 en tres variables distintas y luego sumarlos e imprimir el resultado por pantalla.\n\nRepetir con las distintas operaciones disponibles que se vieron en la unidad 2: resta, multiplicación, división, división entera, resto, potencia; combinando los números entre sí.\n\nCrear un programa que le solicite al usuario:\n\nSu nombre y lo imprima por pantalla.\nSu edad y la imprima por pantalla.\nSu edad, le sume 1, y la imprima por pantalla.\n\nCrear un programa que le solicite al usuario un número, y que imprima el resto obtenido de dividirlo por 2.\n¿Qué operador vimos para obtener el resto?\nEscribir un programa que le pida al usuario su año de nacimiento, y que le diga qué edad tiene en el año actual.\nCrear un programa que le solicite al usuario 5 enteros y que muestre por pantalla el promedio de ellos. Hacerlo de dos formas:\n\nPrimero, usando 5 variables para cada entero.\nDespués, usando una sola variable para almacenar la suma de los 5 enteros. ¿Cómo se te ocurre que podrías hacer?\n\n\n\nA partir de ahora y en adelante, todo lo que se nos pida (incluso si dice “programa”) se debe realizar dentro de una o más funciones.\n\n\nCrear una función que reciba un número y que devuelva el valor absoluto.\nCrear una función que reciba un número y que devuelva True si es par, y False si es impar.\nCrear una función que reciba un número y un string, y que devuelva ambos concatenados dentro de un nuevo string.\nCrear una función que reciba dos enteros y que devuelva el resto y el cociente entre ellos.\nCrear una función que le pida al usuario su nombre y apellido, e los imprima con el siguiente formato: “Apellido, Nombre”.\nHacer una función que reciba una palabra y devuelva la cantidad de letras que tiene.\n\nHacer una función que reciba una palabra y que imprima los primeros 5 caracteres únicamente. Ejemplo: Si se recibe “pensamiento” se debe imprimir “pensa”.\nHacer una función que reciba una palabra y que imprima sólo los caracteres ubicados en posiciones pares. Ejemplo: Si se recibe “pensamiento” se debe imprimir “pnaino”.\nHacer una función que reciba una palabra y que imprima la palabra dada vuelta. Ejemplo: Si se recibe “materia” se debe imprimir “airetam”.\n\nHacer una funcion que reciba una palabra, le borre todas las letras “a” e imprima el resultado por pantalla. Pista: usar una función predefinida de Python. Ejemplo: Si se recibe “casa” se debe imprimir “cs”.\nAnalizar qué tipo de dato (o error) se obtiene al hacer las siguientes operaciones:\n\n5 / 2\n5 // 2\n5 % 2\n5 ** 2\n5.0 / 2\n5.0 // 2\n5.0 % 2\n5.0 ** 2\n5 / 2.0\n5 // 2.0\n5 % 2.0\n5 ** 2.0\n5.0 / 2.0\n5.0 // 2.0\n5.0 % 2.0\n5.0 ** 2.0\n\"Hola\" * 2\n\"Hola\" + 2\n\"Hola\" + \"2\"\nx = \"Hola\"\nx += \" mundo\"\n\n\nEscribir una función que convierta un valor dado en grado Celsius, a Fahrenheit. Recordar que la fórmula para la conversión es: F = 9/5 * C + 32.\nEscribir una función que convierta un valor dado en grados Fahrenheit, a Celsius. Usar la misma fórmula anterior.\n\nEscribir una función que calcule el área de un triángulo recibiendo como parámetros su base y su altura.\nSiendo el cálculo de la norma de un vector \\(v\\) en \\(R^3\\):\n\\[||v|| = \\sqrt{v_1^2 + v_2^2 + v_3^2}\\]\nEscribir una función que calcule la norma de un vector en R3 recibiendo como parámetros las 3 componentes \\(v_1\\), \\(v_2\\) y \\(v_3\\) del mismo.\nDesafío (no obligatorio): Calcular el área de un rectángulo (alineado con los ejes \\(x\\) e \\(y\\)), dadas sus coordenadas \\(x_1\\), \\(x_2\\), \\(y_1\\) e \\(y_2\\). Nota: considerar que tiene que funcionar para cualquier cuadrado, independientemente de los cuadrantes en los que tenga sus vértices.",
    "crumbs": [
      "Guía de Ejercicios"
    ]
  },
  {
    "objectID": "guia.html#guía-3-estructuras-de-control",
    "href": "guia.html#guía-3-estructuras-de-control",
    "title": "Guía de Ejercicios",
    "section": "Guía 3: Estructuras de Control",
    "text": "Guía 3: Estructuras de Control\n\n1. Decisiones\n\nEscribir una función que, dado un número entero \\(n\\), calcule si es impar o no.\nEscribir una implementación propia de la función \\(abs\\), que devuelva el valor absoluto de cualquier valor que reciba. Ejemplo: mi_abs(5) devuelve 5 y mi_abs(-5) devuelve 5. Pista: No se puede usar la función predefinida abs.\nEscribir una función que reciba un número y devuelva True si es entero y False si no lo es. Pista: no se puede usar la función isinstance.\nEscribir una función para determinar si una letra recibida es vocal o no. La misma debe devolver un valor booleano. Luego, escribir una función para determinar si una letra es consonante o no.\n\nResolver sin el uso de in ni not in.\nResolver usando in y not in.\nResolver para que la función identifique tanto mayúsculas como minúsculas. Pista: investigar los métodos lower y upper de string.\n\n\n\n\n\n\n\n\nTip: in y not in\n\n\n\n\n\n¿Conocés el uso de in?\nPara saber si un elemento está en una lista o en un string, podemos usar in y not in. Por ejemplo:\n\n'a' in 'hola'\n\nTrue\n\n\n\n'w' in 'hola'\n\nFalse\n\n\n\n'w' not in 'hola'\n\nTrue\n\n\n\n'casa' in ['cama', 'mesa', 'silla']\n\nFalse\n\n\n\n\n\n\nEscribir funciones que resuelvan los siguientes problemas:\n\nDado un año, que devuelva si es bisiesto. Nota: un año es bisiesto si es un número divisible por 4, pero no si es divisible por 100, excepto que también sea divisible por 400.\nDado un mes y un año, que devuelva la cantidad de días correspondientes.\nPedirle al usuario su día y mes de cumpleaños. El programa debe imprimir un mensaje indicando a qué signo corresponde el usuario.\n\nAries: 21 de marzo al 20 de abril.\nTauro: 21 de abril al 20 de mayo.\nGéminis: 21 de mayo al 21 de junio.\nCáncer: 22 de junio al 23 de julio.\nLeo: 24 de julio al 23 de agosto.\nVirgo: 24 de agosto al 23 de septiembre.\nLibra: 24 de septiembre al 22 de octubre.\nEscorpio: 23 de octubre al 22 de noviembre.\nSagitario: 23 de noviembre al 21 de diciembre.\nCapricornio: 22 de diciembre al 20 de enero.\nAcuario: 21 de enero al 19 de febrero.\nPiscis: 20 de febrero al 20 de marzo.\nPiedra, papel o tijera: escribir un programa de “Piedra, papel o tijera” tal que sea imposible que el usuario gane. El usuario debe ingresar R (piedra), P (papel), o T (tijera) y la computadora debe siempre ganarle. Las ejecuciones son individuales: el usuario sólo ingresa una sola vez su jugada, el programa le gana, y la ejecución termina.\nEjemplo 1 de Ejecución:\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: R\n¡Papel! ¡Gané!\nEjemplo 2 de Ejecución:\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: P\n¡Tijera! ¡Gané!\nEjemplo 3 de Ejecución:\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: T\n¡Piedra! ¡Gané!\nEjemplo 4 de Ejecución:\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: M\nEsa jugada no está disponible.\nSuponiendo que el primer día del año fue lunes, escribir una función que reciba un número con el día del año (de 1 a 366) y devuelva el día de la semana que le toca. Por ejemplo: si se recibe ‘3’, debe devolver “miércoles”, y si se recibe ‘9’, debe devolver “martes”.\n\n\n\n2. Ciclos\n\nEscribir función que:\n\nImprima por pantalla todos los números entre 10 y 20.\nSalude a todas las personas de esta lista [Flaminia, Serena, Agustina, Priscila, Sol, Agostina, Iara, Lu] con el mensaje \"Hola &lt;nombre&gt;! Vamos a aprender a programar\".\nLe pida al usuario que ingrese 5 números y le muestre la suma total de todos ellos.\nImprima por pantalla todos los números entre 100 y 199 que sean divisibles por 7.\nReciba dos números, y recorra todos los números entre ellos, imprimiendo en pantalla si es par o impar. Por ejemplo, recibiendo 1 y 3, debe imprimir:\n\n1 es impar\n2 es par\n3 es impar\nSe quiere hacer un programa para enseñar a los niños las tablas de multiplicar del 1 al 10. Crear una función que reciba un número e imprima por pantalla la tabla de multiplicar de ese número. Ejemplo:\nmostrar_tablas_para(1)\ndebe imprimir:\n1 x 1 = 1\n1 x 2 = 2\n1 x 3 = 3\n1 x 4 = 4\n1 x 5 = 5\n1 x 6 = 6\n1 x 7 = 7\n1 x 8 = 8\n1 x 9 = 9\n1 x 10 = 10\nmostrar_tablas_para(-2)\ndebe imprimir:\nError: El número debe ser positivo y estar entre 1 y 10\nCrear una función que cante el feliz cumpleaños. Dado un entero, debe imprimir ‘Que los cumplas feliz’ en distintas líneas por esa cantidad de veces.\n\nNecesitamos escribir un programa de cobro en el supermercado. La función debe recibir un número entero que representa el monto a pagar y debe permitir al usuario que ingrese valores, hasta que el pago se haya realizado en su totalidad. Además, le debe ir indicando cuánto le queda por pagar. El programa no da vuelto.\n\nEjemplo:\nSu total a pagar es: 500\nIngrese el monto a pagar: 100\nPendientes: 400. Ingrese el monto a pagar: 200\nPendientes: 200. Ingrese el monto a pagar: 200\nPendientes: 0. Gracias por su compra.\n\nHacer que el programa anterior dé vuelto:\n\nEjemplo:\nSu total a pagar es: 500\nIngrese el monto a pagar: 100\nPendientes: 400. Ingrese el monto a pagar: 200\nPendientes: 200. Ingrese el monto a pagar: 300\nPendientes: 0. Su vuelto es: 100. Gracias por su compra.\nEscribir un programa que le pida al usuario que ingrese un número. Para ese número, se imprime la tabla de multiplicar del 1 al 10. Luego, se le vuelve a pedir otro número. Si el usuario ingresa “X”, el programa debe terminar. El usuario debe poder ingresar números indefinidamente hasta que ingrese “X”. Se puede reutilizar la función del ejercicio 9 de esta guía.\nEjemplo:\nHola! Esto es Tablas de Multiplicar\nIngrese un número o \"X\" para salir: 1\n1 x 1 = 1\n1 x 2 = 2\n1 x 3 = 3\n1 x 4 = 4\n1 x 5 = 5\n1 x 6 = 6\n1 x 7 = 7\n1 x 8 = 8\n1 x 9 = 9\n1 x 10 = 10\nIngrese un número o \"X\" para salir: -2\nError: El número debe ser positivo y estar entre 1 y 10\nIngrese un número o \"X\" para salir: X\n¡Adios!\nManejo de contraseñas\n\nEscribir un programa que contenga una contraseña inventada, que le pregunte al usuario la contraseña, y no le permita continuar hasta que la haya ingresado correctamente.\nModificar el programa anterior para que solamente permita una cantidad fija de intentos.\nModificar el programa anterior para que sea una función que devuelva si el usuario ingresó o no la contraseña correctamente, mediante un valor booleano (True o False).\n\n\nHacer una función que reciba un número del 1 al 10, y luego permita al usuario poder adivinar ese número, ingresando valores repetidamente. Para cada ingreso del usuario, el programa debe indicarle si su número es menor o mayor al número a adivinar. Una vez que el usuario ingresa el número correcto, lo felicita y termina.\nRepetir permitiendo únicamente 3 intentos.\nRepetir generando el número aleatoriamente de la siguiente forma dentro de la función, sin recibirlo por parámetro:\n\n\n\nimport random\nnumero_a_adivinar = random.randint(1, 10)\nprint(numero_a_adivinar)\n\n5\n\n\n\n\n\n\n\n\nTip: Bibliotecas\n\n\n\n\n\n¿Sabías que Python tiene muchas bibliotecas que podés usar para hacer cosas más complejas? Por ejemplo, la biblioteca random tiene funciones para generar números aleatorios. También hay otras bibliotecas como Pandas para trabajar con datos, Matplotlib para hacer gráficos, Numpy para trabajar con matrices, y muchas más. Vamos a estar viendo estas tres en la última unidad de la materia.\nUna biblioteca es un conjunto de funciones que alguien más escribió y que podemos usar en nuestros programas. Para usar una biblioteca, primero tenemos que importarla. Por ejemplo, para usar la biblioteca random, tenemos que poner import random al principio de nuestro programa (arriba de todo en nuestro archivo). Luego, podemos usar las funciones de la biblioteca, como random.randint(1, 10).\n\n\n\n\n\nQueremos modelar una máquina de sacar juguetes. Debemos hacer una función que reciba un número que representa la cantidad de fichas \\(x\\) que necesita la máquina para funcionar. Se debe imprimir un mensaje en pantalla que indique “Ingresá \\(x\\) fichas para comenzar”. El usuario deberá ingresar entonces letras “F”, que representan a las fichas. Notar que si se ingresa algo distinto a “F”, se ignora.\n\nSe debe seguir solicitando fichas siempre que no se haya alcanzado la cantidad necesaria para funcionar. Cuando se haya alcanzado la cantidad necesaria, se debe imprimir un mensaje que indique “¡A jugar!”. Ejemplo:\nIngresá 2 fichas para comenzar: F\nIngresá 2 fichas para comenzar: B\nIngresá 2 fichas para comenzar: Hola\nIngresá 2 fichas para comenzar: F\n¡A jugar!\n\nModificar el programa anterior para que vaya mostrando la cantidad de fichas que faltan para comenzar a jugar. Ejemplo:\n\nIngresá 2 fichas para comenzar: F\nIngresá 1 fichas para comenzar: B\nIngresá 1 fichas para comenzar: ficha\nIngresá 1 fichas para comenzar: F\n¡A jugar!\nCrear una función que calcule si un número es primo o no. Un número es primo cuando solamente es divisible por sí mismo y por 1. Pista: usar el operador módulo %.\nDesafío (obligatorio): Crear una función que reciba un número entero e imprima los números primos entre 1 y el número ingresado.\nDesafío (obligatorio):\n\nCrear una función que reciba dos números, y devuelva la suma de todos los números múltiplos de 7 entre esos dos números. Por ejemplo, si recibe 3 y 25, debe devolver 7 + 14 + 21 = 42. Si recibe 3 y 4, debe devolver 0, ya que no hay múltiplos de 7 entre esos dos números.\nRepetir calculando el promedio en vez de la suma.\nRepetir calculando únicamente el promedio entre los primeros 3 múltiplos de 7 encontrados. Pista: usar break.\nRepetir calculando únicamente el promedio entre los múltiplos de 7 encontrados que no sean múltiplos de 2. Pista: usar continue.\n\nDesafío (obligatorio):\n\nEscribir una función que dada la cantidad de ejercicios de un examen, y el porcentaje de ejercicios bien resueltos necesario para aprobar dicho examen, revise un grupo de exámenes.\n\nPara ello, en cada paso debe preguntarle al usuario la cantidad de ejercicios resueltos por el alumno, o pedirle que ingrese “*” para salir. Debe mostrar por pantalla el porcentaje correspondiente a la cantidad de ejercicios resueltos respecto a la cantidad de ejercicios del examen y una leyenda que indique si aprobó o no.\n\nAdicional al punto anterior: imprimir un mensaje informándole al usuario la cantidad de ejercicios y el % de aprobación.\nValidar que el usuario siempre ingrese números positivos y menor o iguales a la cantidad de ejercicios del examen, o “*“. De lo contrario, mostrar un mensaje de error y volver a pedirle el dato al usuario.",
    "crumbs": [
      "Guía de Ejercicios"
    ]
  },
  {
    "objectID": "guia.html#guía-4-tipos-de-estructuras-de-datos",
    "href": "guia.html#guía-4-tipos-de-estructuras-de-datos",
    "title": "Guía de Ejercicios",
    "section": "Guía 4: Tipos de Estructuras de Datos",
    "text": "Guía 4: Tipos de Estructuras de Datos\n\n1. Cadenas de caracteres\n\nEscribir funciones que dada una cadena y un caracter:\n\nInserte el caracter entre cada letra de la cadena. Ejemplo: 'separar' y '-' debería devolver 's-e-p-a-r-a-r'.\n\nReemplace todos los espacios por el caracter. Ejemplo: 'mi archivo de texto.txt' y '_’ debería devolver 'mi_archivo_de_texto.txt'.\n\nReemplace todos los dígitos de la cadena por el caracter. Ejemplo: 'su clave es: 1540' y '*' debería devolver 'su clave es: ****'.\n\nInserte el caracter cada 3 dígitos en la cadena. Ejemplo: '2552552550' y '.' debería devolver '255.255.255.0'\nModificar todas las anteriores para que, adicionalmente, reciba un parámetro que indique la cantidad máxima de reemplazos o inserciones a realizar. Ejemplo: 'su clave es: 1540', '*' y 3 debería devolver 'su clave es: ***0'.\n\nEscribir una función que reciba una cadena que contiene un largo número entero y devuelva una cadena con el número y las separaciones de miles. Por ejemplo, si recibe 1234567890, debe devolver 1.234.567.890. Cuidado: no es lo mismo 123.456.789.0 que 1.234.567.890. Tienen que ser separaciones de miles y quedar un número válido.\nEscribir funciones que dada una cadena de caracteres:\n\nDevuelva la primera letra de cada palabra. Ejemplo: si se recibe Ciclo Básico Común se debe devolver CBC.\nIndique si se trata de un palíndromo. Por ejemplo, anita lava la tina es un palíndromo (se lee igual de izquierda a derecha que de derecha a izquierda).\n\nEscribir funciones que dadas dos cadenas de caracteres:\n\nIndique si la segunda cadena es subcadena de la primera. Por ejemplo, 'compu' es subcadena de 'computacional'.\nDevuelva la que sea anterior en orden alfábetico. Por ejemplo, si recibe 'kde' y 'gnome' debe devolver 'gnome'.\n\nEscribir una función que, dada una cadena de caracteres, devuelva una lista con cada uno de los caracteres que la componen en mayúscula. Ejemplo: 'Hola' debe devolver ['H', 'O', 'L', 'A']. Restricción: no se permite el uso de ciclos for/while. Pista: Buscá en el apunte cómo usar map.\nEscribir una función que, dada una cadena de caracteres, devuelva una tupla con cada uno de los caracteres que no es una vocal. Ejemplo: 'Algoritmos' debe devolver ('l', 'g', 'r', 't', 'm', 's'). Restricción: no se permite el uso de ciclos for/while.\nEscribir una función que, dada una cadena de caracteres, devuelva el número de índice de posición del último caracter. Por ejemplo, para la cadena 'Hola' debe devolver 3. Restricción: no se permite el uso de ciclos for/while.\nDesafío (obligatorio):\n\nSe quiere implementar un buscador dentro de un editor de texto, que permita encontrar todas las ocurrencias de una palabra en un texto. Para ello, se debe implementar una función que reciba como parámetro una palabra y un texto, y que devuelva la primer aparición de la palabra en el texto. Pista: index arrojará un error si la subcadena no se encuentra. ¿Qué otro método tenemos disponible para buscar subcadenas?\nModificar la función anterior para que devuelva una lista con las posiciones de inicio de cada ocurrencia de la palabra dentro del texto. Ejemplo: si se busca 'al' en 'calcule el precio al valor actual', debe devolver [1, 18, 22, 31]. Pista: del método usado en el punto anterior, ¿conocemos algún parámetro adicional que le podamos pasar?\nModificar la función anterior para que devuelva la cantidad de ocurrencias encontradas. Ejemplo: si se busca 'al' en 'calcule el precio al valor actual', debe devolver 4. Restricción: No se puede usar el método len.\n\nDesafío (no obligatorio): Escribir una función que reciba dos cadenas de caracteres y devuelva una lista con todos los caracteres que no tienen en común. Ejemplo: 'Python' y 'Hola' debería devolver el conjunto de letras ['P', 'y', 't', 'l', 'a', 'n'], indiferentemente del orden y de si está en mayúscula o minúscula. Nota: para que un caracter esté en la lista, no es necesario que esté en la misma posición.\n\n\n\n2. Rangos, Tuplas y Listas\n\nUsar un rango para:\n\nImprimir los números del 10 al 50 inclusive, saltando de 5 en 5.\nImprimir los números del 40 al 20 en orden decreciente, saltando de 2 en 2.\nCrear una lista con los números del 4 al 10. Luego, acceder con el índice a los elementos que contienen a los números 4, 6 y 9 e impimirlos por pantalla. Pista: recordar que los índices comienzan en 0.\n\nEscribir una función que reciba:\n\nUna lista y devuelva True si su longitud es par y False si su longitud es impar.\n\nUna lista de números cualesquiera y devuelva el elemento máximo y el mínimo.\nUna lista de números y devuelva otra lista con los mismos números ordenados de menor a mayor. Por ejemplo, si recibe [5, 10, 7, 3] debe devolver [3, 5, 7, 10].\n\n\nEscribir una función que reciba una lista de nombres y un número, que representa el cupo. La función debe devolver en una lista a los nombres que no pudieron entrar al curso por falta de cupo. Ejemplo: chequear_cupo(['Agustina', 'Iara', 'Priscila', 'Sol', 'Lucía'], 3) debe devolver ['Sol', 'Lucía'].\nModificar la función anterior para que devuelva únicamente a la última persona de la lista de la gente que pudo entrar. Ejemplo: chequear_cupo(['Agustina', 'Iara', 'Priscila', 'Sol', 'Lucía'], 3) debe devolver 'Priscila', porque es la última que tuvo cupo.\n\nDada la lista de tuplas [(\"Argentina\", 3), (\"España\",1), (\"Uruguay\", 2), (\"Francia\",2)], donde cada tupla contiene un país y la cantidad de mundiales que ganaron:\n\nHacer una función que reciba la lista por parámetro e imprima la información de cada país con el siguiente formato:\n\nPaís: &lt;nombre&gt; - Copas: &lt;cantidad&gt;\nSi y sólo si el país es “Argentina”, se debe imprimir el nombre con 3 estrellas: \"Argentina⭐⭐⭐\". Usar el operador abreviado +=.\n\nHacer una función que reciba la lista por parámetro y devuelva la cantidad de mundiales que ganaron entre todos los países. Ejemplo: contar_mundiales([(\"Argentina\", 3), (\"España\",1), (\"Uruguay\", 2), (\"Francia\",2)]) debe devolver 8.\nHacer una función que reciba la lista por parámetro y la devuelva, ordenada por cantidad de copas ganadas.\nHacer una función que reciba la lista por parámetro y devuelva en una tupla: una lista con los países que tienen más de una copa ganada, y otra lista con valores booleanos que nos diga si la cantidad de copas es par o impar. Pista: ¿Cómo podemos usar filter? ¿Y map?\nEjemplo: [(\"Argentina\", 3), (\"España\",1), (\"Uruguay\", 2), (\"Francia\",2)] devuelve:\n([(\"Argentina\", 3), (\"Uruguay\", 2), (\"Francia\",2)] , [False, True, True])\n\nEscribir una función que reciba dos fichas de dominó y determine si encajan o no entre sí.\n\nResolver teniendo en cuenta que las fichas se reciben con formato de tuplas. Ejemplo: (3,4) y (5,4).\nResolver teniendo en cuenta que las fichas se reciben con formato de string. Ejemplo: '3-4' y '5-4'.\n\nEscribir una función que reciba dos vectores y devuelva su prod_escalar. El prod_escalar se calcula como: Siendo \\(v1 = (v1_1, v1_2, ..., v1_n)\\) y \\(v2 = (v2_1, v2_2, ..., v2_n)\\), entonces\n\\[v1 \\cdot v2 = (v1_1 \\cdot v2_1) + (v1_2 \\cdot v2_2) + ... + (v1_n \\cdot v2_n)\\] Si los vectores no tienen las mismas dimensiones, la función debe devolver None.\n\nEscribir una función que reciba una tupla, un índice, y un nuevo valor. La función debe modificar la tupla, cambiando el valor en la posición dada por el índice, por el nuevo valor pasado como parámetro. Devolver la tupla modificada.\nRepetir el ejercicio anterior, pero con una lista.\nRepetir ambos si ahora, en vez de recibir un índice, se recibe el valor a eliminar. Si no se contiene al valor, se devuelve la estructura tal cual se recibió.\n\nEscribir una función que reciba una lista y un número \\(n\\). Para dicho número \\(n\\), debe imprimir los últimos \\(n\\) elementos de la lista en orden inverso, y luego devolver la lista sin ellos. Ejemplo: Si se recibe [1, 2, 3, 4, 5] y n = 2, debe imprimir 5, 4 y devolver [1, 2, 3].\nEscribir una función que reciba una lista de números y devuelva la misma lista en orden inverso.\nEscribir una función que dado un valor \\(n\\), devuelva una lista con los números del 1 a \\(n\\).\nEscribir una función que reciba una matriz y una tupla (fila, columna), y devuelva el valor ubicado en esa posición de la matriz. Ejemplo: si se recibe la matriz [[1, 2], [3, 4]] y la tupla (0, 1), debe devolver 2.\nSe tiene una lista de supermercado escrita como string con productos separados por coma: \"pan, arroz, pescado, jugo, fideos,...\".\n\nEscribir una función que reciba la cadena de caracteres de los productos de supermercado y devuelva una lista con cada uno de los productos por separado: ['pan', 'arroz', 'pescado', 'jugo', 'fideos', ...].\nSe tiene además otra cadena de caracteres con los precios de cada producto: \"100, 50, 200, 80, 30,...\". Escribir una función que reciba ambas cadenas y devuelva una lista con tuplas de (producto, precio): [('pan', 100), ('arroz', 50), ('pescado', 200), ('jugo', 80), ('fideos', 30), ...].\nPara la función del punto anterior, escribir otra función que reciba la lista de tuplas y devuelva el precio total de la lista de compras.\n\nSe quiere crear una lista de supermercado, solicitándole al usuario productos hasta que ingrese el valor ‘X’. La función debe devolver los productos en un string, separados por comas. Ejemplo: si se ingresa ‘pan’, ‘arroz’, ‘pescado’, ‘X’, debe devolver \"pan, arroz, pescado\".\nHacer una función que reciba una lista de palabras, las ordene en orden alfabético y luego las una en un string separadas por espacios. Ejemplo: si recibe ['hola', 'como', 'estas'], debe devolver \"como estas hola\".\nDesafio (obligatorio): Escribir una función que reciba un tamaño y devuelva una matriz con 1 en la diagonal principal y 0 en el resto. Ejemplo: si recibe 4, debe devolver la matriz identidad de tamaño 4x4. \\[\n\\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n\\end{bmatrix}\n\\]\nDesafio (obligatorio): Escribir una función que reciba una matriz y devuelva su transpuesta. Ejemplo: si recibe la matriz [[1, 2, 3], [4, 5, 6]], debe devolver [[1, 4], [2, 5], [3, 6]].\nSi se recibe: \\[\n\\begin{bmatrix}\n1 & 2 & 3  \\\\\n4 & 5 & 6  \\\\\n\\end{bmatrix}\n\\]\nSe debe devolver:\n\\[\n\\begin{bmatrix}\n1 & 4 \\\\\n2 & 5 \\\\\n3 & 6 \\\\\n\\end{bmatrix}\n\\]\nDesafio (no obligatorio): Agenda Simplificada\nEscribir una función que reciba una cadena a buscar y una lista de tuplas (nombre_completo, telefono), y busque dentro de la lista todas las entradas que contengan en el nombre completo la cadena recibida (puede ser el nombre, el apellido o sólo una parte de cualquiera de ellos). Debe devolver una lista con todas las tuplas encontradas.\nDesafio (no obligatorio): Sistema de facturación simplificado.\nSe cuenta con una lista ordenada de productos con tuplas de (identificador, descripción, precio), y una lista de los productos a facturar, con tuplas de (identificador, cantidad).\nSe desea generar una factura que incluya la cantidad, la descripción, el precio unitario y el precio total de cada prod_comprado, y al final imprima el total general.\nEscribir una función que reciba ambas listas e imprima por pantalla la factura solicitada.\nSuper Desafio (no obligatorio): Batalla Naval\n\nSe tiene una matriz de 10x10 que representa un tablero. Cada celda contiene un 0 si está vacía, o un 1 si hay un barco (consideramos que en este caso, sólo hay barcos unitarios que ocupan un espacio).\nLa posición de los barcos se representa con tuplas de (fila, columna). Por ejemplo, si se tiene un barco en la fila 1, columna 3, se representa con la tupla (1, 3).\nEscribir una función que cree un tablero con 10 barcos ubicados aleatoriamente (usar la biblioteca random), y que permita al usuario intentar adivinar dónde están.\nEl usuario luego ingresa una posición, y la máquina indica si había un barco en esa posición (mostrando un mensaje por pantalla “¡Hundido!”) o no (“¡Agua!”).\nEl usuario gana cuando hunde todos los barcos del tablero. Si se equivoca más de 5 veces, pierde.\n\n\n\n\n\n\nBatalla Naval: Modo Supervivencia\n\n\n\n\n\n¿Te animás a que el juego sea un ida y vuelta? Es decir, que el usuario también pueda poner barcos y la máquina intente adivinar dónde están. Una posibilidad es que el usuario tenga su propio tablero en un papel, y una vez cada uno, la máquina y el usuario elijan una posición para atacar.\nTe dejamos unos tips:\n\nLas posiciones son limitadas por el tablero 10x10\nLas posiciones no deberían repetirse\n\n¿Se te ocurre una forma fácil de generar y guardar todas las posiciones posibles del tablero, e ir sacando de a una para que no se repitan? ¿Quién pensás que ganaría, la máquina o el usuario? En este caso, el usuario y la máquina tienen intentos ilimitados intercalados hasta que alguno de los dos gane.\n\n\n\nSe tiene una base de datos con nombres de libros de la siguiente forma [\"La Noche de la Usina\", \"La Pregunta de sus Ojos\", \"Ser Feliz era Esto\",...], y se quiere saber cuántos libros repetidos tienen. Escribir una función que reciba la base de datos y devuelva, para cada uno de los títulos, cuántos ejemplares hay. La lista no tiene un tamaño fijo, y puede contener muchos títulos repetidos.\nPista: tenés que usar un diccionario.\n\n\n\n3. Diccionarios\n\nEscribir una función que reciba una lista de tuplas, y que devuelva un diccionario en donde las claves sean los primeros elementos de las tuplas, y los valores una lista con los segundos. Por ejemplo:\n\nl = [('Hola', 'don Pepito'), ('Hola', 'don Jose'), ('Buenos', 'días')]\nprint(tuplas_a_diccionario(l))\n{'Hola': ['don Pepito', 'don Jose'], 'Buenos': ['días']}\n\nEscriba una función que reciba una cadena y devuelva:\n\nUn diccionario con la cantidad de apariciones de cada palabra en la cadena. Por ejemplo, si recibe \"Que lindo dia que hace hoy\" debe devolver: {'que': 2, 'lindo': 1, 'dia': 1, 'hace': 1, 'hoy': 1}.\nUn diccionario con la cantidad de apariciones de cada caracter en la cadena.\n\nEscribir una función que reciba una cantidad de iteraciones N.\n\nSe deberá simular una persona que tira un dado N veces, y se deberá devolver un diccionario con la cantidad de apariciones de cada valor en el dado. Nota: para simular una tirada, usar import randomy random.randint(1, 6).\nRepetir el punto anterior, si ahora en vez de tirar 1 dado, tira 2. Se debe devolver un diccionario con la cantidad de apariciones de cada valor de la suma de ambos dados.\n\nSe tiene una agenda implementada como diccionario, que guarda nombres de personas y sus números de teléfono. Escribir un programa que le pida al usuario que ingrese nombres.\n\nSi el nombre se encuentra en la agenda, debe mostrar el teléfono.\nSi el nombre no se encuentra, debe permitir ingresar el teléfono correspondiente.\n\nEn ambos casos, El usuario puede utilizar la palabra “EXIT” para dejar de ingresar nombres.\nEscribir una función que reciba un texto y para cada caracter presente en el texto, devuelva la palabra más larga en la que se encuentra ese caracter.\nNos contratan para hacer un nuevo sistema de FIUBA para almacenar información de sus estudiantes:\n\n\n\nnombre\napellido\ndni\ncarrera\n\n\n\n\nVioleta\nPerez\n42000000\nInformática\n\n\nCarla\nGuanca\n42001001\nMecánica\n\n\nManuela\nGomez\n42002002\nQuímica\n\n\n\n\nCrear un diccionario que sirva para representar a cada persona. Debe contener las claves nombre, apellido, dni y carrera. Los diccionarios se deben guardan en una lista llamada estudiantes.\nAgregar al diccionario creado un nuevo elemento, que debe ser otro diccionario y represente las notas obtenidas en la carrera. La clave debe ser el codigo y el valor la nota (del 1 al 10) obtenida.\nCrear código que agregue para la estudiante Violeta Perez la nota 7 en la materia Algoritmos y Programación III (7507), y la nota 4 en la materia Análisis Matemático II (6103).\nTeniendo la lista de estudiantes, buscar en la lista la persona con mayor cantidad de notas e imprimirla por pantalla.\n\nEn un vivero se guardan las plantas en una lista de diccionarios con la siguiente información: especie, luz directa (si/no), precio. Se necesita un sistema que guarde las plantas a medida que van llegando. Hacer una función que reciba la lista de diccionarios de plantas, y los datos de la planta nueva, y agregue esa planta a la lista de diccionarios.\nEscribir una función que reciba una lista de diccionarios y una clave, y devuelva una lista con los valores correspondientes a esa clave.\nSe tiene un ticket de supermercado en forma de diccionario con los siguientes datos:\n\nNombre del Producto\nPrecio por Unidad\nCantidad\n\nSe pide hacer una función que reciba el ticket y devuelva el monto a pagar total.\nRosita tiene una lista de diccionarios donde guarda todas las películas que vió. La información para cada una es: el nombre de la película, año en que salió, y la puntuación que le puso del 1 al 10. Hacer una función que reciba el diccionario y devuelva una nueva lista de diccionarios donde sólo estén las películas que tienen puntaje mayor a 7.\n\nResolver sin usar filter\nResolver usando filter.\n\nLa profesora Llamell guarda las notas del parcial de Pensamiento Computacional en una lista de diccionarios. Cada diccionario tiene la siguiente información: nombre, apellido, intento, nota.\nLos intentos pueden ser 1 (si es la primera vez que rinde el parcial) o 2 (si está en el recuperatorio).\n\nSe pide hacer una función que dada esta lista de diccionarios, se devuelva el promedio de las notas en la primera oportunidad de los alumnos.\nGeneralizar la función anterior, para que también reciba el número de intento y se pueda devolver el promedio de cualquiera de los dos intentos.\n\nEn una fábrica se tiene una base de datos donde se guardan todos los códigos de los productos que se fabrican como claves de un diccionario. Los valores de cada clave son nuevos diccionarios, con la siguiente información: fecha de vencimiento (mes,año), si pasó el chequeo de calidad o no.\nSe pude hacer una función que reciba esta lista de diccinoarios, y elimine a todos los productos que no pasaron el chequeo de calidad. Devolver en una tuple todos los productos eliminados en formato {codigo: diccionario del producto}.\nSe quiere guardar información de un grupo de maratonistas. Se necesita guardar su nombre, DNI y todas las maratones que corrió. Para esto último, se guardan: nombre de cada una, año, puesto y el tiempo que tardaron en correrlas (en minutos).\n\nCrear un diccionario de ejemplo que represente esta situación.\nTeniendo esta lista de diccionarios, ordenarlos alfabéticamente por el nombre de los maratonistas.\nTeniendo esta lista de diccionarios, ordenar las maratones en tiempo ascendente según el tiempo que tardaron en correrlas.\n\nDesafío (obligatorio): Laura tiene una lista de diccionarios donde guarda el valor de todas las reviews laborales anuales que le hicieron. La información de cada una es año, seniority en ese momento (trainee, junior, semisenior, senior), el sueldo en ese momento y el valor del bono de performance que le dieron. La semana pasada le avisaron que por políticas de la empresa, los bonos ahora deben calcularse como un porcentaje de su sueldo.\nLaura quiere entonces actualizar sus diccionarios, para que en vez de guardar el monto exacto del bono, guarde el porcentaje que le corresponde. Ejemplo: si en el 2019 su sueldo era de $1.000.000 y el bono que le dieron era de $40.000, el bono fue del 4% del sueldo.\n\nHacer una función que reciba la lista de diccionarios, y para cada una de las reviews, modifique el valor del bono por el porcentaje correspondiente.\nHacer una función que reciba la lista de diccionarios ya modificada y devuelva los años en los que Laura tuvo un bono mayor al 50% de su sueldo. Restricción: usar filter y map.\n\nDesafío (obligatorio): Los estudiantes de la materia Pensamiento Computacional quieren crear un programa que les facilite la cursada. Uno de los problemas es que no se tiene fácil acceso a los enunciados de los ejercicios, porque la guía es larga y hay que scrollear mucho. En el programa, la guía de ejercicios se guarda en un diccionario, donde cada clave es el número de guía y cada valor una lista con los enunciados de los ejercicios, cada uno en su posición correspondiente (la posición 0 de la lista sólo guarda None). Se quiere que el usuario que está usando el programa pueda acceder por pantalla a un enunciado puntual de una guía con sólo pedirlo (si existe). Para el problema mencionado, hacer una función o más que lo resuelva. Usar los temas visto en la materia hasta el momento, en la forma que se considere mejor y siguiendo las buenas prácticas y convenciones enseñadas.\nDesafío (no obligatorio): Donarg (https://www.donarg.com.ar/) es un proyecto que nació con estudiantes de FIUBA con el fin de optimizar procesos tanto para donantes de sangre como para hospitales y servicios de hemoterapia. Formado por estudiantes y graduados universitarios comprometidos, fue galardonado con el primer puesto en la FIUBATON 2020 “Desafío Cuarentena” del FIUBA Consulting Club, destacándose entre más de 100 proyectos.\nDonarg necesita un sistema que permita filtrar una base de datos de posibles donantes de sangre, quedándose con los que cumplen los requisitos.\nLa base contiene los siguientes datos de cada posible donante:\n\nNombre\nApellido\nEdad\nPeso\nFecha de la última donación. Puede ser ‘None’ si nunca donó. Formato: (dia,mes,año)\nFecha del último tatuaje. Puede ser ‘None’ si no tiene tatuajes. Formato: (dia,mes,año)\nTipo de sangre. Puede ser ‘0+’, ‘0-’, ‘A+’, ‘A-’, ‘B+’, ‘B-’, ‘AB+’, ‘AB-’\n\nLos requisitos son:\n\nTener entre 16 y 65 años\nPesar más de 50 kilos\nQue hayan pasado 2 meses desde la última donación\nQue hayan pasado 6 meses desde el último tatuaje\n\n\nSe pide hacer una función que reciba una lista de diccionarios con la información de cada posible donante, y devuelva una lista con los que cumplen los requisitos.\nSe pide hacer una función que priorice a los donantes que tienen sangre tipo 0 (positivo y negativo) por sobre todos los A, B y AB (positivos y negativos); ya que son los que más se necesitan. La función debe recibir la lista de diccionarios con la información de cada posible donante ya filtrada por requisitos, y devolver una nueva lista ordenados de mayor a menor prioridad.\nSe pide hacer una función que reciba la lista de diccionarios con la información de cada posible donante ya filtrada por requisitos y ordenada por prioridad, que se quede con los que son 0+ y 0-, y los ordene por órden alfabético de apellido.\n\n\n\nSi querés saber más sobre el proyecto, podés visitar su página web:\nhttps://www.donarg.com.ar/\no sacar turno para donar sangre en\nhttps://www.donarg.com.ar/dondedono.",
    "crumbs": [
      "Guía de Ejercicios"
    ]
  },
  {
    "objectID": "guia.html#guía-5-entrada-y-salida",
    "href": "guia.html#guía-5-entrada-y-salida",
    "title": "Guía de Ejercicios",
    "section": "Guía 5: Entrada y Salida",
    "text": "Guía 5: Entrada y Salida\n\n1. Archivos\n\nEscribir una función llamada contar (o count) que dado un archivo retorne la cantidad de filas que tiene.\nEscribir una funcion llamada imprimir(o cat) que dado un archivo imprima por pantalla todo el contenido.\n\nAgregar un parametro a la funcion llamado ignorar_vacias (o blank) que en caso de ser True, no se impriman las lineas en blanco.\n\nEscribir una función llamada ver_encabezado (o head) que dado un archivo y un número N retorne en una lista las primeras N lineas del archivo.\nEscribir una función llamada ver_final (o tail) que dado un archivo y un número N retorne en una lista las últimas N lineas del archivo.\nEscribir una función llamada crear (o touch) que dado el nombre de un archivo lo cree. Si el archivo exixte borra todo el contenido.\nEscribir una función, llamada wc, que dado un archivo de texto, lo procese e imprima por pantalla cuántas líneas, cuantas palabras y cuántos caracteres contiene el archivo.\nEscribir una función, llamada grep, que reciba una cadena y un archivo de texto, e imprima las líneas del archivo que contienen la cadena recibida.\nSe tiene un archivo con una pregunta, llamado pregunta.txt. Se pide leerlo y mostrar el contenido en consola. Luego, pedirle al usuario una respuesta, y guardarla en un archivo llamado respuesta.txt.\nSea un diccionario cuyas claves y valores son cadenas.\n\nEscribir una función guardar_diccionario que reciba el diccionario y un nombre de archivo, y guarde el contenido del diccionario en el archivo, en formato CSV, con un par clave-valor por línea.\nEscribir una función cargar_diccionario que reciba el nombre de un archivo con el formato mencionado en el punto anterior, y devuelva el diccionario original.\n\nDesafio (obligatorio): Distribución de Carga\nSe tiene una base de datos en formato CSV con resultados de partidos de futbol. Como el archivo es muy grande, se quiere distribuir la base en varios archivos más pequeños. El formato del archivo es el siguiente:\nlocal;visita;goles_local;goles_visita;gano;penales\nreal madrid;boca juniors;1;2;visita;N\nA.C. Milan; boca juniors;1;1;visita;S\n.\n.\n.\nUtilizando las funciones de los ejercicios 1 a 7, procesar el archivo: Se desea que el archivo original se separe en archivos resultantes de no mas de 10 lineas, además no tienen que quedar filas en blanco. Por ejemplo si el archivo original tiene 100 lineas de las cuales 20 están en blanco, el resultado del procesamiento tienen que ser 8 archivos de 10 lineas cada uno. El tamaño del archivo original puede variar en cada ejecución.\nLa señora Rowling sospecha que su vecino le robo algunos manuscritos y los publicó como propios con algunas modificaciones. Se desea procesar una lista de archivos y guardar en un archivo llamado reporte_plagio.txt la siguiente información:\narchivo;palabras;apariciones\narchivo1.txt;765030;547\n\narchivo: es el nombre del archivo que se proceso.\npalabras: es la cantidad de palabras de ese archivo.\napariciones: es la cantidad de veces que aparece una palabra especificada.\n\nEn ejemplo de uso podría ser:\narchivos = [\"archivo1.txt\", \"archivo2.txt\"]\nprocesar_archivos(archivos, \"harry\")\nEn procesar_archivos se tiene que analizar los archivos y dejar el resultado en reporte_plagio.txt\nHacer una función que reciba un archivo y dos palabras: una que se quiere reemplazar, y otra por la que se quiere reemplazar. La función debe modificar el archivo reemplazando todas las apariciones de la primera palabra por la segunda.\nSe tiene un archivo CSV que contiene información sobre el stock de una librería.\nUn posible ejemplo de este archivo es el siguiente: \n    lapiceras;34512;50;120\n    cuadernos;41611;500;130\n    sacapuntas;62812;30;210\nDonde cada línea representa un prod_y contiene el nombre del producto, el código de barras, la cantidad en stock y el precio unitario. Hacer una función que le solicite al usuario datos de un nuevo prod_y lo agregue al final del archivo. Debe seguir pidiéndole al usuario datos de productos hasta que este ingrese como prod_“X”.\nEn un cine tienen dos archivos .txt, uno con salas y otro con nombres de películas. Se sabe que en la sala de una fila del archivo se va a transmitir la película de la misma fila del archivo de películas. Se pide leer los dos archivos, y crear un nuevo archivo csv que tenga el nuevo formato sala;pelicula Por ejemplo si se tienen los siguientes archivos:\n\n(salas.txt)\nD2\nF1\nE4\n(peliculas.txt)\nMegamente\nThe Menu\nShrek\nEl nuevo archivo deberá quedar:\n(funciones.csv)\nD2;Megamente\nF1;The Menu\nE4;Shrek\nSe tiene un archivo con información de ventas de productos en un supermercado. El archivo tiene el siguiente formato:\nproducto;precio;cantidad;fecha\narroz;50;100;2021-01-01\nfideos;40;200;2021-01-01\narroz;50;100;2021-01-02\nfideos;40;200;2021-01-02\narroz;50;100;2021-01-03\nfideos;40;200;2021-01-03\nSe pide hacer una función que reciba el nombre del archivo y un producto, y devuelva el precio promedio de ese prod_en el archivo.\nSe tiene una lista de archivos y se quiere imprimir las primeras 5 líneas de cada uno. Si el archivo no existe, se lo debe crear e imprimir el mensaje: ‘el archivo {nombre} no existe. Se crea y deja vacío.’.\nDesafío (obligatorio): Los docentes de Pensamiento Computacional saben que los ejercicios de las primeras guías son cortitos de resolver, entonces les dicen a los estudiantes que “si el ejercicio tiene más de 5 líneas, probablemente haya que revisarlo”. Los estudiantes se lo toman muy literal, y quieren buscar la forma de chequear si un ejercicio que resolvieron tiene más de 5 líneas, pero sin contar a la firma de la función.\nEl ejercicio puede estar guardado en un archivo o en un string todo junto, lo que resulte más cómodo para su resolución. Además, quieren la posibilidad de poder pasar varios ejercicios juntos para ahorrar tiempo, y saber en cuáles se pasaron de las 5 líneas o si algun archivo (en caso de elegir esa forma de almacenamiento) no existe. Para el problema mencionado, hacer una función o más que lo resuelva. Usar los temas visto en la materia hasta el momento, en la forma que se considere mejor y siguiendo las buenas prácticas y convenciones enseñadas.\nDesafío (obligatorio): Los estudiantes del CBC pensaron que podía ser buena idea guardar los apuntes de todas las materias en un mismo archivo, para no marearse con tantos documentos diferentes. Pero terminó siendo un dolor de cabeza y es muy dificil encontrar las notas de cada materia. Para poder acceder facil a esa informacion, decidieron extraer del archivo original la informacion de las notas. Sabemos que a cada materia se le puso de título un hashtag, por ejemplo “#analisisMatematico”, y que la fila que contiene un título no contiene nada más. Lo que se quiere hacer es obtener un nuevo archivo CSV con el nombre de la sección/materia, la posición (número de línea) donde comienza la misma, y la posición donde termina. Para el problema mencionado, hacer una función o más que lo resuelva. Usar los temas visto en la materia hasta el momento, en la forma que se considere mejor y siguiendo las buenas prácticas y convenciones enseñadas.\n\n\n\n2. Manejo de Errores\n\nCrear una función que asegure la apertura de un archivo. Debe recibir un nombre y si el archivo existe, retorna el contenido archivo. Si no existe, imprime un mensaje descriptivo.\nEscribir una función que le pida al usuario que ingrese 5 números y le muestre la suma total de todos ellos. Si el valor ingresado no es un número, debe mostrar un mensaje de error y seguir pidiendo números.\nEscribir un programa que le pida números al usuario e imprima si son pares o impares. Si el usuario ingresa un valor que no es un número, el programa debe imprimir un mensaje de error y seguir pidiendo números. El programa termina cuando el usuario ingresa \"*\".\nUn climatólogo tiene archivos donde guarda las temperaturas promedio de la Ciudad de Buenos Aires de cada mes. Cada línea es un número que representa la temperatura promedio del día. Por ejemplo:\n25.5\n26.0\n24.5\n# etc\nComo el climatólogo es humano, a veces se equivoca y tipea cosas que no son números. Por ejemplo: 25p3 o 25.5.5. Se pide hacer una función que reciba el nombre del archivo y devuelva la temperatura promedio del archivo. Si en algún momento se encuentra con un valor que no es un número, debe ignorarlo y seguir con el resto de los valores.\nAl final de la ejecución, debe devolverse el valor promedio y el porcentaje de valores que no pudieron ser procesados respecto del total.\nCrea un programa que pueda procesar un archivo: por cada fila, se debe ejecutar la operacion de división dividendo/divisor y almacenar el resultado en un archivo llamado “resultados.csv”. Tener en cuenta que en el archivo se pueden encontar filas con errores de carga y que el divisor sea 0 o que no sean números, en tal caso en lugar de escribir el resultado escribir “Error en la fila X: {descripción específica del error}” donde X es la fila que tiene errores.\ndividendo;divisor\n83848;389\n8762;78\n.\n.\n.\nDesafio: Para la venta de entradas de un teatro se cuenta con un diccionario que contiene las filas: “A”, “B”, “C”… y en cada fila contiene una lista con las ubicaciones disponibles en forma de lista [\"L\",\"O\",\"O\",\"O\",\"L\",\"L\",\"L\"] donde “L” es libre y “O” es ocupada. \nEscribir una funcion que reciba el diccionario, la fila y la ubicación en ella, y reserve el asiento en caso de que este libre. Considerar que el tamaño de la lista de ubicaciones puede variar por fila. Si la fila o la ubicación no son correctas, mostrar un mensaje descriptivo. Si el asiento ya se encuentra ocupado, mostrar el mensaje: El asiento ya se encuentra ocupado.\nEjemplo\nsala = {\"A\":[\"L\",\"O\",\"O\",\"O\",\"L\",\"L\",\"L\"], \"B\": [\"L\",\"O\",\"O\",\"O\",\"L\"]}\nreservar_butaca(sala, \"A\", 0)\n# En este ejemplo la fila \"A\" deberia quedar [\"O\",\"O\",\"O\",\"O\",\"L\",\"L\",\"L\"]\nDesafio (obligatorio): Se tiene esta función, que recibe dos números y devuelve la división entre ellos:\ndef dividir(n1, n2):\n    return n1/n2\nLa función puede lanzar una excepción ZeroDivisionError si el segundo número es 0 (es decir, la ejecución va a terminar con un error).\n\nProbar usar la función de arriba, pasándole 5 y 0 como argumentos. ¿Qué pasa? ¿Cómo podrías modificar la función para evitar que el programa termine con un error? Considerar qué valor podría llegar a devolver la función si ocurre un error.\nSe pide hacer un programa que le pida al usuario dos números, y muestre el resultado de la división usando/invocando a la función dividir definida arriba. Si el usuario ingresa un 0 como segundo número, se debería mostrar un mensaje de error y retornar None.\nConsiderar ahora también que el usuario podría ingresar algo que no es un número. En ese caso, debe mostrar otro mensaje de error diferente, y seguir pidiendo números.\n\nDesafío (no obligatorio): El kiosko de la facultad quiere automatizar un letrero que tome datos de un programa y le cobre al estudiante.\nSe tienen dos diccionarios, uno con un código y el producto, y otro con el código y el precio de cada producto.\nopciones = {\n    1: \"hamburguesas\",\n    2: \"milanesas\",\n    3: \"gaseosa\",\n    4: \"alfajor\",\n    5: \"papas fritas\",\n    6: \"agua\"\n}\n\nvalores = {\n    1:1000,\n    2:1500,\n    3:500,\n    4:300,\n    5:600,\n    6:350\n}\nSe quiere hacer un programa que muestre la información de la siguiente forma en la pantalla:\n1. hamburguesas - $1000\n2. milanesas - $1500\n3. gaseosa - $500\n4. alfajor - $300\n5. papas fritas - $600\n6. agua - $350\nY le pida al usuario una opción y una cantidad. Luego, debe imprimir el total a pagar.\nSe debe considerar que el usuario podría ingresar una opción que no está en el diccionario, o ingresar una opción que no sea un número. El programa debe en esos casos imprimir un mensaje de error que sea descriptivo y terminar su ejecución.",
    "crumbs": [
      "Guía de Ejercicios"
    ]
  },
  {
    "objectID": "guia.html#numpy",
    "href": "guia.html#numpy",
    "title": "Guía de Ejercicios",
    "section": "1. Numpy",
    "text": "1. Numpy\n\nCrear un array de 20 números espaciados uniformemente entre 0 y 10. Luego, imprimir:\n\nLa dimensión\nLa forma\nEl tamaño\n\nCrear un array llamado “arr” con números enteros del 0 al 9. Luego:\n\nCambiar su forma de manera tal que tenga 2 filas y 5 columnas\nInsertar el valor 100 en la posición 3.\n\nPara el array x = np.arange(10), calcular:\n\ny = x^2\ny = 3x + 2\ny = 1/(x+1)\ny = log10(x)\n\nUsando el array y = 1/(x+1) del ejercicio anterior:\n\nCalcular la media de y.\nCalcular la diferencia entre y y su media\n\nRepetir el ejercicio 4.2.2 de la Guía 4:\n\nEscribir una función que reciba:\n\n\nUna lista y devuelva True si su longitud es par y False si su longitud es impar.\n\nUna lista de números cualesquiera y devuelva el elemento máximo y el mínimo.\n\nUna lista de números y devuelva otra lista con los mismos números ordenados de menor a mayor. Por ejemplo, si recibe [5, 10, 7, 3] debe devolver [3, 5, 7, 10].\n\n\nRepetir el ejercicio 4.2.6. de la Guía 4:\n\nEscribir una función que reciba dos vectores y devuelva su prod_escalar. El prod_escalar se calcula como: Siendo \\(v1 = (v1_1, v1_2, ..., v1_n)\\) y \\(v2 = (v2_1, v2_2, ..., v2_n)\\), entonces\n\\[v1 \\cdot v2 = (v1_1 \\cdot v2_1) + (v1_2 \\cdot v2_2) + ... + (v1_n \\cdot v2_n)\\] Si los vectores no tienen las mismas dimensiones, la función debe devolver None.\n\nRepetir el ejercicio 4.2.11 de la Guía 4:\n\nEscribir una función que reciba una matriz y una tupla (fila, columna), y devuelva el valor ubicado en esa posición de la matriz. Ejemplo: si se recibe la matriz [[1, 2], [3, 4]] y la tupla (0, 1), debe devolver 2.\n\nRepetir el ejercicio 4.2.15 de la Guía 4:\n\nDesafio (obligatorio): Escribir una función que reciba un tamaño y devuelva una matriz con 1 en la diagonal principal y 0 en el resto. Ejemplo: si recibe 4, debe devolver la matriz identidad de tamaño 4x4.\n\\[\n\\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n\\end{bmatrix}\n\\]\n\nRepetir el ejercicio 4.2.16 de la Guía 4:\n\nDesafio (obligatorio): Escribir una función que reciba una matriz y devuelva su transpuesta. Ejemplo: si recibe la matriz [[1, 2, 3], [4, 5, 6]], debe devolver [[1, 4], [2, 5], [3, 6]]. Si se recibe:\n\\[\n\\begin{bmatrix}\n1 & 2 & 3  \\\\\n4 & 5 & 6  \\\\\n\\end{bmatrix}\n\\]\nSe debe devolver:\n\\[\n\\begin{bmatrix}\n1 & 4 \\\\\n2 & 5 \\\\\n3 & 6 \\\\\n\\end{bmatrix}\n\\]\n\n\nUna persona quiere cercar el frente de su casa con alambre. Los postes se deben poner a 1 metro de distancia como mínimo entre sí. Hacer una función que reciba un número entero que sea la cantidad de metros a cubrir, y devuelva un array con la posición de los postes necesarios. Por ejemplo, si se reciben 5 metros, debe devolver: [0.   1.25   2.5   3.75   5.]\nSe va a realizar un concierto gratis en el Jardín Japonés, para lo cual se habilitó la reserva de asientos por internet. Por un error, las reservas se hicieron en una lista de 50 asientos, guardando el número de reserva si está ocupado o 0 sino: [1,2,3,0,7,6,4,0,0,8,9, ...].\nLos asientos en el Jardín Japonés se van a organizar en forma de matriz, teniendo 5 filas de 10 asientos cada uno. Se quiere transformar la lista de asientos en una matriz. Hacer una función que reciba la lista de asientos y devuelva la matriz de asientos organizada por filas.\nEjemplo: Si se recibe [1,2,3,0,7,6,4,0,0,8,9,10,0,13,11,12], se debe devolver: [[1,2,3,0,7,6,4,0,0,8],[9,10,0,13,11,12]].\nDesafio (no obligatorio): Se tiene una matriz de 10x10 que representa un tablero de Batalla Naval. Cada celda contiene un 0 si está vacía, o un 1 si no. Se pide hacer una función que cree un tablero con 10 barcos ubicados aleatoriamente (usar la biblioteca random).\n\nLuego, se debe hacer una función que reciba la matriz y permita al usuario intentar adivinar dónde están.\nPista: se puede extender/modificar el Super Desafio (no obligatorio) de Batalla Naval de la Guía 4.",
    "crumbs": [
      "Guía de Ejercicios"
    ]
  },
  {
    "objectID": "guia.html#pandas",
    "href": "guia.html#pandas",
    "title": "Guía de Ejercicios",
    "section": "2. Pandas",
    "text": "2. Pandas\n\n\n\n\n\n\nNote\n\n\n\nPara estos ejercicios, recomendamos usar Google Colab (ver apunte) y tener una celda por ejercicio.\n\n\nNos contratan para hacer un nuevo sistema de FIUBA para almacenar información de sus estudiantes.\nUsando el siguiente DataFrame:\n\nimport pandas as pd\ndata = {\n    'nombre': ['Violeta', 'Carla', 'Manuela', 'Lucia', 'Emilia', 'Mariana', 'Aldo'],\n    'apellido': ['Perez', 'Guanca', 'Gomez', 'Capon', 'Duzac', 'Szischik', 'Rastrelli'],\n    'dni': [42000000, 42001001, 42002002, 37010020, 40001002, 38090080, 38111222],\n    'año_nac': [1997, 1998, 1998, 1993, 2003, 1993, 1994],\n    'mail': ['vp@fi.uba.ar', 'cg@fi.uba.ar', None, None, None, 'ms@fi.uba.ar', 'ar@fi.uba.ar'],\n    'carrera': ['Informática', 'Mecánica', 'Química', 'Informática', 'Informática', 'Electrónica', 'Informática']\n}\n\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\nnombre\napellido\ndni\naño_nac\nmail\ncarrera\n\n\n\n\n0\nVioleta\nPerez\n42000000\n1997\nvp@fi.uba.ar\nInformática\n\n\n1\nCarla\nGuanca\n42001001\n1998\ncg@fi.uba.ar\nMecánica\n\n\n2\nManuela\nGomez\n42002002\n1998\nNone\nQuímica\n\n\n3\nLucia\nCapon\n37010020\n1993\nNone\nInformática\n\n\n4\nEmilia\nDuzac\n40001002\n2003\nNone\nInformática\n\n\n5\nMariana\nSzischik\n38090080\n1993\nms@fi.uba.ar\nElectrónica\n\n\n6\nAldo\nRastrelli\n38111222\n1994\nar@fi.uba.ar\nInformática\n\n\n\n\n\n\n\n\nMostrar el resumen de la información del DataFrame\nMostrar su forma\nMostrar la lista de los nombres de las columnas\nMostrar las primeras 3 filas\nMostrar las últimas 3 filas\nAgregar la nueva columna al DataFrame con la información de la edad de los estudiantes para el año actual y mostrar el DataFrame resultante\nMostrar a los estudiantes que tienen edad mayor a 25.\nPara los estudiantes que tienen edad mayor a 25, mostrar el promedio de edad.\nMostrar a la persona que es más joven.\nMostrar a la persona que se encuentra en la mitad de la tabla.\nMostrar sólo las columnas: “carrera” y “edad”.\nMostrar sólo los estudiantes que estudian Informática.\nMostrar sólo los estudiantes que estudian informática y tienen menos de 25 años.\nReemplazar Informática por Informática o Sistemas en la columna “carrera”.\nMostrar la cantidad de estudiantes por carrera.\nRenombrar la columna “carrera” por “ingeniería”.\nPara la primer estudiante, cambiar su carrera a “Electrónica”.\nAgregar una nueva fila al DataFrame con tus datos.\nAgregar una nueva columna ‘tiene_mail’, con un valor booleano que indique si la estudiante tiene mail en el sistema.\nAgregar una nueva columna, con un valor booleano que indique si a la estudiante se le necesita pedir un mail (sólo se le tiene que pedir un mail si no tiene mail asignado). Asumir que todavía no se tiene la columna ‘tiene_mail’.\nOrdenar el dataFrame por carrera y apellido, en ese orden.\nOrdenar el dataFrame por carrera y edad. Carrera por forma ascendente, edad por forma descendente.\nLa profesora Llamell guarda las notas del parcial de Pensamiento Computacional en un dataFrame. Cada fila tiene la siguiente información: nombre, apellido, intento, nota.\nLos intentos pueden ser 1 (si es la primera vez que rinde el parcial) o 2 (si está en el recuperatorio).\n\n\n\nObtener el promedio de las notas en la primera oportunidad de los alumnos.\nNota: Este ejercicio ya fue resuelto en la Guía 4 de Diccionarios, es el 4.3.11.\n\n\ndata = {\n    'nombre': ['Violeta', 'Carla', 'Manuela'],\n    'apellido': ['Perez', 'Guanca', 'Gomez'],\n    'dni': [42000000, 42001001, 42002002],\n    'carrera': ['Informática', 'Mecánica', 'Química'],\n    'nota': [7, 4, 6],\n    'intento': [1, 2, 1]\n}\n\ndf_notas = pd.DataFrame(data)\ndf_notas\n\n\n\n\n\n\n\n\nnombre\napellido\ndni\ncarrera\nnota\nintento\n\n\n\n\n0\nVioleta\nPerez\n42000000\nInformática\n7\n1\n\n\n1\nCarla\nGuanca\n42001001\nMecánica\n4\n2\n\n\n2\nManuela\nGomez\n42002002\nQuímica\n6\n1\n\n\n\n\n\n\n\n\nRosita tiene un dataFrame donde guarda todas las películas que vió. La información para cada una es: el nombre de la película, año en que salió, y la puntuación que le puso del 1 al 10. Obtener sólo las películas que tienen puntaje mayor a 7. Nota: este ejercicio ya fue resuelto en la Guía 4 de Diccionarios, es el 4.3.10.\n\ndata = {\n    'nombre': ['Harry Potter', 'El Señor de los Anillos', 'Barbie', 'Rapido y Furioso 18'],\n    'año': [2001, 2003, 1972, 2040],\n    'puntuacion': [8, 9, 8, 3]\n}\n\ndf_pelis = pd.DataFrame(data)\ndf_pelis",
    "crumbs": [
      "Guía de Ejercicios"
    ]
  },
  {
    "objectID": "guia.html#matplotlib",
    "href": "guia.html#matplotlib",
    "title": "Guía de Ejercicios",
    "section": "3. Matplotlib",
    "text": "3. Matplotlib\n\nGraficar las funciones obtenidas en el ejercicio 3 de Numpy, usando los números del 1 al 100 del eje x. Hacerlo primero en distintos gráficos y luego las 4 en el mismo.\n\n\ny = x^2\ny = 3x + 2\ny = 1/(x+1)\ny = log10(x)\n¿Hay alguna función que no se esté viendo correctamente en el gráfico? Tratar de entender por qué y graficarla en otro gráfico. Pista: mirar los valores que toma la función en el eje y.\n\n\nUsando Numpy: Siendo x un conjunto de 1000 valores de 0 a 2 * pi separados de forma uniforme:\n\nGraficar, con grilla, título y referencias apropiadas, la función seno de x (sin(x)).\nGraficar, con grilla, título y referencias apropiadas, la función coseno de x (cos(x)).\nGraficar, con grilla, título y referencias apropiadas, la función (seno de x) + x/2.\n\nSe tienen los siguientes datos de ventas de un prod_en los últimos 10 años:\nimport matplotlib.pyplot as plt\nimport numpy as np\n\naños = np.arange(2012, 2022)\n\nventas = [140, 60, 120, 250, 200, 180, 100, 300, 120, 160]\nganancias = [14000, 45000, 20400, 100000, 50000, 25000, 100000, 30000, 15000, 35000]\nproductos = [\"prod_1\", \"prod_2\", \"prod_3\", \"prod_4\", \"prod_5\", \"prod_6\", \"prod_7\", \"prod_8\", \"prod_9\", \"prod_10\"]\ncant_ventas_productos_2024 = [180, 160, 190, 140, 100, 200, 120, 130, 150, 170]\nEn gráficos separados:\n\nGraficar las ventas en función de los años usando gráfico de línea y gráfico de barras horizontal. ¿Cuál te parece que es mejor para este caso?\nGraficar las ganancias en función de los años usando gráfico de línea y gráfico de barras. ¿Cuál te parece que es el mejor gráfico para este caso?\nGraficar la cantidad de ventas en el año 2024 en función de los productos usando gráfico de barras y gráfico de torta. ¿Cuál te parece que es el mejor gráfico para este caso?\n\nUsando el siguiente dataframe:\ndata = {\n    'Jurisdicción': [\n        'Ciudad Autónoma de Buenos Aires', 'Buenos Aires', 'Catamarca', 'Chaco', 'Chubut',\n        'Córdoba', 'Corrientes', 'Entre Ríos', 'Formosa', 'Jujuy', 'La Pampa', 'La Rioja',\n        'Mendoza', 'Misiones', 'Neuquén', 'Río Negro', 'Salta', 'San Juan', 'San Luis',\n        'Santa Cruz', 'Santa Fe', 'Santiago del Estero', 'Tierra del Fuego, Antártida e Islas del Atlántico Sur',\n        'Tucumán'\n    ],\n    'Capital': [\n        '', 'La Plata', 'San Fernando del Valle de Catamarca', 'Resistencia', 'Rawson',\n        'Córdoba', 'Corrientes', 'Paraná', 'Formosa', 'San Salvador de Jujuy', 'Santa Rosa', 'La Rioja',\n        'Mendoza', 'Posadas', 'Neuquén', 'Viedma', 'Salta', 'San Juan', 'San Luis',\n        'Río Gallegos', 'Santa Fe', 'Santiago del Estero', 'Ushuaia', 'San Miguel de Tucumán'\n    ],\n    'Población (hab)': [\n        3075646, 17541141, 415438, 1204541, 618994, 3760450, 1120801, 1385961,\n        605193, 770881, 358428, 393531, 1990338, 1261294, 664057, 747610,\n        1424397, 781217, 508328, 365698, 3536418, 978313, 173715, 1694656\n    ],\n    'Superficie (km2)': [\n        205.9, 305907.4, 101486.1, 99763.3, 224302.3, 164707.8, 89123.3, 78383.7,\n        75488.3, 53244.2, 143492.5, 91493.7, 149069.2, 29911.4, 94422, 202168.6,\n        155340.5, 88296.2, 75347.1, 244457.5, 133249.1, 136934.3, 910324.4, 22592.1\n    ],\n    'PBI': [\n        154863803.5, 292689868, 6150949.159, 9832642.672, 17747854.21, 69363739.19,\n        7968012.982, 20743409.1, 3807057.419, 6484938.334, 6990262.458, 5590515.628,\n        33431369.11, 9646825.835, 22564106.16, 10264584.42, 13438834.91, 8262308.568,\n        11780849.36, 11663738.04, 81588690.27, 8387858.731, 7049276.383, 13856198.9\n    ],\n}\n\ndf = pd.DataFrame(data)\ndf.head()\n\nRealizar un gráfico de barras horizontales que muestre la cantidad de habitantes por jurisdicción. Las provincias con mayor población, deben ubicarse en la parte superior.\nRealizar un gráfico de torta que muestre el porcentaje de superficie de cada región del país.\nRealizar un gráfico de barras verticales que muestre el PBI de cada jurisdicción. Las provincias con mayor PBI, deben ubicarse a la derecha.\nRealizar un gráfico de puntos que muestre la relación entre la población y la superficie de cada jurisdicción. ¿Qué conclusión se puede tomar respecto al gráfico obtenido? ¿Hay alguna excepción? De ser así, analice cuál, incluyendo también un análisis de los gráficos anteriores.\n\n\n\n\n\n\n\n\ndatos.gob.ar\n\n\n\n¿Sabías que en Argentina hay un portal de datos abiertos?\nPodés ingresar a datos.gob.ar y obtener información de diferentes áreas, como salud, educación, justicia, entre otras. ¡Es una excelente fuente de datos para hacer análisis!\nPara usarlos, podés guardar el archivo csv en google drive e importarlo de la siguiente forma como un dataframe:\nimport pandas as pd\n\n# Acá va el link público de tu archivo de google drive + '/export?format=csv'\nurl = \"https://drive.google.com/drive/folders/ABC123XYZ456/export?format=csv\" \ndf = pd.read_csv(url)\n\n\n\nPara calcular la energía potencial elástica (Ep) almacenada en un material elástico, se utiliza la siguiente fórmula:\n\\[\nEp = \\frac{1}{2}*k*x^{2}\n\\]\ndonde k es la constante elástica (con unidad N/m) y x es la distancia que el resorte se estira o comprime (metros). La energía Ep resultante tiene como unidad el Joule (J).\nPara un resorte con valor \\(k=0.15 N/m\\), graficar en línea continua la energía potencial elástica \\(Ep\\) en un rango de distancia \\(x\\) de 0 a 10m con pasos de 0.5. Incluir título, grilla, nombres de ejes y label (leyenda) con el valor de \\(k\\).\nPara calcular la posición final de un móvil dada una posición inicial, velocidad inicial, tiempo y aceleración, se tiene la siguiente fórmula:\n\\[\nx = x_0+v_0 . t + \\frac{1}{2}.a.t^2\n\\]\nDonde \\(x_0\\) es la posición inicial, \\(v_0\\) la velocidad inicial, \\(t\\) el tiempo y \\(a\\) la aceleración.\nSe tiene la siguiente información de dos móviles:\nmovil 1:\n\nComienza a 0m\nArranca desde el reposo con velocidad $ 0  m/s$\nSu aceleración es \\(1 \\ m/s^2\\)\n\nmovil 2:\n\nComienza a 500m\nArranca con velocidad \\(4 \\ m/s\\)\nSu aceleración es \\(0.5 \\ m/s^2\\)\n\nPara 5000 valores del tiempo del 0 al 100, mostrar un único gráfico con la posición respecto del tiempo de ambos móviles. Incluir grilla, títulos y label (leyenda) indicando el valor de la posicion inicial, velocidad y aceleración.\nDesafio (obligatorio): Teniendo la planilla de notas del primer parcial del 1C2024 de los alumnos de la materia “Pensamiento Computacional”, importar los datos como dataframe usando el siguiente código:\nimport pandas as pd\n\nurl_sheet = \"https://docs.google.com/spreadsheets/d/17ei_NER5i_R-9QLnkeIjNprzTyoSqGowJ8yrT9tbi_8/export?format=csv\"\ndf = pd.read_csv(url_sheet)\ndf.head()\nSi la nota es “NaN”, significa que el o la estudiante no rindió el examen.\nEn gráficos diferentes:\n\nRealizar un gráfico de torta que muestre el porcentaje entre la cantidad de alumnos que asistieron al parcial y los que no.\nRealizar un gráfico de barras que muestre la cantidad de alumnos que aprobaron y desaprobaron el parcial, sin contar a los ausentes.\nRealizar un gráfico de puntos que muestre la relación entre el curso y la nota obtenida en el parcial. ¿Diría que existe una relación?\nRealizar un gráfico de linea que muestre la evolución de la nota promedio de los aprobados a través de los cursos.",
    "crumbs": [
      "Guía de Ejercicios"
    ]
  },
  {
    "objectID": "contact.html",
    "href": "contact.html",
    "title": "Contacto",
    "section": "",
    "text": "Discord\nPor temas administrativos, podes contactar al plantel docente de la materia enviando un mail a:\npc-cbc-docentes@googlegroups.com\nPor otros temas, te recomendamos que te comuniques por el servidor de Discord.\nLa materia usa Discord como plataforma adicional para la resolución de los ejercicios de las guias.\nTengan a bien leer con atención el mensaje de bienvenida y las reglas de convivencia. Pueden ingresar al servidor a través del siguiente link.",
    "crumbs": [
      "Contacto"
    ]
  },
  {
    "objectID": "contact.html#feedback",
    "href": "contact.html#feedback",
    "title": "Contacto",
    "section": "Dejanos Feedback!",
    "text": "Dejanos Feedback!\nPodés dejarnos feedback de las clases prácticas completando este formulario.",
    "crumbs": [
      "Contacto"
    ]
  },
  {
    "objectID": "contact.html#docentes",
    "href": "contact.html#docentes",
    "title": "Contacto",
    "section": "Ser Docente",
    "text": "Ser Docente\nPara ser docente de la materia es necesario haber aprobado el CBC y ser estudiante de FIUBA.\nSi cumplís con estos requisitos y te interesa ser docente de la práctica, podés escribirnos a nuestro mail de Contacto (arriba) para más información.\nLa materia se dicta los días lunes, martes, jueves y viernes, en los turnos 7-10, 10-13 y 13-16.",
    "crumbs": [
      "Contacto"
    ]
  }
]