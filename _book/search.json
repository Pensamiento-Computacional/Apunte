[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pensamiento Computacional",
    "section": "",
    "text": "Pensamiento Computacional\nBienvenidos y bienvenidas a la cátedra de Pensamiento Computacional del Ciclo Básico Común de la Facultad de Ingeniería - UBA."
  },
  {
    "objectID": "index.html#docentes-de-la-cátedra",
    "href": "index.html#docentes-de-la-cátedra",
    "title": "Pensamiento Computacional",
    "section": "Docentes de la Cátedra",
    "text": "Docentes de la Cátedra\n\nProf. Titular: Méndez, Mariano\nBalbiano, Jose Luis\nBulacios, Juan\nCáceres, Fernando\nCapón, Lucía\nCarletti, Joaquin\nLopez, Fernando\nMartinez Gorbik, Llamell Ailén\nMéndez, Mariano\nNotari, Pablo\nRabanos, Federico\nRastrelli, Aldana\nSzischik, Mariana"
  },
  {
    "objectID": "intro.html#fundamentación",
    "href": "intro.html#fundamentación",
    "title": "La Materia",
    "section": "Fundamentación",
    "text": "Fundamentación\nEl pensamiento computacional es una disciplina que ha sido definida como “el conjunto de procesos de pensamiento implicados en la formulación de problemas y sus soluciones, de manera que dichas soluciones sean representadas de una forma que puedan ser efectivamente ejecutadas por un agente de procesamiento de información”, entendiendo por esto último a un humano, una máquina o una combinación de ambos.\nReconoce antecedentes en trabajos de la Carnegie Mellon University de la década de 1960 y del Massachusetts Institute of Technology de alrededor de 1980, aunque su auge en la educación superior llegó con la primera década del siglo XXI.\nLas herramientas básicas en las que se funda el pensamiento computacional son la descomposición, la abstracción, el reconocimiento de patrones y la algoritmia. Está ampliamente aceptado que estas herramientas no sirven solamente a los profesionales de Ciencias de la Computación y de Informática, sino a cualquier persona que deba resolver problemas, con lo cual el pensamiento computacional deviene una técnica de resolución de problemas. Actualmente, los y las profesionales de la Ingeniería requieren de una capacidad analítica que les permita resolver problemas, y en ese sentido el pensamiento computacional se convierte en un soporte invaluable de esa competencia (cada vez más las ciencias de la computación y la informática constituyen una ciencia básica para todas las ingenierías).\nSi bien el pensamiento computacional no necesariamente requiere del uso de computadoras, la programación de computadoras se convierte en su complemento ideal. En primer lugar, porque permite comprobar, mediante la codificación de un algoritmo en un programa, la validez de la solución encontrada al problema, de manera sencilla y prácticamente inmediata. En segundo lugar, porque la programación incentiva la creatividad, la capacidad para la autoorganización y el trabajo en equipo. En tercer lugar, porque la programación constituye un recurso habitual del trabajo en el campo profesional de la ingeniería."
  },
  {
    "objectID": "intro.html#objetivos-generales",
    "href": "intro.html#objetivos-generales",
    "title": "La Materia",
    "section": "Objetivos Generales",
    "text": "Objetivos Generales\nEl objetivo general de la asignatura es que los/as estudiantes adquieran habilidades de resolución de problemas de ingeniería mediante el soporte de un lenguaje de programación multiparadigma."
  },
  {
    "objectID": "rules.html#formas-de-evaluación",
    "href": "rules.html#formas-de-evaluación",
    "title": "Regimen de Cursada",
    "section": "Formas de Evaluación",
    "text": "Formas de Evaluación\nLa cursada de la materia cuenta con dos parciales:\n\nPrimer Parcial\n\nUnidad 1\nUnidad 2\nUnidad 3\nUnidad 4\n\nSegundo Parcial\n\nUnidad 5\nUnidad 6\n\n\nCada parcial cuenta con un único recuperatorio."
  },
  {
    "objectID": "rules.html#aprobación-de-la-cursadamateria",
    "href": "rules.html#aprobación-de-la-cursadamateria",
    "title": "Regimen de Cursada",
    "section": "Aprobación de la Cursada/Materia",
    "text": "Aprobación de la Cursada/Materia\nSe tiene dos formas de aprobación de la cursada:\n\nRegularización\nPromoción\n\n\nRegularización\nPara regularizar la cursada, se deben aprobar los dos parciales (o recuperatorios) con un mínimo de nota de 4 (cuatro) en cada uno.\nEl promedio entre ambos parciales (o recuperatorios) debe ser mayor o igual a 4 (cuatro) y menor a 7 (siete).\n\n\n\n\n\n\n¿Cómo calculo Promedio?\n\n\n\n\n\nSean:\n\nn1 la nota del primer parcial o recuperatorio del primer parcial\nn2 la nota del segundo parcial o recuperatorio del segundo parcial\n\nEl promedio es: (n1+n2)/2\n\n\n\nLa cursada regularizada habilita a rendir el examen final integrador, para el cual se tienen 3 (tres) oportunidades de rendir (más información abajo).\n\n\nPromoción\nPara promocionar la materia, se deben aprobar los dos parciales (o recuperatorios) con un mínimo de nota de 7 (siete) en cada uno.\nEl promedio entre ambos parciales (o recuperatorios) debe ser mayor o igual a 7 (siete).\n\n\n\n\n\n\nRendir Recuperatorios para Promoción\n\n\n\n\n\nSi se desea rendir el recuperatorio intentar subir la nota para la promoción, se debe tener en cuenta que la cátedra considerará únicamente válida la nota del último examen que se haya rendido.\nEjemplo:\n# caso 1\nparcial1 = 5\nrecuperatorio1 = 7\n=&gt; nota final parcial1 = 7\n\n# caso 2\nparcial1 = 5\nrecuperatorio1 = 4\n=&gt; nota final parcial1 = 4\n\n\n\n\n\nExamen Final Integrador\nEl examen final integrador consta de una evaluación que incluye todos los temas de la materia. Los mismos se rinden al final del cuatrimestre. Se aprueba con una nota mayor o igual a 4 (cuatro).\n\n\n\n\n\n\nDesaprobación de la Materia\n\n\n\nSi se desaprueba alguno de los parciales, el mismo puede recuperarse una sola vez.\nSi se desapruba el recuperatorio, se debe volver a cursar la materia el cuatrimestre siguiente.\nSi se desaprueba 3 (tres) veces el examen final integrador, se debe volver a cursar la materia el cuatrimestre siguiente."
  },
  {
    "objectID": "unidad_1.html#introducción",
    "href": "unidad_1.html#introducción",
    "title": "1  Introducción a la Algoritmia y a la Programación",
    "section": "1.1 Introducción",
    "text": "1.1 Introducción\nComo en todas las disciplinas, la Ingeniería de Software y la Programación de Sistemas en general tienen un lenguaje técnico específico. La utilización de ciertos términos y el compartir de ciertos conceptos agiliza el diálogo y mejora la comprensión con los pares.\nEn este capítulo vamos a hacer una breve introducción de ciertos conceptos, ideas y modelos que van a permitirnos establecer acuerdos y manejar un lenguaje común.\n\n1.1.1 La Computadora\nUna computadora es un dispositivo físico de procesamiento de datos, con un propósito general. Todos los programas que escribiremos serán ejecutados (o corridos) en una computadora. Una computadora es capaz de procesar datos y obtener nueva información o resultados.\n\n\n1.1.2 Software y Hardware\nToda computadora funciona con software y hardware. El software es el conjunto de herramientas abstractas (programas), y se le llama componente lógica del modelo computacional. El hardware es el componente físico del dispositivo. Básicamente, el software dice qué hacer, y el hardware lo hace.\n\n\n\n\n\n\n¿Es indispensable tener una computadora para crear un algoritmo?\n\n\n\n\nLa respuesta, sorprendentemente, es no: muchos de los algoritmos que se utilizan de forma computacional hoy en día fueron diseñados varias décadas atrás. Pero la implementación de un algoritmo depende del grado de avance del hardware y la tecnología disponible.\n\n\n\n\n1.1.3 Sistema Operativo\nEl sistema operativo es el programa encargado de administrar los recursos del sistema. Los recursos (como la memoria, por ejemplo) son disputados entre diferentes programas o procesos ejecutándose al mismo tiempo. El sistema operativo es el que decide cómo administrar y asignar los recursos disponibles.\nLos sistemas operativos más comunes el día de hoy son: Windows, Linux, iOS, Android; por ejemplo.\n\n\n1.1.4 Algoritmo\nUn algoritmo es una serie finita de pasos precisos para alcanzar un objetivo.\n\n“serie”: porque son continuados uno detrás del otro, de forma ordenada.\n“finita”: porque no pueden ser pasos infinitos, en algún momento deben terminar.\n“pasos precisos”: porque en un algoritmo se debe ser lo más específico posible.\n\n\nEjemplo Un algoritmo puede ser una receta de cocina: tiene una serie finita de pasos (son ordenados, uno detrás de otro, finitos porque en algún momento deben terminar), que son precisos (porque tienen indicaciones de cuánto agregar de cada ingrediente, cómo incorporarlo a la preparación, etc) y están orientados en alcanzar un objetivo (obtener una comida en particular).\n\n\n1.1.4.1 Creación de un Algoritmo\nLa forma en la que trabajaremos la creación de un algoritmo es siguiendo los siguientes pasos:\n\nAnálisis del problema: entender el objetivo y los posibles casos puntuales del mismo.\n\nPrimer borrador de solución: confeccionar una idea generalizada de cómo podría resolverse el problema.\n\nDivisión del problema en partes: dividir el problema en partes ayuda a descomponer un problema complejo en varios más sencillos.\n\nEnsamble de las partes para la versión final del algoritmo: acoplar todo el conjunto de partes del problema para lograr el objetivo general.\n\n\nEstos cuatro pasos podrán iterarse (repetirse) la cantidad de veces que sean necesarios, para poder lograr acercarnos más a la solución en cada iteración.\n\n\n\n1.1.5 Programa\nUn programa es un algoritmo escrito en un lenguaje de programación.\n\n\n1.1.6 Lenguaje de Programación\nUn lenguaje de programación es un protocolo de comunicación.\nUn protocolo es un conjunto de normas consensuadas.\n\\(\\implies\\) Entonces, un lenguaje de programación es un conjunto de normas consensuadas, entre la persona y la máquina, para poder comunicarse.\nCuando logramos que un lenguaje pueda ser comprendido por el humano y por la máquina, tenemos una comunicación efectiva en donde podremos hacer programas y pedirle a la máquina que los ejecute.\nUn buen ejemplo de cómo una computadora interpreta nuestras instrucciones sin pensar al respecto, sin tener sentido común y sin ambigüedades, es este video. La computadora lo único que hace es interpretar de forma explícita lo que nosotros le pedimos que haga.\nUn lenguaje de programación tiene reglas estrictas que se deben respetar y no se admiten ambiguedades o sobreentendidos.\n\n\n1.1.7 Entorno de Desarrollo\nUn entorno de desarrollo es un conjunto de herramientas que nos permiten escribir, editar, compilar y ejecutar programas.\n\nEn la materia utilizaremos un entorno de desarrollo llamado Replit, que nos permite escribir código en un editor de texto, compilarlo y ejecutarlo en un mismo lugar de forma online. Pero existen muchos otros entornos de desarrollo, como por ejemplo Visual Studio Code, Eclipse, NetBeans, etc."
  },
  {
    "objectID": "unidad_1.html#lenguaje-python",
    "href": "unidad_1.html#lenguaje-python",
    "title": "1  Introducción a la Algoritmia y a la Programación",
    "section": "1.2 Lenguaje Python",
    "text": "1.2 Lenguaje Python\nEn este curso utilizaremos el lenguaje de programación Python. Python es un lenguaje de programación de propósito general, que se utiliza en muchos ámbitos de la industria y la academia.\nPython es un lenguaje realmente fácil de aprender, con una curva de aprendizaje muy suave. Es un lenguaje de alto nivel, lo que significa que es un lenguaje que se asemeja mucho al lenguaje natural, y que no requiere de conocimientos de bajo nivel para poder utilizarlo.\n\n1.2.1 Hola, Mundo!\nEl primer programa que se escribe en cualquier lenguaje de programación es el programa “Hola, Mundo!”. Este programa es un programa que imprime en pantalla el texto “Hola, Mundo!”.\nEn Python, el programa “Hola, Mundo!” se escribe de la siguiente forma:\n\nprint(\"Hola, Mundo!\")\n\nHola, Mundo!\n\n\nprint es una función que imprime en pantalla el texto que se le pasa entre paréntesis. En este caso, el texto que se le pasa como parámetro es \"Hola, Mundo!\". Al escribir las comillas dobles, estamos indicando que el texto que se encuentra entre ellas es un texto literal.\nDe la misma forma, podremos imprimir cualquier otro mensaje en pantalla, como por ejemplo:\n\nprint(\"Hola, me llamo Rosita y soy programadora\")\n\nHola, me llamo Rosita y soy programadora\n\n\nAl igual que Rosita, al hacer nuestro primer ‘Hola, Mundo!’ nos convertimos en programadores. ¡Felicitaciones!\nA partir de la próxima clase, comenzaremos a ver cómo escribir programas más complejos, que nos permitan resolver problemas más interesantes."
  },
  {
    "objectID": "unidad_1.html#anexo-replit",
    "href": "unidad_1.html#anexo-replit",
    "title": "1  Introducción a la Algoritmia y a la Programación",
    "section": "1.3 Anexo: Replit",
    "text": "1.3 Anexo: Replit\n\n1.3.1 Creación de una nueva cuenta\nPara utilizar replit vamos a ingresar a https://replit.com/.\n\n\n\n\nPágina de inicio de Replit\n\n\nVamos a presionar luego en Sign Up, donde va a pedir crear una cuenta, o iniciar sesión si ya tenemos una. Una de nuestras opciones es, si tenemos una cuenta google ya creada, iniciar sesión con eso. De lo contrario, podemos crear una cuenta nueva con un mail.\n\n\n\nPágina de creación de cuenta de Replit\n\n\n\n\n1.3.2 Creación de un nuevo proyecto\nUna vez creada la cuenta e iniciado sesión, vamos a ver esta pantalla:\n\n\n\nHome de Replit\n\n\nEn la misma vamos a ver muchas opciones, pero la que nosotros nos interesa es el botón de + Create Repl, que nos va a permitir crear un nuevo proyecto.\n\n\n\nBotón de creación de un nuevo proyecto en Replit\n\n\nSe va a abrir la siguiente ventana: \nDonde vamos a buscar y elegir en “Templates” el lenguaje de programación Python. Luego, vamos a asignarle un nombre y seleccionar “Create repl”.\nSe debería ver algo así:\n\n\n\nVentana completa de creación de un nuevo proyecto en Replit\n\n\n\n\n1.3.3 Uso del nuevo proyecto\nLos espacios o proyectos en replit se llaman Workspace, que significa espacio de trabajo. En este espacio de trabajo vamos a poder escribir código, ejecutarlo, y ver los resultados de la ejecución.\nUna vez creado el espacio de trabajo, se nos va a abrir una pantalla donde vamos a ver varias cosas.\nInicialmente, tenemos en el centro el espacio de edición de código, donde vamos a escribir nuestro programa. \nEn la parte superior, vamos a ver un botón de Run, que nos va a permitir ejecutar el programa que escribimos.\n\n\n\nBotón de ejecución de código\n\n\nEn la parte derecha, vamos a ver el resultado de la ejecución del programa. En este caso, como no escribimos nada, no hay nada para mostrar.\n\n\n\nResultado de la ejecución de código\n\n\nFinalmente, en la parte izquierda vamos a tener el menú de archivos, donde vamos a poder crear nuevos archivos, borrarlos, etc. También tiene el acceso a otras herramientas que de momento no vamos a estar usando.\n\n\n\nMenú de archivos\n\n\nVamos a ver que en el menú de archivos ya tenemos un archivo creado, llamado main.py. Este archivo es el archivo principal de nuestro programa, y es el que se ejecuta cuando presionamos el botón de Run.\nSi bien podemos tener otros archivos, el único que se ejecuta cuando presionamos Run es main.py. Por lo tanto, es importante que nuestro programa principal o lo que nosotros queremos correr, esté en este archivo. Lo que podemos hacer, es crear otros archivos para ir guardando nuestro código y ejercicios anteriores sin necesidad de que se ejecuten cada vez que presionamos Run.\n\n¡Probemos el espacio de trabajo! Vamos a escribir en el archivo main.py el siguiente código: print(\"Hola, Mundo!\"). Luego, vamos a presionar el botón de Run y vamos a ver el resultado en la parte derecha de la pantalla.\n\n¡Felicitaciones! Ya escribiste tu primer programa en Python.\n\n\n\n\n\n\n\n\n\n\n¿Lograste ver el resultado? ¿Qué pasa si presionás el botón de Run varias veces seguidas?"
  },
  {
    "objectID": "unidad_2.html#sentencias-básicas",
    "href": "unidad_2.html#sentencias-básicas",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "2.1 Sentencias Básicas",
    "text": "2.1 Sentencias Básicas\nEn esta unidad vamos a centrarnos en la herramienta que vamos a emplear, que es Python. Vamos a hacer un programa sencillo, interactuar con el usuario y más.\n\n2.1.1 Flujo de Control de un Programa\nEl flujo de control de un programa es la forma en la que se ejecutan las instrucciones de un programa. En Python, el flujo de control es secuencial, es decir, se ejecutan las instrucciones una detrás de otra. En otros lenguajes de programación, el flujo de control puede ser condicional o repetitivo.\nEjemplo:\nEsta línea se ejecutaría primero        ↓\nEsta línea se ejecutaría después        ↓\nEsta línea se ejecutaría a lo último    \nEn este curso, la comunicación de los programas con el mundo exterior se realizará casi exclusivamente con el usuario por medio de la consola (o terminal, la presentamos en la unidad anterior en el anexo de Replit).\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nEsto no significa que todos los programas siempre se comuniquen con el usuario para todo. Pensemos en las aplicaciones que usamos generalmente, como instagram: imaginémonos si para cada acción que hiciéramos dentro de la app la misma nos preguntara si queremos hacerlo o no:\n\n- “¿Estás seguro/a de que querés iniciar sesión?”\n- “¿Estás seguro/a de que querés traer tu nombre de usuario para mostrarse en el perfil?”\n- “¿Estás seguro/a de que querés traer tu foto de usuario para mostrarse en el perfil?”\n\nSería extremadamente molesto. Uno simplemente inicia sesión, y hay un montón de cosas y procesos que se ejecutan uno detrás de otro, automáticamente.\n\nHay cosas que no necesitan de la interacción del usuario. Nosotros nos vamos a centrar en la interacción con el usuario en gran parte del curso, pero no es lo único que se puede hacer. Los programas pueden comunicarse con otros programas y las partes de un mismo programa pueden comunicarse con otras partes del mismo programa.  Más adelante vamos a ver un poco más de esta diferencia.\n\n\n\n\n2.1.2 Valores y Tipos\nSi tenemos la operación 7 * 5, sabemos que el resultado es 35. Decimos que tanto 7, 5 como 35 son valores. En los lenguajes de programación, cada valor tiene un tipo.\nEn este caso, 7, 5 y 35 son enteros (o integers en inglés). En Python, los enteros se representan con el tipo int.\nPython tiene dos tipos de datos numéricos: - número enteros - números de punto flotante\nLos números enteros representan un valor entero exacto, como 42, 0, -5 o 10000.\nLos números de punto flotante tienen una parte fraccionaria, como 3.14159, 1.0 o 0.0.\nSegún los operandos (los valores que se operan) y el operador (el símbolo que indica la operación), el resultado puede ser de un tipo u otro. Por ejemplo, si tenemos 7 / 5, el resultado es 1.4, que es un número de punto flotante. Si tenemos 7 + 5, el resultado es 12, que es un número entero.\n\n1 + 2\n\n3\n\n\nVamos a elegir usar enteros cada vez que necesitemos recordar, almacenar o representar un valor exacto, como pueden ser por ejemplo: la cantidad de alumnos, cuántas veces repetimos una operación, un número de documento, etc.\nVamos a elegir usar números de punto flotante cada vez que necesitemos recordar, almacenar o representar un valor aproximado, como pueden ser por ejemplo: la altura o el peso de una persona, la temperatura de un día, una distancia recorrida, etc.\n\n0.1 + 0.2\n\n0.30000000000000004\n\n\nComo vemos, cuando hay números de punto flotante, el resultado es aproximado. 0.1 + 0.2 nos debería dar 0.3, pero nos da 0.30000000000000004. Esto es porque los números de punto flotante son aproximados, y no pueden representar todos los valores de forma exacta. Esto es algo que vamos a tener que tener en cuenta cuando trabajemos con números de punto flotante.\n\n\n\n\n\n\nUso de punto\n\n\n\nNotemos que para representar números de punto flotante, usamos el punto (.) y no la coma (,). Esto es porque en Python, la coma se usa para separar valores, como vamos a ver más adelante.\n\n\nAdemás de efectuar operaciones matemáticas, Python nos permite trabajar con porciones de texto, que se llaman cadenas (o strings en inglés). Las cadenas se representan con el tipo str.\nLas cadenas se escriben entre comillas simples (') o dobles (\").\n\nprint( \"¡Hola!\" )\n\n¡Hola!\n\n\n\nprint( '¡Hola!' )\n\n¡Hola!\n\n\nLas cadenas también tienen operaciones disponibles, como por ejemplo la concatenación, que es la unión de dos cadenas en una sola. Esto se hace con el operador +.\n\nprint( \"¡Hola!\" + \" ¿Cómo estás?\" )\n\n¡Hola! ¿Cómo estás?\n\n\nVamos a ver más de estas operaciones más adelante.\n\n\n2.1.3 Variables\nPython nos permite asignarle un nombre a un valor, de forma tal que podamos “recordarlo” y usarlo más adelante. A esto se le llama asignación.\nEstos nombres se llaman variables, y son espacios donde podemos almacenar valores.\n\nLa asignación se hace con el operador = de la siguiente forma: &lt;nombre&gt; = &lt;valor o expresion&gt;.\nEjemplos:\n\nx = 5\n\n\ny = x + 2\n\n\nprint(y)\n\n7\n\n\n\nprint(y * 2)\n\n14\n\n\n\nlenguaje = \"Python\"\n\ntexto = \"Estoy programando en \" + lenguaje\nprint(texto)\n\nEstoy programando en Python\n\n\nEn este ejemplo, creamos las siguientes variables:\n\nx\ny\nlenguaje\ntexto\n\ny las asociamos a los valores 5, 7, “Python” y “Estoy programando en Python” respectivamente. Luego podemos usar esas variables como parte de cualquier expresión, y en el momento de evaluarla, Python reemplazará las variables por su valor asociado.\n\n\n\n\n\n\nVariables y Constantes\n\n\n\nSi el dato es inmutable (no puede cambiar) durante la ejecución del programa, se dice que ese dato es una constante. Si tiene la habilidad de cambiar, se dice que es una variable. En Python, todas las variables son mutables, es decir, pueden cambiar su valor durante la ejecución del programa.\nY no sólo pueden cambiar su valor, sino también su tipo: x = 5 y x = \"Hola\" son dos asignaciones válidas, y se pueden hacer una debajo de la otra:\n\nx = 5\nx = \"Hola\"\nprint(x)\n\nHola\n\n\n\n\n\n\n\n\n\n\nNombres de Variables\n\n\n\nNo se puede usar el mismo nombre para dos datos diferentes a la vez; una variable puede referenciar un sólo dato por vez. Si se usa un mismo nombre para un dato diferente, se pierde la referencia al dato anterior.\n\n\n\n\n\n2.1.4 Funciones\nPara poder realizar algunas operaciones particulares, necesitamos introducir el concepto de función. Una función es un bloque de código que se ejecuta cuando se la llama.\nEs un fragmento de programa que permite efectuar una operación determinada. abs, print, max son ejemplos de funciones de Python: abspermite calcular el valor absoluto de un número, print permite mostrar un valor por pantalla y max permite calcular el máximo entre dos valores.\n\nUna función puede recibir 0 o más parámetros o argumentos, que son valores que se le pasan a la función entre paréntesis y separados por comas, para que los use.\n\n\nabs(-5)\n\n5\n\n\n\nprint(\"¡Hola!\")\n\n¡Hola!\n\n\n\nmax(5, 7)\n\n7\n\n\nLa función recibe los parámetros, efectúa una operación y devuelve un resultado.\nPython viene equipado de muchas funciones predefinidas, pero nosotros como programadores debemos ser capaces de escribir nuevas instrucciones para la computadora. Las grandes aplicaciones como el correo electrónico, navegación web, chat, juegos, etc. no son más que grandes programas implementados introduciendo nuevas funciones a la máquina, escritas por uno o más programadores.\n\n\n\nUna función recibe parámetros y devuelve un resultado\n\n\n\n\n\n\n\n\nPython es Case Sensitive\n\n\n\nPython es Case Sensitive, es decir, distingue entre mayúsculas y minúsculas.\nEs muy importante respetar mayúsculas y minúsculas: PRINT() o prINT() no serán reconocidas. Esto aplica para todo lo que escribamos en nuestros programas.\n\n\nSi queremos crear una función que nos devuelva un saludo a Lucia cada vez que se la llama, debemos ingresar el siguiente conjunto de líneas en Python:\n\ndef saludar_lucia():\n  return \"Hola, Lucia!\"\n\nVarias cosas a notar del código:\n\nsaludar_lucia es el nombre de la función. Podría ser cualquier otro nombre, pero es una buena práctica que el nombre de la función describa lo que hace.\n\ndef es una palabra clave que indica que estamos definiendo una función.\n\nreturn indica el valor que devuelve la función. Es decir, el resultado. Puede devolverse una sola cosa, como en este caso, o varias cosas separadas por comas.\n\nLa sangría (el espacio inicial) en el renglón 2 le indica a Python que estamos dentro del cuerpo de la función. El cuerpo de la función es el bloque de código que se ejecuta cuando se llama a la misma.\n\n\n\n\n\n\n\n\nSangría\n\n\n\nLa sangría puede ingresarse utilizando dos o más espacios, o presionando la tecla Tab. Es importante prestar atención en no mezclar espacios con tabs, para evitar “confundir” al intérprete.\n\n\n\n\n\n\n\n\nFirma de la función\n\n\n\nLa firma de una función es la primera línea de la misma, donde se indica el nombre de la función y los parámetros que recibe. La firma permite identificar y diferenciar a una función de otra.\n\n\nPero, como vemos, el bloque de código anterior no hace nada. Para que la función haga algo, tenemos que llamarla. Para llamar a una función, escribimos su nombre, seguido de paréntesis y los parámetros que recibe, separados por comas.\nsaludar_lucia()\nSe dice que estamos invocando o llamando a la función. Y al invocar una función, se ejecutan las instrucciones que habíamos escrito en su cuerpo.\n\nPero de nuevo, vemos que no pasa nada. ¿Por qué? Porque la función usa return para devolver un valor. Pero nosotros no estamos haciendo nada con ese valor. Para poder verlo, tenemos que imprimirlo por pantalla.\n\nsaludo = saludar_lucia()\nprint(saludo)\n\nHola, Lucia!\n\n\nLo que hicimos fue asignar el resultado devuelto por saludar_lucia a la variable saludo, y luego imprimir el valor de la variable por pantalla.\nBueno, ahora podemos saludar a Lucia. Pero vamos a querer saludar a otras personas también. ¿Cómo hacemos? Podemos hacer una función que reciba el nombre de la persona a saludar como parámetro.\n\ndef saludar(nombre):\n  return \"Hola, \" + nombre + \"!\"\n\nDe esta forma, podemos saludar a cualquier persona, pasando su nombre como parámetro.\n\n# Esta es otra forma de imprimir, sin necesidad de guardarnos\n# el resultado de la función en una variable,\n# simplemente la imprimimos\nprint(saludar(\"Lucia\"))\n\nHola, Lucia!\n\n\n\nprint(saludar(\"Serena\"))\n\nHola, Serena!\n\n\n\n2.1.4.1 Ejemplos\n\nEjemplo\nEscribir una función que calcule el doble de un número.\n\n\ndef obtener_doble(numero):\n  return numero * 2\n\nPara invocarla, debemos llamarla pasándole un número:\n\ndoble = obtener_doble(5)\nprint(doble)\n\n10\n\n\n\nEjemplo\nPensá un número, duplícalo, súmale 6, divídelo por 2 y resta el número que elegiste al comienzo. El número que queda es siempre 3.\n\n\ndef f(numero):\n  return ((numero * 2) + 6) / 2 - numero\n\n\nprint(f(5))\n\n3.0\n\n\n\n\n\n2.1.5 Ingreso de Datos por Consola\nHasta ahora, los programas que hicimos no interactuaban con el usuario. Pero para que nuestros programas sean más útiles, vamos a querer que el usuario pueda ingresar datos, y que el programa pueda mostrarle datos por pantalla. Para esto, vamos a usar la función input.\ninput()\nInput es una función que bloquea el flujo del programa, esperando a que el usuario ingrese una entrada por consola y presione enter. Cuando el usuario presiona enter, la función devuelve el valor ingresado por el usuario.\n\ninput()\nprint(\"terminé!\")\nSi corremos el bloque de código anterior, vamos a tener un comportamiento como este:\n\nLa consola va a quedar vacía, esperando el ingreso del usuario\nIngresamos un valor, el que tengamos ganas, y presionamos enter.\nLa consola muestra el mensaje “terminé!”.\n\n\n\n\nInput bloquea el flujo del programa\n\n\n\n\n\nIngresamos un valor (puede ser un número, texto, o ambos)\n\n\n\n\n\nAl presionar Enter, la consola muestra el mensaje “terminé!”\n\n\n\n2.1.5.1 Obteniendo el Valor Ingresado\nComo dijimos más arriba, la función input devuelve el valor ingresado por el usuario. Para poder usarlo, tenemos que guardarlo en una variable.\nnombre = input()\nprint(\"Hola, \" + nombre + \"!\")\n\n\n\nIngresamos “Mariana” y presionamos Enter.\n\n\nPara hacer nuestro programa más amigable, podemos mostrarle al usuario un mensaje antes de pedirle que ingrese un valor. Para esto, podemos pasarle un parámetro a la función input, que es el mensaje que queremos mostrarle al usuario.\nnombre = input(\"Ingresá tu nombre: \")\nprint(\"Hola, \" + nombre + \"!\")\n\n\n\nIngresamos “Mariana” y presionamos Enter.\n\n\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nA partir de la guía 2, a menos que el ejercicio diga específicamente “pedirle al usuario”, no se debe usar input, sino que todo tiene que recibirse por parámetro en la función.\nLo mismo con print: A menos que el ejercicio diga específicamente “imprimir”, todo siempre se tiene que devolver con un return."
  },
  {
    "objectID": "unidad_2.html#buenas-prácticas-de-programación",
    "href": "unidad_2.html#buenas-prácticas-de-programación",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "2.2 Buenas Prácticas de programación",
    "text": "2.2 Buenas Prácticas de programación\n\n2.2.1 Sobre Comentarios\nLos comentarios son líneas que se escriben en el código, pero que no se ejecutan. Sirven para que el programador pueda dejar notas en el código, para que se entienda mejor qué hace el programa.\nLos comentarios se escriben con el símbolo #. Todo lo que esté a la derecha del # no se ejecuta. También se pueden encerrar entre tres comillas dobles (\"\"\") para escribir comentarios de varias líneas.\n# Esto es un comentario\n\n\"\"\" Esto es un comentario\nde varias líneas \"\"\"\nNo es correcto escribir comentarios que no aporten nada al código, o tener el código absolutamente plagado de comentarios. Los comentarios deben ser útiles, y deben aportar información que no se pueda inferir del código. Nuestro primer intento de hacer el código más entendible no tienen que ser los comentarios, sino mejorar el código en sí.\n\n\n2.2.2 Sobre Convención de Nombres\nPara nombres de variables y funciones, se usa snake_case, que es básicamente dejar todas las palabras en minúscula y unirlas con un guión bajo. Ejemplos: numero_positivo, sumar_cinco, pedir_numero, etc.  Siempre emplear un nombre que nos remita al significado que tendrá ese dato, siempre en snake_case: numero, letra, letra2, edad_hermano, etc.\n\n2.2.2.1 Variables\nLas variables son cosas. Entonces sus nombres son sustantivos: nombre, numero, suma, resta, resultado, respuesta_usuario. La única excepción son las variables booleanas (ya las vamos a ver, son aquellas que pueden guardar dos posibles valores: verdadero o falso), que suelen tener nombres como es_par, es_cero, es_entero, porque su valor es true o false.\nA veces es útil alguna frase para identificar mejor el contenido:\nedad_mayor_hijo, apellido_conyuge\n\n\n2.2.2.2 Funciones\nLas funciones hacen algo. Entonces sus nombres son verbos. Se usan siempre verbos en infinitivo (terminan en -ar, -er, -ir): calcular_suma, imprimir_mensaje, correr_prueba, obtener_triplicado, etc.\nDe nuevo, las excepciones son las funciones que devuelven un valor booleano (V o F). Esas pueden llamarse como: es_par, da_cero, tiene_letra_a, porque devuelven verdadero o falso, y eso nos confirma o niega la afirmación que hace el nombre.\n\n\n\n2.2.3 Sobre Ordenamiento de Código\nCuando uno corre Python, lo que hace el lenguaje es leer línea a línea nuestro código. Lo que se puede ejecutar, lo ejecuta. Las funciones las guarda en memoria para poder usarlas luego.\nEntonces es más ordenado y prolijo primero poner todas las funciones, y después el código “ejecutable” (si van a dejar código suelto en el archivo).\n\nAdemás, no olvidemos que Python tiene un flujo de control de arriba para abajo. Si intentamos invocar funciones antes de que estén definidas (def), Python no va a saber qué hacer, y nos va a tirar un error.\n\nEsto es correcto: \nEsto es incorrecto: \n\n\n2.2.4 Sobre uso de Parámetros en Funciones\nUna función se puede pensar como una caja cerrada o una fábrica. La función tiene dos puertas: una de entrada y una de salida.\nLa puerta de entrada son los parámetros y la de salida es el output (el resultado).\n\n\n\nCuando se llama o invoca a la función, la puerta de entrada se abre, permitiéndonos enviarle (pasarle) cero, uno o más parámetros a la función (según cómo esté definida). Los parámetros son datos que la función necesida para funcionar, y como ya dijimos, se le pasan a la misma entre los paréntesis de la llamada.\n\n\nEjemplo: saludar(nombre), imprimir_elementos(lista), sumar(numero1, numero2), etc.\n\n\n\n\nUna vez que la función se empieza a ejecutar, ambas puertas se cierran. Esto quiere decir que, mientras la función se está ejecutando, nada entra y nada sale de la misma.\nLa función debería trabajar únicamente con los datos que se le hayan pasado por parámetro o que se le pidan al usuario dentro de ella, pero no debería utilizar nada que esté por fuera de la misma.\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nPython nos deja usar cosas por fuera de la función y sin recibir los datos por parámetro, porque es un lenguaje muy benevolente. Pero está mal usar cosas que no se hayan recibido por parámetro: es una mala práctica.\n\n\n\n\n\nUna vez que la función terminó de ejecutarse, el o los valores de salida (resultados) se devuelven por el output. Una función puede retornar uno o más elementos, o podría simplemente no retornar nada.\nreturn suma, return numero1, numero2, return, etc.\n\n\n\nPodemos ver la diferencia entre enviar algo por parámetro y usarlo por fuera de la función a continuación:\n\n\n\n\nEsto está mal\n\n\nEsto está bien\n\n\n\n\ndef saludar():\n  print(\"Hola, \" + nombre + \"!\")\n\nnombre = \"Manuela\"\nsaludar()\n\n\ndef saludar(persona):\n  print(\"Hola, \" + persona + \"!\")\n\nnombre = \"Manuela\"\nsaludar(nombre)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nComo podemos observar los nombres de los argumentos cuando se invoca y en la definición de la firma pueden ser los mismos o distintos. En este caso, la función sabe que está recibiendo algo como parámetro, y sabe que dentro de su cuerpo a este dato lo va a identificar como persona, pero no hace falta que la variable que nosotros le pasamos como parámetro también se llame persona: en este caso se llama nombre."
  },
  {
    "objectID": "unidad_2.html#tipos-de-datos",
    "href": "unidad_2.html#tipos-de-datos",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "2.3 Tipos de Datos",
    "text": "2.3 Tipos de Datos\n\n2.3.1 Datos Simples\nLos programas trabajan con una gran variedad de datos. Los datos más simples son los que ya vimos: números enteros, números de punto flotante y cadenas.\nPero dependiendo de la naturaleza o el tipo de información, cabrá la posibilidad de realizar distintas transformaciones aplicando operadores. Por eso, a la hora de representar información no sólo es importante que identifiquemos al dato y podamos conocer su valor, sino saber qué tipo de tratamiento podemos darle.\nTodos los lenguajes tienen tipos predefinidos de datos. Se llaman predefinidos porque el lenguaje ya los conoce: sabe cómo guardarlos en memoria y qué transformaciones puede aplicarles.\nEn Python, tenemos los siguientes tipos de datos:\n\n\n\n\n\n\n\n\nTipo\nDescripción\nEjemplo\n\n\n\n\nint\nNúmeros enteros\n5, 0, -5, 10000\n\n\nfloat\nNúmeros de punto flotante o reales\n3.14159, 1.0, 0.0\n\n\ncomplex\nNúmeros complejos\n(1, 2j), (1.0,-2.0j), (0,1j). La componente con j es la parte imaginaria.\n\n\nbool\nValores booleanos o valores lógicos\nTrue, False\n\n\nstr\nCadenas de caracteres\n\"Hola\", \"Python\", \"¡Hola, mundo!\", \"\" (cadena vacía, no contiene ningún caracter)\n\n\n\n\n\n\n\n\n\n¿Por qué se llaman “cadenas de caracteres”?\n\n\n\nPorque son una cadena de caracteres, es decir, una secuencia de caracteres. Por ejemplo, la cadena “Hola” está formada por los caracteres “H”, “o”, “l” y “a”. Esto nos permite acceder a cada uno de los caracteres de la cadena por separado si quisiéramos, o a porciones de una cadena, como vamos a ver más adelante.\nMás aún, podemos ver que el texto “hola” no será igual a “aloh” ni a “Holá”, porque son cadenas distintas.\nUn string permite almacenar cualquier tipo de caracter unicode dentro (letras, números, símbolos, emojis, etc.).\n\n\n\n\n2.3.2 Operadores Numéricos\nLos operadores son símbolos que representan una operación. Por ejemplo, el operador + representa la suma.\n\nPara transformar datos numéricos, emplearemos los siguientes operadores:\n\n\n\nSímbolo\nDefinición\nEjemplo\n\n\n\n\n+\nSuma\n5 + 3\n\n\n-\nResta\n5 - 3\n\n\n*\nProducto\n5 * 3\n\n\n**\nPotencia\n5 ** 2\n\n\n/\nDivisión\n5 / 3\n\n\n//\nDivisión entera\n5 // 3\n\n\n%\nMódulo o Resto\n5 % 3\n\n\n+=\nSuma abreviada\nx = 0x += 3\n\n\n-=\nResta abreviada\nx = 0x -= 3\n\n\n*=\nProducto abreviado\nx = 0x *= 3\n\n\n/=\nDivisión abreviada\nx = 0x /= 3\n\n\n//=\nDivisión entera abreviada\nx = 0x //= 3\n\n\n%=\nMódulo o Resto abreviado\nx = 0x %= 3\n\n\n\nComo pasa en matemática, para alterar cualquier precedencia (prioridad de operadores) se pueden usar paréntesis.\n\n(5 + 3) * 2\n\n16\n\n\n\n5 + (3 * 2)\n\n11\n\n\nEl orden de prioridad de ejecución para los operadores va a ser el mismo que en matemática.\n\n\n2.3.3 Operadores de Texto\nPara transformar datos de texto, emplearemos los siguientes operadores:\n\n\n\n\n\n\n\n\nSímbolo\nDefinición\nEjemplo\n\n\n\n\n+\nConcatenación\n\"Hola\" + \" \" + \"Mundo\"\n\n\n*\nRepetición\n\"Hola\" * 3\n\n\n+=\nConcatenación abreviada\nx = \"Hola\"x += \" Mundo\"\n\n\n*=\nRepetición abreviada\nx = \"Hola\"x *= 3\n\n\n[k] o [-k]\nAcceso a un caracter\n\"Hola\"[0]\"Hola\"[-1]\n\n\n[k1:k2]\nAcceso a una porción\n\"Hola\"[0:2]\"Hola\"[1:]\"Hola\"[:2]\"Hola\"[:]\n\n\n\nDe nuevo, para alterar precedencias, se deben usar ().\n\n2.3.3.1 Manipulando Strings\nSi bien esto se va a ahondar en la siguiente sesión de la materia, es importante saber que los strings, como se dijo más arriba, son un conjunto de caracteres. Pero no sólo un conjunto, sino un conjunto ordenado. Esto quiere decir que cada caracter tiene una posición dentro de la cadena, y que esa posición es importante.\n\nPor ejemplo, la cadena \"Hola\" tiene 4 caracteres: \"H\", \"o\", \"l\" y \"a\".\nLa posición de cada caracter es la siguiente:\n\n\n\nPosición\n0\n1\n2\n3\n\n\n\n\nCaracter\n“H”\n“o”\n“l”\n“a”\n\n\n\nEntonces, si queremos acceder al caracter \"H\", tenemos que usar la posición 0. Si queremos acceder al caracter \"a\", tenemos que usar la posición 3.\n\n\n\n\n\n\n\nTip\n\n\n\nPara acceder a un caracter de una cadena, usamos los corchetes ([]) y dentro de ellos la posición del caracter que queremos acceder.\n\n\n\n\nletra = \"Hola\"[0]\nprint(letra)\n\nH\n\n\nPero no sólo puedo obtener los caracteres en las posicione de la palabra, sino que puedo obtener slices o porciones de la misma, usando algo que vemos por primera vez: los rangos.\nUn rango tiene tres partes:\n[start : end : step]\n\nstart es el índice de inicio del rango. Si no se especifica, se toma el índice 0. El caracter en la posición de inicio siempre se incluye.\nend es el índice de fin del rango. Si no se especifica, se toma el índice final de la cadena. El caracter en la posición de fin nunca se incluye.\nstep es el tamaño del paso. Si no se especifica, se toma el valor 1.\n\n\nEjemplos:\n\n\n\n\n\n\n\n\n2.3.4 Input y Casteo\nCuando usamos la función input, el valor que devuelve es siempre una cadena. Esto es porque el usuario puede ingresar cualquier cosa, y no sabemos qué tipo de dato es.\n\nPor ejemplo, si le pedimos al usuario que ingrese un número, el usuario puede ingresar un número entero, un número de punto flotante, un número complejo, o incluso un texto. Entonces, el valor que devuelve input es siempre una cadena, y nosotros tenemos que transformarla al tipo de dato que necesitemos.\n\nPor ejemplo:\nedad = input(\"Indique su edad:\")\nprint(\"Su edad es:\", edad_nueva)\n\n\n\n\n\n\nImprimiendo Strings y Variables (Iterpolación de Cadenas)\n\n\n\nExisten muchas formas de concatenar variables con texto.\n\nUsando el operador +: \"Su edad es: \" + edad\nUsando el método fstring: f\"Su edad es: {edad}\"\nUsando el caracter ,: print(\"Su edad es:\", edad)\n\nLa forma más recomendada es la segunda, usando fstring. Pero dependerá de cada caso.\n\n\nEl problema es que, si bien nuestro código anterior funciona, no podemos operar edad como si fuese un número, porque es un string.\nEl siguiente código va a fallar:\nedad = input(\"Indique su edad:\")\nedad_nueva = edad + 1\nprint(\"Edad siguiente:\", edad_nueva)\n\n\n\nEjecución del bloque de código\n\n\nComo vemos, la consola nos arroja un error, o en términos simples decimos que “explotó”.\n\n\n\n\n\n\n¿Qué es un error?\n\n\n\nLos errores son información que nos da la consola para que podamos corregir nuestro código.\n\n\nEn este caso, nos dice que no se puede concatenar un string con un int.\n¿Por qué nos dice eso? Porque edad es un string: \"25\", y estamos tratando de sumarle 1, que es un int: 1.\n\nPara poder operar con edad como si fuese un número, tenemos que transformarla a un número. Esto se llama castear.\n\nPara castear un valor a un tipo de dato, usamos el nombre del tipo de dato, seguido de paréntesis y el valor que queremos castear.\nint(\"25\")\nDe esta forma, podemos modificar nuestro código anterior:\nedad = int(input(\"Indique su edad:\")) # Le agregamos int\nedad_nueva = edad + 1\nprint(\"Edad siguiente:\", edad_nueva)\nY obtenemos un código que funciona correctamente.\n\n\n\nEjecución del bloque de código\n\n\nDe esta forma, podemos castear a varios tipos de datos:\nnumero_entero = int(input(\"Ingrese un número\"))\npunto_flotante = float(input(\"Ingrese un número\"))\n\npunto_flotante2 = float(numero_entero)\n\nnumero_en_str = str(numero_entero)\nEjemplo:\nnombre_menor = input('Ingresá el nombre de un conocido/a:')\nedad_menor = int(input(f'Ingresá la edad de { nombre_menor } '))\nnombre_mayor = input(f'Cómo se llama el hermano/a mayor de {nombre_menor}? ')\ndiferencia = int(input(f'Cuántos años más grande es {nombre_mayor}?  '))\n\nedad_mayor = edad_menor + diferencia\n\nprint(nombre_menor,'tiene',edad_menor,'años')\nprint(nombre_mayor,'es mayor y tiene', edad_mayor, 'años')\n\n\n\nEjecución del bloque de código"
  },
  {
    "objectID": "unidad_2.html#bonus-track-algunas-funciones-predefinidas-de-python",
    "href": "unidad_2.html#bonus-track-algunas-funciones-predefinidas-de-python",
    "title": "2  Tipos de Datos, Expresiones y Funciones",
    "section": "2.4 Bonus Track: Algunas Funciones Predefinidas de Python",
    "text": "2.4 Bonus Track: Algunas Funciones Predefinidas de Python\n\n\n\n\n\n\nRecomendación\n\n\n\nTe recomendamos que te animes a probar estas funciones, para ver qué hacen y terminar de entenderlas.\n\n\n\n\n\n\n\n\n\n\nFunción\nDefinición\nEjemplo de uso\n\n\n\n\nprint()\nImprime un mensaje o valor en la consola\nprint(\"Hello, world!\")\n\n\ninput()\nLee una entrada de texto desde el usuario\nname = input(\"Enter your name: \")\n\n\nabs()\nDevuelve el valor absoluto de un número\nabs(-5)\n\n\nround()\nRedondea un número al entero más cercano\nround(3.7)\n\n\nint()\nConvierte un valor en un entero\nx = int(\"5\")\n\n\nfloat()\nConvierte un valor en un número de punto flotante\ny = float(\"3.14\")\n\n\nstr()\nConvierte un valor en una cadena de texto\nmessage = str(42)\n\n\nbool()\nConvierte un valor en un booleano\nis_valid = bool(1)\n\n\nlen()\nDevuelve la longitud (número de elementos) de un objeto\nlength = len(\"Hello\")\n\n\nmax()\nDevuelve el valor máximo entre varios elementos o una secuencia\nmax(4, 9, 2)\n\n\nmin()\nDevuelve el valor mínimo entre varios elementos o una secuencia\nmin(4, 9, 2)\n\n\npow()\nCalcula la potencia de un número\nresult = pow(2, 3)\n\n\nrange()\nGenera una secuencia de números\nnumbers = range(1, 5)\n\n\ntype()\nDevuelve el tipo de un objeto\ndata_type = type(\"Hello\")\n\n\nround()\nRedondea un número a un número de decimales específico\nrounded_num = round(3.14159, 2)\n\n\nisinstance()\nVerifica si un objeto es una instancia de una clase específica\nis_instance = isinstance(5, int)\n\n\nreplace()\nReemplaza todas las apariciones de un substring por otro\ntext = \"Hello, World!\"new_text = text.replace(\"Hello\", \"Hi\")\n\n\neval(&lt;expr&gt;)\nEvalúa una expresión\neval(\"2 + 2\")"
  },
  {
    "objectID": "unidad_3.html#decisiones",
    "href": "unidad_3.html#decisiones",
    "title": "3  Estructuras de Control",
    "section": "3.1 Decisiones",
    "text": "3.1 Decisiones\n\nEjemplo Leer un número y, si el número es positivo, imprimir en pantalla “Número positivo”.\n\nNecesitamos decidir de alguna forma si nuestro número \\(x\\) es positivo (&gt;0) o no. Para resolver este problema, introducimos una nueva instrucción, llamada condicional: if.\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nDonde if es una palabra reservada, &lt;expresion&gt; es una condición y &lt;cuerpo es un bloque de código que se ejecuta sólo si la condición es verdadera.\nPor lo tanto, antes de seguir explicando sobre la instrucción if, debemos entender qué es una condición. Estas expresiones tendrán valores del tipo sí o no.\n\n3.1.1 Expresiones Booleanas\nLas expresiones booleanas forman parte de la lógica binomial, es decir, sólo pueden tener dos valores: True o False. Estos valores no tienen elementos en común, por lo que no se pueden comparar entre sí. Por ejemplo, True &gt; False no tiene sentido. Y además, son complementarios: algo que no es True, es False; y algo que no es False, es True. Son las únicas dos opciones posibles.\nPython, además de los tipos numéricos como inty float, y de las cadenas de caracteres str, tiene un tipo de datos llamado bool. Este tipo de datos sólo puede tener dos valores: True o False. Por ejemplo:\nn = 3 # n es de tipo 'int' y tiene valor 3\nb = True # b es de tipo 'bool' y tiene valor True\n\n\n3.1.2 Expresiones de Comparación\nLas expresiones booleanas se pueden construir usando los operadores de comparación: sirven para comparar valores entre sí, y permiten construir una pregunta en forma de código.\nPor ejemplo, si quisiéramos saber si 5 es mayor a 3, podemos construir la expresión:\n\n5 &gt; 3\n\nTrue\n\n\nComo 5 es en efecto mayor a 3, esta expresión, al ser evaluada, nos devuelve el valor True.\nSi quisiéramos saber si 5 es menor a 3, podemos construir la expresión:\n\n5 &lt; 3\n\nFalse\n\n\nComo 5 no es menor a 3, esta expresión, al ser evaluada, nos devuelve el valor False.\nLas expresiones booleanas de comparación que ofrece Python son:\n\n\n\nExpresión\nSignificado\n\n\n\n\na == b\na es igual a b\n\n\na != b\na es distinto de b\n\n\na &lt; b\na es menor que b\n\n\na &gt; b\na es mayor que b\n\n\na &lt;= b\na es menor o igual que b\n\n\na &gt;= b\na es mayor o igual que b\n\n\n\nVeamos algunos ejemplos:\n5 == 5\n\n5 != 5\n\n5 &lt; 5\n\n5 &gt;= 5\n\n5 &gt; 4\n\n5 &lt;= 4\n\n\n\n\n\n\nTip\n\n\n\nTe recomendamos probar estas expresiones para ver qué valores devuelven. Podés hacerlo de dos formas:\n\nGuardando el resultado de la expresión en una variable, para luego imprimirla:\n\nresultado = 5 == 5\nprint(resultado)\n\nImprimiendo directamente el resultado de la expresión:\n\nprint(5 == 5)\n\n\n\n\n3.1.3 Operadores Lógicos\nAdemás de los operadores de comparación, Python también tiene operadores lógicos, que permiten combinar expresiones booleanas para construir expresiones más complejas. Por ejemplo, quizás no sólo queremos saber si 5 es mayor a 3, sino que también queremos saber si 5 es menor que 10. Para esto, podemos usar el operador and:\n5 &gt; 3 and 5 &lt; 10\nPython tiene tres operadores lógicos: and, or y not. Veamos qué hacen:\n\n\n\n\n\n\n\nOperador\nSignificado\n\n\n\n\na and b\nEl resultado es Truesolamente si aes Truey bes True. Ambos deben ser True, de lo contrario devuelve False.\n\n\na or b\nEl resultado es Truesi aes True o bes True (o ambos). Si ambos son False, devuelve False.\n\n\nnot a\nEl resultado es True si aes False, y viceversa.\n\n\n\nAlgunos ejemplos:\n\n5 &gt; 2 and 5 &gt; 3\n\nTrue\n\n\n\n5 &gt; 2 or 5 &gt; 3\n\nTrue\n\n\n\n5 &gt; 2 and 5 &gt; 6\n\nFalse\n\n\n\n5 &gt; 2 or 5 &gt; 6\n\nTrue\n\n\n\n5 &gt; 6\n\nFalse\n\n\n\nnot 5 &gt; 6\n\nTrue\n\n\n\n5 &gt; 2\n\nTrue\n\n\n\nnot 5 &gt; 2\n\nFalse\n\n\n\n\n\n\n\n\nPrioridad de Operadores\n\n\n\n\n\nLas expresiones lógicas complejas (con más de un operador), se resuelven al igual que en matemáticas: respetando precedencias y de izquierda a derecha. También admiten el uso de () para alterar las precedencias.\nSin embargo, si no tenemos precedencias explícitas con (), Python prioriza resolver primero los and, luego los or y por último los not.\nEjemplos:\n\nTrue or False and False\n\nTrue\n\n\nPor la prioridad del and, primero se resuelve False and False, que da False. Luego, se resuelve True or False, que da True.\n\nTrue or False or False\n\nTrue\n\n\nComo no hay and, se resuelve de izquierda a derecha. Primero se resuelve True or False, que da True. Luego, se resuelve True or False, que da True.\n\n(True or False) and False\n\nFalse\n\n\nComo hay paréntesis, se resuelve primero lo que está dentro de los paréntesis. True or False da True. Luego, True and False da False.\n\n\n\n\n\n3.1.4 Comparaciones Simples\nVolvamos al problema inicial: Queremos saber, dado un número \\(x\\), si es positivo o no, e imprimir un mensaje en consecuencia.\nRecordemos la instrucción if que acabamos de introducir y que sirve para tomar decisiones simples. Esta instrucción tiene la siguiente estructura:\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\ndonde:\n\n&lt;expresion&gt;debe ser una expresión lógica.\n&lt;cuerpo&gt;es un bloque de código que se ejecuta sólo si la expresión es verdadera.\n\n\n\n\nDiagrama de Flujo para la instrucción if\n\n\nComo ahora ya sabemos cómo construir condiciones de comparación, vamos a comparar si nuestro número x es mayor a 0:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n\nPodemos probarlo:\n\nimprimir_si_positivo(5)\nimprimir_si_positivo(-5)\nimprimir_si_positivo(0)\n\nNúmero positivo\n\n\nComo vemos, si el número es positivo, se imprime el mensaje. Pero si el número no es positivo, no se imprime nada. Necesitamos además agregar un mensaje “Número no positivo”, si es que la condición no se cumple.\nModifiquemos el diseño: 1. Si \\(x&gt;0\\), se imprime “Número positivo”. 2. En caso contrario, se imprime “Número no positivo”.\nPodríamos probar con el siguiente código:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  if not x &gt; 0:\n      print(\"Número no positivo\")\n\nOtra solución posible es:\n\ndef imprimir_si_positivo(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  if x &lt;= 0:\n      print(\"Número no positivo\")\n\nAmbas están bien. Si lo probamos, vemos que funciona:\n\nimprimir_si_positivo(5)\nimprimir_si_positivo(-5)\nimprimir_si_positivo(0)\n\nNúmero positivo\nNúmero no positivo\nNúmero no positivo\n\n\nSin embargo, hay una mejor forma de hacer esta función. Existe una condición alternativa para la estructura de decisión if, que tiene la forma:\nif &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nelse:\n    &lt;cuerpo&gt;\ndonde if y else son palabras reservadas. Su efecto es el siguiente:\n\nSe evalúa la &lt;expresion&gt;.\nSi la &lt;expresion&gt; es verdadera, se ejecuta el &lt;cuerpo&gt; del if.\nSi la &lt;expresion&gt; es falsa, se ejecuta el &lt;cuerpo&gt; del else.\n\n\n\n\nDiagrama de Flujo para la instrucción if-else\n\n\nPor lo tanto, podemos reescribir nuestra función de la siguiente forma:\n\ndef imprimir_si_positivo_o_no(x): # le cambiamos el nombre\n  if x &gt; 0:\n      print(\"Número positivo\")\n  else:\n      print(\"Número no positivo\")\n\nProbemos:\n\nimprimir_si_positivo_o_no(5)\nimprimir_si_positivo_o_no(-5)\nimprimir_si_positivo_o_no(0)\n\nNúmero positivo\nNúmero no positivo\nNúmero no positivo\n\n\n¡Sigue funcionando!\nLo importante a destacar es que, si la condición del if es verdadera, se ejecuta el &lt;cuerpo&gt; del if y no se ejecuta el &lt;cuerpo&gt; del else. Y viceversa: si la condición del if es falsa, se ejecuta el &lt;cuerpo&gt; del else y no se ejecuta el &lt;cuerpo&gt; del if. Nunca se ejecutan ambos casos, porque son caminos paralelos que no se cruzan, como vimos en el diagrama de flujo más arriba.\n\n\n3.1.5 Múltiples decisiones consecutivas.\nSupongamos que ahora queremos imprimir un mensaje distinto si el número es positivo, negativo o cero. Podríamos hacerlo con dos decisiones consecutivas:\n\ndef imprimir_si_positivo_negativo_o_cero(x):\n  if x &gt; 0:\n      print(\"Número positivo\") # cuerpo del primer if\n  else:\n      if x == 0:                      #\n          print(\"Número cero\")        #\n      else:                           #\n          print(\"Número negativo\")    # todo esto es el cuerpo del primer else\n\nA esto se le llama anidar, y es donde dentro de unas ramas de la decisión (en este caso, la del else), se anida una nueva decisión. Pero no es la única forma de implementarlo. Podríamos hacerlo de la siguiente forma:\n\ndef imprimir_si_positivo_negativo_o_cero(x):\n  if x &gt; 0:\n      print(\"Número positivo\")\n  elif x == 0:\n      print(\"Número cero\")\n  else:\n      print(\"Número negativo\")\n\nLa estructura elif es una abreviatura de else if. Es decir, es un else que tiene una condición. Su efecto es el siguiente:\n\n\n\nDiagrama de Flujo para la instrucción if-elif-else del ejemplo\n\n\n\nSe evalúa la &lt;expresion&gt; del if.\nSi la &lt;expresion&gt; es verdadera, se ejecuta el &lt;cuerpo&gt; del if.\nSi la &lt;expresion&gt; es falsa, se evalúa la &lt;expresion&gt; del elif.\nSi la &lt;expresion&gt; del elif es verdadera, se ejecuta su &lt;cuerpo&gt;.\nSi la &lt;expresion&gt; del elif es falsa, se ejecuta el &lt;cuerpo&gt; del else.\n\n\n\n\n\n\n\nSabías que… ?\n\n\n\n\n\nEn Python se consideran verdaderos (True) también todos los valores numéricos distintos de 0, las cadenas de caracteres que no sean vacías, y cualquier valor que no sea vacío en general. Los valores nulos o vacíos son falsos.\nif x == 0:\nes equivalente a:\nif not x:\nY además, existe el valor especial None, que representa la ausencia de valor, y es considerado falso. Podemos preguntar si una variable tiene el valor None usando el operador is:\nif x is None:\no también:\nif not x:\n\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nDebemos calcular el pago de una persona empleada en nuestra empresa. El cálculo debe hacerse por la cantidad de horas trabajadas, y se le debe pedir al usuario la cantidad de horas y cuánto vale cada hora.\nAdicionalmente, se abona un plus fijo de guardería a todo empleado/a con infantes a su cargo. Y se paga un 10% de incentivo a todo empleado/a que haya trabajado 30 horas o más y no reciba el plus por guardería.\n\nPista: pensar los distintos tipos de liquidación:\na) Empleado/a con menos de 30 horas y sin infantes a cargo.\nb) Empleado/a con 30 horas o más y sin infantes a cargo.\nc) Empleado/a con menos de 30 horas y con infantes a cargo.\nd) Empleado/a con 30 horas o más y con infantes a cargo.\n\n\n\n\n\n\nAyuda: Flujo de la resolución\n\n\n\n\n\n\n\n\nDiagrama de Flujo para el desafío"
  },
  {
    "objectID": "unidad_3.html#ciclos-y-rangos",
    "href": "unidad_3.html#ciclos-y-rangos",
    "title": "3  Estructuras de Control",
    "section": "3.2 Ciclos y Rangos",
    "text": "3.2 Ciclos y Rangos\nSupongamos que en una fábrica se nos pide hacer un procedimiento para entrenar al personal nuevo. Para comenzar se nos encarga la descripción de uno muy simple: descarga de cajas de material del camión del proveedor y almacenamiento en el depósito. Así que aplicamos lo que venimos aprendiendo hasta ahora sobre algoritmos y describimos la operación para la descarga de 3 cajas:\n1 Abrir la puerta del depósito y encender luces \n2 Ir al garage o playón donde estacionó el camión \n3 Abrir las puertas traseras de la caja del transporte\n\n4 Tomar una caja con ambas manos, asegurándola para no tirarla \n5 Caminar sosteniendo la caja hasta el depósito \n6 Colocar la caja sobre el piso en el sector correspondiente \n7 Ir al garage o playón donde estacionó el camión\n\n8 Tomar OTRA caja con ambas manos, asegurándola para no tirarla \n9 Caminar sosteniendo la caja hasta el depósito \n10 Colocar la caja sobre la caja anterior \n11 Ir al garage o playón donde estacionó el camión\n\n12 Tomar OTRA caja con ambas manos, asegurándola para no tirarla \n13 Caminar sosteniendo la caja hasta el depósito \n14 Colocar la caja sobre la caja anterior\n\n15 Apagar luces y cerrar puerta del depósito \n16 Ir al garage o playón donde estacionó el camión \n17 Cerrar y trabar puertas del camión \n18 Avisar fin de descarga al transportista\nYa lo tenemos. Ahora la persona a cargo dice que en el camión suelen venir entre 5 y 15 cajas de material y pide que definas el mismo procedimiento para todos los casos posibles. Notemos que se repiten las instrucciones 2, 3, 4, 5 y 6 para cada caja ¿Qué hacemos? ¿Vamos a seguir copiando y pegando las instrucciones para cada caja? ¿Y si algún día vienen más de 15 o menos de 5? ¿Vamos a tener una lista de instrucciones distinta para cada cantidad de cajas que puedan venir? Parece ser necesario hacer algo más genérico que le facilite la vida a todos. Una nueva versión:\n1 Abrir la puerta del depósito y encender luces \n2 Ir al garage o playón donde estacionó el camión \n3 Abrir las puertas traseras de la caja del transporte \n4 Tomar una caja con ambas manos, asegurándola para no tirarla \n5 Caminar sosteniendo la caja hasta el depósito \n6 Si es la primera caja, colocarla sobre el piso en el sector correspondiente;\nsi no, apilarla sobre la anterior;\nsalvo que ya haya 3 apiladas,\nen ese caso colocarla a la derecha sobre el piso \n7 Ir al garage o playón donde estacionó el camión \n\n8 Repetir 4,5,6,7 mientras queden cajas para descargar \n\n9 Cerrar y trabar puertas del camión \n10 Avisar fin de descarga al transportista \n11 Volver a depósito \n12 Apagar luces y cerrar puerta del depósito\nEsta descripción es bastante más compacta y cubre todas las posibles cantidades de cajas en un envío (habituales y excepcionales), de modo que con una única página en el manual de procedimientos será suficiente.\nSin embargo, los algoritmos que venimos escribiendo se parecen más al primer procedimiento que al segundo. ¿Cómo podemos mejorarlos?\n\n\n\n\n\n\nCiclos\n\n\n\nEl ciclo, bucle o sentencia iterativa es una instrucción que permite ejecutar un bloque de código varias veces. En Python, existen dos tipos de ciclos: while y for.\n\n\n\n3.2.1 Ciclo for\nLa instrucción for nos indica que queremos repetir un bloque de código una cierta cantidad de veces. Por ejemplo, si queremos imprimir los números del 1 al 10, podemos hacerlo de la siguiente forma:\n\nfor i in range(1, 11):\n    print(i)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nEl ciclo for incluye una línea de inicialización y una línea de &lt;cuerpo&gt;, que puede tener una o más instrucciones. El ciclo definido es de la forma:\nfor &lt;nombre&gt; in &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nEl ciclo se dice definido porque una vez evaluada la &lt;expresion&gt;, se sabe cuántas veces se va a ejecutar el &lt;cuerpo&gt;: tantas veces como elementos tenga la &lt;expresion&gt;.\nLa expresión puede indicarse con range:\n\nrange(n) devuelve una secuencia de números desde 0 hasta n-1.\nrange(a, b) devuelve una secuencia de números desde a hasta b-1.\nrange(a, b, c) devuelve una secuencia de números desde a hasta b-1, de a c en c.\n\nSe podría decir que el range puede recibir 3 valores: range(start, end, step) o range(inicio, fin, paso), donde:\n\nstart o inicio es el valor inicial de la secuencia. Por defecto es 0.\nend o fin es el valor final de la secuencia. No se incluye en la secuencia.\nstep o paso es el incremento entre cada elemento de la secuencia. Por defecto es 1.\n\nSi le pasamos un sólo parámetro, lo toma como end.\nSi le pasamos dos, los toma como start y end.\nY si le pasamos tres, los toma como start, end y step.\n\n\n\n\n\n\nNote\n\n\n\n¿Te suena quizás a algo que ya vimos? Quizás… ¿los slices de las cadenas de caracteres?\n\n\nAdemás, la variable &lt;nombre&gt; va a ir tomando el valor de cada elemento de la &lt;expresion&gt; en cada iteración. En nuestro ejemplo de imprimir los números del 1 al 10, vemos que i toma los valores 1, 2, 3, 4, 5, 6, 7, 8, 9 y 10, en ese orden.\n\n\nEjemplo\nSe pide una función que imprima todos los números pares entre dos números dados a y b. Se considera que a y b son siempre números enteros positivos, y que a es menor que b.\n\n\ndef imprimir_pares(a, b):\n  for i in range(a, b):\n    if i % 2 == 0: # si el resto de dividir por 2 es cero, es par\n      print(i)\n\nimprimir_pares(1,15)\n\n2\n4\n6\n8\n10\n12\n14\n\n\n\n\n\nEjemplo\nSe pide una función que imprima todos los números del 1 al 10, en orden inverso.\n\n\ndef imprimir_inverso():\n  for i in range(10, 0, -1):\n      print(i)\n\nimprimir_inverso()\n\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n\n\n\n\n\n3.2.1.1 Iterables\nComo dijimos más arriba, la expresión del for puede ser cualquier expresión que devuelva una secuencia de valores. A estas expresiones se las llama iterables.\nUn ciclo for también podría iterar sobre elementos de una lista (tema que vamos a ver más adelante), o sobre caracteres de una palabra. Por ejemplo:\n\nfor num in [1, 3, 7, 5, 2]:\n    print(num)\n\n1\n3\n7\n5\n2\n\n\n\nfor c in \"Hola\":\n    print(c)\n\nH\no\nl\na\n\n\n\n\n\n3.2.2 Ciclo while\nLa instrucción while nos indica que queremos repetir un bloque de código mientras se cumpla una condición. Por ejemplo, si queremos imprimir los números del 1 al 10, podemos hacerlo de la siguiente forma:\n\ni = 1\nwhile i &lt; 11:\n    print(i)\n    i += 1\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nEl ciclo while incluye una línea de inicialización y una línea de &lt;cuerpo&gt;, que puede tener una o más instrucciones. El ciclo definido es de la forma:\nwhile &lt;expresion&gt;:\n    &lt;cuerpo&gt;\nEl ciclo se dice indefinido porque una vez evaluada la &lt;expresion&gt;, no se sabe cuántas veces se va a ejecutar el &lt;cuerpo&gt;: se ejecuta mientras la &lt;expresion&gt; sea verdadera.\nPara usar la instrucción while, tenemos cuatro aspectos para armar y afinar correctamente:\n\nCuerpo\nCondición\nEstado Previo\nPaso\n\nAntes, para la instrucción for, sólo considerábamos el cuerpo y la condición. Ahora, además, tenemos que considerar el estado previo y el paso.\nEl cuerpo es la porción de código que se repetirá mientras la condición sea verdadera.\nLa condición es la expresión booleana que se evalúa para decidir si se ejecuta el cuerpo o no.\nEl estado previo es el estado de las variables antes de ejecutar el cuerpo. En general, se refiere al estado de las variables que participan de la condición.\nEl paso es la porción de código que modifica el estado previo. En general, se refiere a la modificación de las variables que participan de la condición.\n\n\n\n\n\n\n\nWarning\n\n\n\nCon los ciclos while hay que tener mucho cuidado de no caer en un loop infinito. Esto sucede cuando la condición siempre es verdadera, y el cuerpo no modifica el estado previo. Por ejemplo:\nwhile True: # más adelante sobre el uso de `while True`\n    print(\"Hola\")\no bien:\ni = 0\nwhile i &lt; 10:\n    print(i) # el valor de i nunca cambia\n\n\n\nEjercicio\nRepetir el ejercicio 7.b de la guía 2 usando un ciclo while. Repetir usando un ciclo for. ¿Qué diferencias hay entre ambos?  \n\n\n\n3.2.3 Break, Continue y Return\nbreak y continueson dos palabras clave en Python que se utilizan en bucles (tanto for como while) para alterar el flujo de ejecución del bucle.\n\n3.2.3.1 Break\nLa declaración break se usa para salir inmediatamente de un bucle antes de que se complete su iteración normal. Cuando se encuentra una declaración break dentro de un bucle, el bucle for o while se detiene inmediatamente y continúa con la ejecución de las instrucciones que están después del mismo.\nPor ejemplo, supongamos que queremos encontrar al primer número múltiplo de 3 entre 10 y 30:\n\nnumero = 10\nwhile numero &lt;= 30:\n  if numero % 3 == 0:\n      print(\"El primer número múltiplo de 3 es:\", numero)\n      break\n  numero += 1\n\nEl primer número múltiplo de 3 es: 12\n\n\n\nfor numero in range(10, 31):\n  if numero % 3 == 0:\n      print(\"El primer número múltiplo de 3 es:\", numero)\n      break\n\nEl primer número múltiplo de 3 es: 12\n\n\n\n\n3.2.3.2 Continue\nLa declaración continue se usa para omitir el resto del código dentro de una iteración actual del bucle y continuar con la siguiente iteración. Cuando se encuentra una declaración continue dentro de un bucle, el bucle for o while salta a la siguiente iteración del bucle sin ejecutar las instrucciones que están después del continue.\nPor ejemplo, supongamos que queremos imprimir todos los números entre 1 y 20, excepto los múltiplos de 4:\n\nnumero = 1\nwhile numero &lt;= 20:\n  if numero % 4 == 0:\n      numero += 1\n      continue\n  print(numero)\n  numero += 1\n\n1\n2\n3\n5\n6\n7\n9\n10\n11\n13\n14\n15\n17\n18\n19\n\n\n\nfor numero in range(1, 21):\n  if numero % 4 == 0:\n      continue\n  print(numero)\n\n1\n2\n3\n5\n6\n7\n9\n10\n11\n13\n14\n15\n17\n18\n19\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotemos que tanto para el uso de break como de continue, si el código se encuentra con uno de ellos en la ejecución, no ejecuta nada posterior a ellos: en el caso de break, corta o interrumpe la ejecución del bucle; en el case de continue, saltea el resto del código de esa iteración y pasa a la siguiente, volviendo a evaluar la condición si el bucle es while.\n\n\n\n\n3.2.3.3 Return\nCuando estamos dentro de una función, la instrucción return nos permite devolver un valor y salir de la función. Ahora, si además estamos dentro de un ciclo, también nos permite salir del mismo sin ejecutar el resto del código.\nPor ejemplo:\n\ndef obtener_primer_par_desde(n):\n  for num in range(n, n+10):\n    print(f\"Analizando si el número {num} es par\")\n    if num % 2 == 0:\n      return num\n  return None\n\n\nobtener_primer_par_desde(9)\n\nAnalizando si el número 9 es par\nAnalizando si el número 10 es par\n\n\n10\n\n\nComo vemos, la función obtener_primer_par_desde recibe un número n, y devuelve el primer número par que encuentra a partir de n. Si no encuentra ningún número par, devuelve None.\nSi encuentra un número par, no sigue analizando el resto de los números. Usa return para salir del ciclo y devuelve el número encontrado.\n\n\n\n3.2.4 Consideraciones del While\nEs importante no ser redundantes con el código y no “hacer preguntas” que ya sabemos.\nwhile &lt;condicion&gt;:\n  &lt;cuerpo&gt;\n\n&lt;codigo cuando ya no se cumple la condición&gt;\nVeamos un ejemplo:\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\nif numero == 3:\n  print(\"El número es 3\")\nelse:\n  print(\"El número no es 3\")\nEl output va a ser siempre el mismo:\n1\n2\n3\nEl número es 3\n¿Por qué? Porque nuestra condición del while es lo que dice “mientras esto se cumpla, yo repito el bloque del código de adentro”. Nuestra condición es que numero &lt; 3. En el momento en que numero llega a 3, el bucle whiledeja de cumplir con la condición, y la ejecución se corta, se termina con el bucle.\nEs decir, el bloque\nif numero == 3:\n  print(\"El número es 3\")\nsiempre se ejecuta.\nY el bloque\nelse:\n  print(\"El número no es 3\")\nnunca se ejecuta.\nPor lo tanto, podemos reescribir el código de la siguiente forma:\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\nprint(\"El número es 3\")\n\nDe la misma forma, no tendría sentido hacer algo así:\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n  continue\n\n  if numero == 3:\n    break\n\nif numero == 3 está absolutamente de más. Si numero es 3, el bucle while no se ejecuta, por lo que nunca se va a llegar a esa línea de código. No es necesario “re-chequear” la condición del while dentro del mismo, porque asumimos que si llegamos a esa línea de código, es porque la condición se cumplió. Por lo tanto, podemos reescribir el código de la siguiente forma:\n\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n  continue\n\nAhora, el continue está de más también, porque se usa cuando nosotros queremos forzar a que el ciclo pase a la siguiente iteración. Pero en este caso, el ciclo ya va a pasar a la siguiente iteración, porque estamos en la última línea del cuerpo.\n\nEste es nuestro código final, escrito de forma correcta:\nnumero = 0 \nwhile numero &lt; 3:\n  print(numero)\n  numero += 1\n\n3.2.4.1 While True\nLa instrucción while está hecha para que se ejecute mientras la condición sea verdadera. Pero, ¿qué pasa si usamos while True? Lo que pasa al usar while True es que nuestro código se vuelve más propenso al error: si no tenemos cuidado, podemos caer en un loop infinito.\n\nComo no tenemos una condición a evaluar ni modificar en cada iteración, el bucle se ejecuta infinitamente. Dependería de nosotros, como programadores, que el bucle se corte en algún momento. Es decir, dependería de que nos acordemos de poner dentro del while alguna decisión que haga que el bucle se corte. Y si por alguna razón no nos acordamos, el bucle se ejecutaría infinitamente, dejando al programa “congelado” o “colgado”, sin responder, y usando todos los recursos de la computadora.\nEn pocas palabras, podemos afirmar que el uso de while True en Python es una mala práctica de programación, y recomendamos evitarla fuertemente.\n\n\n3.2.4.2 Modificando la Condición\nwhile &lt;condicion&gt;:\n  &lt;cuerpo&gt;\nLa mejor decisión que se puede tomar para el  de un bloque while es asumir que, durante toda su ejecución exceptuando la última línea, la condición se cumple. Es decir, que el cuerpo del bucle se ejecuta mientras la condición sea verdadera. Por lo tanto, si queremos modificar la condición, debemos hacerlo en la última línea del cuerpo.\nPor ejemplo, esto no es correcto:\n\n# Se deben imprimir los números 0, 1, 2\nnumero = 0\nwhile numero &lt; 3:\n  numero += 1     # actualización de la condición\n  print(numero)\n\n1\n2\n3\n\n\nComo vemos, se imprimen los números 1, 2, 3; pero no el 0. Esto es porque estamos modificando la condición ni bien empieza el bucle, y no en la última línea del cuerpo.\nLa forma correcta de hacerlo sería:\n\n# Se deben imprimir los números 0, 1, 2\nnumero = 0\nwhile numero &lt; 3:\n  print(numero)\n  numero += 1     # actualización de la condición\n\n0\n1\n2\n\n\nDe esta forma, todo lo que se encuentre antes de la última línea del cuerpo se ejecuta mientras la condición sea verdadera. Y la última línea del cuerpo es la que modifica la condición.\n\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir un programa que pida al usuario un número entero positivo y muestre por pantalla todos los números pares desde 1 hasta ese número.\nResolver primero usando un ciclo while y luego usando un ciclo for.\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir un programa que pida al usuario un número par. Mientras el usuario ingrese números que no cumplan con lo pedido, se lo debe volver a solicitar.\nPista: resolver usando while."
  },
  {
    "objectID": "unidad_4.html#introducción-secuencias",
    "href": "unidad_4.html#introducción-secuencias",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.1 Introducción: Secuencias",
    "text": "4.1 Introducción: Secuencias\nUna secuencia es una serie de elementos ordenados que se suceden unos a otros.\nUna secuencia en Python es un grupo de elementos con una organización interna, que se alojan de manera contigua en memoria.\nLas secuencias son tipos de datos que pueden ser iterados, y que tienen un orden definido. Las secuencias más comunes son los rangos, las cadenas de caracteres, las listas y las tuplas. En este capítulo vamos a ver las características de cada una de ellas y cómo podemos manipularlas."
  },
  {
    "objectID": "unidad_4.html#rangos",
    "href": "unidad_4.html#rangos",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.2 Rangos",
    "text": "4.2 Rangos\nLos rangos ya los hemos visto antes, pero lo que no habíamos definido es que son secuencias. Los rangos representan específicamente una secuencia de números inmutable.\nLos rangos se definen con la función range(), que recibe como parámetros el inicio, el fin y el paso. El inicio es opcional y por defecto es 0, el paso también es opcional y por defecto es 1.\n\n\n\n\n\n\nNote\n\n\n\nPara más información de los rangos, ver la unidad 3."
  },
  {
    "objectID": "unidad_4.html#cadenas-de-caracteres",
    "href": "unidad_4.html#cadenas-de-caracteres",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.3 Cadenas de Caracteres",
    "text": "4.3 Cadenas de Caracteres\nUn string es un tipo de secuencia que sólo admite caracteres como elementos. Los strings son inmutables, es decir, no se pueden modificar una vez creados.\nInternamente, cada uno de los caracteres se almacenará de forma contigua en memoria. Es por esto que podemos acceder a cada uno de los caracteres de un string a través de su índice haciendo uso de [].\n\n\n\nÍndice\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\nLetra\nH\no\nl\na\n\nM\nu\nn\nd\no\n\n\n\nHasta ahora, vimos que:\n\nLas cadenas de caracteres pueden ser concatenadas con el operador +:\n\n\nsaludo = \"Hola\"\ndespedida = \"Chau\"\nprint(saludo + despedida)\n\nHolaChau\n\n\n\nLas cadenas de caracteres pueden ser sliceadas o incluso acceder a un único elemento usando []:\n\n\nsaludo = \"Hola Mundo\"\nprint(saludo[0:4])\nprint(saludo[5])\n\nHola\nM\n\n\nPodemos agregar también que:\n\nLas cadenas de caracteres pueden ser multiplicadas por un número entero (y el resultado es la concatenación de la cadena consigo misma esa cantidad de veces):\n\n\nsaludo = \"Hola\"\nprint(saludo * 3)\n\nHolaHolaHola\n\n\nAdicional a esas 3 operaciones, las cadenas de caracteres tienen una gran cantidad de métodos que nos permiten manipularlas. Veamos algunos de ellos.\n\n4.3.1 Métodos de Cadenas de Caracteres\nTodos los métodos de las cadenas de caracteres devuelven una nueva cadena de caracteres o un valor, y no modifican la cadena original (ya que las cadenas de caracteres son inmutables).\n\n4.3.1.1 Longitud de una Cadena\nSe puede averiguar la cantidad de caracteres que conforman una cadena utilizando la función predefinida len():\n\nprint(len(\"Pensamiento Computacional\"))\n\n25\n\n\nExiste también una cadena especial, la cadena vacía (ya la hemos visto antes), que es la cadena que no contiene ningún caracter entre las comillas. La longitud de la cadena vacía es 0.\n\n\n\n\n\n\nTip: Len e Índices de la Cadena\n\n\n\n\n\nEs interesante notar lo siguiente: si tenemos una cadena de caracteres de longitud n, los índices de la cadena van desde 0 hasta n-1. Esto es porque el índice n no existe, ya que el primer índice es 0 y el último es n-1.\nVeámoslo con un ejemplo: tenemos el caracter Hola.\n\n\n\nÍndice\n0\n1\n2\n3\n\n\n\n\nLetra\nH\no\nl\na\n\n\n\nLa longitud de la cadena es 4, pero el último índice es 3. Si intentamos acceder al índice 4, nos dará un error:\nsaludo = \"Hola\"\nprint(saludo[4])\nIndexError: string index out of range\nLo que nos indica el error es que el índice está fuera del rango de la cadena. Esto es porque el índice 4 no existe, ya que el último índice es 3. El largo de la cadena es 4, y el último índice disponible es 4-1=3.\n\nLos índices positivos (entre 0 y len(s) - 1) son los caracteres de la cadena del primero al último.\nLos índices negativos (entre -len(s) y -1) proveen una notación que hace más fácil indicar cuál es el último caracter de la cadena: s[-1] es el último caracter, s[-2] es el penúltimo, y así sucesivamente.\n\n\nsaludo = \"Hola\"\nprint(saludo[-1])\nprint(saludo[-2])\nprint(saludo[-3])\nprint(saludo[-4])\n\na\nl\no\nH\n\n\nAdemás, el uso de índices negativos también es válido para slices:\n\nsaludo = \"Hola\"\nprint(saludo[-3:-1])\n\nol\n\n\nAl usar índices negativos, es importante no salirse del rango de los índices permitidos.\n\n\n\n\n\n4.3.1.2 Recorriendo Cadenas de Caracteres\nDijimos que los strings son secuencias, y por lo tanto podemos iterar sobre ellos. Esto significa que podemos recorrerlos con un ciclo for:\n\nsaludo = \"Hola Mundo\"\nfor caracter in saludo:\n    print(caracter)\n\nH\no\nl\na\n \nM\nu\nn\nd\no\n\n\nSi bien esto ya lo habíamos nombrado en la sección anterior como una posibilidad, ahora sabemos por qué: todas las secuencias son iterables, y por lo tanto, podemos recorrerlas.\n\n\n4.3.1.3 Buscando Subcadenas\nEl operador in nos permite saber si una subcadena se encuentra dentro de otra cadena. En la guía de la unidad 3 te pedimos que investigues acerca del operador in y not in para el ejercicio de vocales y consonantes.\na in b es una expresión (¿qué era una expresión?, repasar de ser necesario la unidad 3) que devuelve True si a es una subcadena de b, y False en caso contrario.\n\nprint( \"Hola\" in \"Hola Mundo\")\n\nTrue\n\n\nAl ser una expresión booleana, se puede usar como condición tanto de un if como de un while:\n\nif \"Hola\" in \"Hola Mundo\":\n    print(\"Se encontró una subcadena!\")\n\nSe encontró una subcadena!\n\n\n\nEjercicio\n1. Investigar, para un string dado \\(s\\), cuál es el resultado del slice s[:]\n2. Investigar, para un string dado \\(s\\), cuál es el resultado del slice s[j:] con \\(j\\) un número entero negativo.\n\n\n\n4.3.1.4 Inmutabilidad\nLas cadenas son inmutables. Esto significa que no se pueden modificar una vez creadas. Por ejemplo, si queremos cambiar un caracter de una cadena, no podemos hacerlo:\nsaludo = \"Hola Mundo\"\nsaludo[0] = \"h\"\nTypeError: 'str' object does not support item assignment\nSi queremos realizar una modificación sobre una cadena, lo que tenemos que hacer es crear una nueva cadena con la modificación que queremos:\nsaludo = \"Hola Mundo\"\nsaludo = \"h\" + saludo[1:]\nprint(saludo)\n\n\n4.3.1.5 Otros Métodos de Cadenas de Caracteres\nLas cadenas de caracteres tienen una gran cantidad de métodos que nos permiten manipularlas. Algunos ya los vimos, como len(), in y not in. Veamos otros.\n\n\n\n\n\n\n\n\nMétodo\nDescripción\nEjemplo\n\n\n\n\ncapitalize()\nDevuelve una copia de la cadena con el primer caracter en mayúscula y el resto en minúscula\n\"hola mundo\".capitalize() devuelve \"Hola mundo\"\n\n\ncount(subcadena)\nDevuelve la cantidad de veces que aparece la subcadena en la cadena\n\"Hola mundo\".count(\"o\") devuelve 2\n\n\nfind(subcadena)\nDevuelve el índice de la primera aparición de la subcadena en la cadena, o -1 si no se encuentra. Cada vez que se llama, devuelve la siguiente aparición\n\"Hola mundo\".find(\"mundo\") devuelve 5\n\n\nupper()\nDevuelve una copia de la cadena con todos los caracteres en mayúscula\n\"Hola mundo\".upper() devuelve \"HOLA MUNDO\"\n\n\nlower()\nDevuelve una copia de la cadena con todos los caracteres en minúscula\n\"Hola mundo\".lower() devuelve \"hola mundo\"\n\n\nstrip()\nDevuelve una copia de la cadena sin los espacios en blanco al principio y al final\n\" Hola mundo \".strip() devuelve \"Hola mundo\".\n\n\nstrip(subcadena)\nDevuelve una copia de la cadena sin los caracteres de la subcadena al principio y al final. Sólo funciona para quitar elementos de los extremos del string\n\"Hola mundo\".strip(\"do\") devuelve \"Hola mun\"\n\n\nreplace(subcadena1, subcadena2)\nDevuelve una copia de la cadena reemplazando todas las apariciones de la subcadena1 por la subcadena2\n\"Hola mundo\".replace(\"mundo\", \"amigos\") devuelve \"Hola amigos\"\n\n\nsplit()\nDevuelve una lista de subcadenas separando la cadena por los espacios en blanco\n\"Hola mundo  \".split() devuelve [\"Hola\", \"mundo\"]\n\n\nsplit(separador)\nDevuelve una lista de subcadenas separando la cadena por el separador\n\"Hola, mundo\".split(\", \") devuelve [\"Hola\", \"mundo\"]\n\n\nisdigit()\nDevuelve True si todos los caracteres de la cadena son dígitos, False en caso contrario\n\"123\".isdigit() devuelve True\n\n\nisalpha()\nDevuelve True si todos los caracteres de la cadena son letras, False en caso contrario\n\"Hola\".isalpha() devuelve True\n\n\nisalnum()\nDevuelve True si todos los caracteres de la cadena son letras o dígitos, False en caso contrario\n\"Hola123\".isalnum() devuelve True\n\n\ncapitalize()\nDevuelve una copia de la cadena con el primer caracter en mayúscula y el resto en minúscula\n\"hola mundo\".capitalize() devuelve \"Hola mundo\"\n\n\nindex(subcadena)\nDevuelve el índice de la primera aparición de la subcadena en la cadena, o produce un error si no se encuentra\n\"Hola mundo\".index(\"mundo\") devuelve 5\n\n\n\n\n\n\n\n\n\nRecomendación\n\n\n\nTe recomendamos que te animes a probar estas funciones, para ver qué hacen y terminar de entenderlas."
  },
  {
    "objectID": "unidad_4.html#tuplas",
    "href": "unidad_4.html#tuplas",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.4 Tuplas",
    "text": "4.4 Tuplas\nLas tuplas son una secuencia de elementos inmutable. Esto significa que no se pueden modificar una vez creadas. En Python, el tipo de dato asociado a las tuplas se llama tuple y se definen con paréntesis ():\ntupla = (1, 2, 3)\nLas tuplas pueden tener elementos de cualquier tipo, es decir, pueden ser heterogéneas. Por ejemplo, podemos tener una tupla con un número, un string y un booleano:\ntupla = (1, \"Hola\", True)\nUna tupla de un sólo elemento (unitaria) debe definirse de la siguiente manera:\ntupla = (1,)\nLa coma al final es necesaria para diferenciar una tupla de un número entre paréntesis (1).\n\nEjemplos de tuplas podrían ser:\n\nUna fecha, representada como una tupla de 3 elementos: día, mes y año: (1, 1, 2020)\nDatos de una persona: (nombre, edad, dni): (\"Carla\", 30, 12345678)\n\nIncluso es posible anidar tuplas, como por ejemplo guardar, para una persona, la fecha de nacimiento: (\"Carla\", 30, 12345678, (1, 1, 1990))\n\n4.4.1 Tuplas como Secuencias\nComo las tuplas son secuencias, al igual que las cadenas, podemos utilizar la misma notación de índices para obtener cada uno de sus elementos y, de la misma forma que las cadenas, los elementos comienzan a enumerarse en su posición desde el 0:\n\nfecha = (1, 12, 2020)\nprint(fecha[0])\n\n1\n\n\nTambién podemos usar la notación de rangos, o slices, para obtener subconjuntos de la tupla. Esto es algo típico de las secuencias:\n\nfecha = (1, 12, 2020)\nprint(fecha[0:2])\n\n(1, 12)\n\n\n\n\n4.4.2 Tuplas como Inmutables\nAl igual que con las cadenas, las componentes de las tuplas no pueden ser modificadas. Es decir, no puedo cambiar los valores de una tupla una vez creada:\nfecha = (1, 12, 2020)\nfecha[0] = 2\nTypeError: 'tuple' object does not support item assignment\n\n\n4.4.3 Longitud de una Tupla\nLa longitud de una tupla se puede obtener con la función predefinida len(), que devuelve la cantidad de elementos o componentes que tiene esa tupla:\n\nfecha = (1, 12, 2020)\nprint(len(fecha))\n\n3\n\n\nUna tupla vacía es una tupla que no tiene elementos: (). La longitud de una tupla vacía es 0.\n\nEjercicio Calcular la longitud de la tupla anidada (\"Carla\", 30, 12345678, (1, 1, 1990)). ¿Cuántos elementos tiene?\n\n\n\n4.4.4 Empaquetado y desempaquetado de tuplas\nSi a una variable se le asigna una secuencia de valores separados por comas, el valor de esa variable será la tupla formada por esos valores. Ejemplo:\n\na = 1\nb = 2\nc = 3\nd = a, b, c\n\nprint(d)\n\n(1, 2, 3)\n\n\nA esto se le llama empaquetado.\n\nDe forma similar, si se tiene una tupla de largo \\(k\\), se puede asignar cada uno de los elementos de la tupla a \\(k\\) variables distintas. Esto se llama desempaquetado.\n\nd = (1, 2, 3)\na, b, c = d\n\nprint(a)\nprint(b)\nprint(c)\n\n1\n2\n3\n\n\n\n\n\n\n\n\n¡Cuidado!\n\n\n\nSi estamos desempaquetando una tupla de largo \\(k\\) pero lo hacemos en una cantidad de variables menor a \\(k\\), se producirá un error.\nd = (1, 2, 3)\na, b = d\nObtendremos:\nValueError: too many values to unpack\no\nValueError: not enough values to unpack"
  },
  {
    "objectID": "unidad_4.html#listas",
    "href": "unidad_4.html#listas",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.5 Listas",
    "text": "4.5 Listas\nLas listas, al igual que las tuplas, también pueden usarse para modelar datos compuestos, pero cuya cantidad y valor varían a lo largo del tiempo. Son secuencias mutables, y vienen dotadas de una variedad de operaciones muy útiles.\nLa notación para lista es una secuencia de valores entre corchetes y separados por comas.\nlista = [1, 2, 3]\n\nlista_vacia = []\n\n4.5.1 Longitud de una Lista\nLa longitud de una lista se puede obtener con la función predefinida len(), que devuelve la cantidad de elementos que tiene esa lista:\n\nlista = [1, 2, 3]\nprint(len(lista))\n\n3\n\n\n\n\n4.5.2 Listas como Secuencias\nDe la misma forma que venimos haciendo con las cadenas y las tuplas, podremos acceder a los elementos de una lista a través de su índice, slicear y recorrerla con un ciclo for.\n\nlista = [1, 2, 3]\nprint(lista[0])\n\n1\n\n\n\nlista = [\"Civil\", \"Informática\", \"Química\", \"Industrial\"]\nprint(lista[1:3])\n\n['Informática', 'Química']\n\n\n\nlista = [\"Civil\", \"Informática\", \"Química\", \"Industrial\"]\nfor elemento in lista:\n    print(elemento)\n\nCivil\nInformática\nQuímica\nIndustrial\n\n\n\n\n4.5.3 Listas como Mutables\nA diferencia de las tuplas, las listas son mutables. Esto significa que podemos modificar sus elementos una vez creadas.\n\nPara cambiar un elemento de una lista, se usa la notación de índices:\n\n\nlista = [1, 2, 3]\nlista[0] = 4\nprint(lista)\n\n[4, 2, 3]\n\n\n\nPara agregar un elemento al final de una lista, se usa el método append():\n\n\nlista = [1, 2, 3]\nlista.append(4)\nprint(lista)\n\n[1, 2, 3, 4]\n\n\n\nPara agregar un elemento en una posición específica de una lista, se usa el método insert():\n\n\nlista = [1, 2, 3]\nlista.insert(0, 4)\nprint(lista)\n\n[4, 1, 2, 3]\n\n\nEl método ingresa el número 4 en la posición 0 de la lista, y desplaza el resto de los elementos hacia la derecha.\n\nlista = [1, 2, 3]\nlista.insert(1, 3)\nprint(lista)\n\n[1, 3, 2, 3]\n\n\nEl método ingresa el número 3 en la posición 1 de la lista, y desplaza el resto de los elementos hacia la derecha.\nLas listas no controlan si se insertan elementos repetidos, por lo que si queremos exigir unicidad, debemos hacerlo mediante otras herramientas en nuestro código.\n\nPara eliminar un elemento de una lista, se usa el método remove():\n\n\nlista = [1, 2, 3]\nlista.remove(2)\nprint(lista)\n\n[1, 3]\n\n\nRemove busca el elemento 2 en la lista y lo elimina. Si el elemento no existe, se produce un error.\nSi el valor está repetido, se eliminará la primera aparición del elemento, empezando por la izquierda.\n\nlista = [1, 2, 3, 2]\nlista.remove(2)\nprint(lista)\n\n[1, 3, 2]\n\n\n\nPara quitar el último elemento de una lista, se usa el método pop():\n\n\nlista = [1, 2, 3]\nlista.pop()\nprint(lista)\n\n[1, 2]\n\n\nEl método pop() devuelve el elemento que se eliminó de la lista. Si la lista está vacía, se produce un error.\n\nlista = [1, 2, 3]\nelemento = lista.pop()\nprint(elemento)\n\n3\n\n\n\nPara quitar un elemento de una lista en una posición específica, se usa el método pop() con un índice:\n\n\nlista = [1, 2, 3]\nlista.pop(1)\nprint(lista)\n\n[1, 3]\n\n\nAl igual que antes, el método pop() devuelve el elemento que se eliminó de la lista. Si la lista está vacía, se produce un error.\n\nextend() agrega los elementos de una lista al final de otra. Es lo mismo que concatenar dos listas con el operador +:\n\n\nlista1 = [1, 2, 3]\nlista2 = [4, 5, 6]\nlista1.extend(lista2)\nprint(lista1)\n\n[1, 2, 3, 4, 5, 6]\n\n\n\n\n4.5.4 Referencias de Listas\n\na = [1,2,3,4]\nb = a\na.pop()\n\nprint(b)\n\n[1, 2, 3]\n\n\nSe dice que b es una referencia a a. Esto significa que b no es una copia de a, sino que es a misma. Por lo tanto, si modificamos a, también modificamos b.\nUna forma de crear una copia de una lista es usando el método copy():\n\na = [1,2,3,4]\nb = a.copy()\na.pop()\n\nprint(b)\n\n[1, 2, 3, 4]\n\n\n\n\n4.5.5 Búsqueda de Elementos en una Lista\n\nPara saber si un elemento se encuentra en una lista, se puede utilizar el operador in:\n\n\nlista = [1, 2, 3]\nprint(2 in lista)\n\nTrue\n\n\nComo vemos, el operador in es válido para todas las secuencias, incluyendo tuplas y cadenas.\n\nPara averiguar la posición de un valor dentro de una lista, usaremos el método index():\n\n\nlista = [\"a\", \"b\", \"t\", \"z\"]\nprint(lista.index(\"t\"))\n\n2\n\n\nSi el valor no se encuentra en la lista, se produce un error.\nSi el valor se encuentra repetido, se devuelve la posición de la primera aparición del elemento, empezando por la izquierda.\n\n\n4.5.6 Iterando sobre Listas\nLas listas son secuencias, y por lo tanto podemos iterar sobre ellas. Esto significa que podemos recorrerlas con un ciclo for:\n\nlista = [1, 2, 3]\nfor elemento in lista:\n    print(elemento)\n\n1\n2\n3\n\n\nEsta forma de recorrer elementos usando for es utilizable con todos los tipos de secuencias.\n\n\n4.5.7 Ordenando Listas\nNos puede interesar que los elementos de una lista estén ordenados según algún criterio. Python provee dos operaciones para obtener una lista ordenada a partir de la desordenada.\n\nsorted(s) devuelve una lista ordenada con los elementos de la secuencia s. La secuencia s no se modifica.\n\n\nlista = [3, 1, 2]\nlista_nueva = sorted(lista)\n\nprint(lista)\nprint(lista_nueva)\n\n[3, 1, 2]\n[1, 2, 3]\n\n\n\ns.sort() ordena la lista s en el lugar. Es decir, modifica la lista s y no devuelve nada.\n\n\nlista = [3, 1, 2]\nlista.sort()\n\nprint(lista)\n\n[1, 2, 3]\n\n\n\n\n\nTanto el método sort() como el método sorted() ordenan la lista en orden ascendente. Si queremos ordenarla en orden descendente, podemos usar el parámetro reverse:\n\nlista = [3, 1, 2]\nlista.sort(reverse=True)\nprint(lista)\n\n[3, 2, 1]\n\n\nExiste un método reverse (no disponible en Replit) que invierte la lista sin ordenarla. Una forma de reemplazarlo es usando slices, como ya vimos: lista[::-1].\n\n\n\n\n\n\n¡Cuidado con los Ordenamientos!\n\n\n\n\n\n\nTodos los elementos de la secuencia deben ser comparables entre sí. Si no lo son, se producirá un error. Por ejemplo, no se puede ordenar una lista que contenga números y strings.\nAl ordenar, las letras en minúscula no valen lo mismo que las letras en mayúscula. Si queremos ordenar “hola” y “HOLA” (por ejemplo), tenemos que compararlas convirtiendo todo a minúscula o todo a mayúscula.\nDe lo contrario, se ordena poniendo las mayúsculas primero y luego las minúsculas. Es decir, para una lista con los valores [\"hola\", \"HOLA\"], el ordenamiento será [\"HOLA\", \"hola\"].\n\n¿Existe una forma mejor de hacerlo? Sí. Usando keys de ordenamiento:\n\nlista = [\"hola\", \"HOLA\"]\nlista.sort(key=str.lower)\nprint(lista)\n\n['hola', 'HOLA']\n\n\nLo importante de momento es que sepas que existe esta forma de ordenar. A key se le puede pasar una función que se va a aplicar a cada elemento de la lista antes de ordenar. En este caso, la función str.lower convierte todo a minúscula antes de intentar ordenar.\n\n\n\n\n\n4.5.8 Listas por Comprensión\nLas listas por comprensión son una forma de crear listas de forma concisa y elegante.\nPor ejemplo, si queremos crear una lista con los números del 1 al 10, podemos hacerlo de la siguiente forma:\n\nnumeros = []\nfor i in range(1, 11):\n    numeros.append(i)\nprint(numeros)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\nSin embargo, podemos hacerlo de forma más concisa usando una lista por comprensión:\n\nnumeros = [i for i in range(1, 11)]\nprint(numeros)\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\nLa sintaxis de una lista por comprensión es la siguiente:\n[&lt;expresión&gt; for &lt;elemento&gt; in &lt;secuencia&gt;]\nLa expresión se evalúa para cada elemento de la secuencia, y el resultado de esa evaluación se agrega a la lista.\n\n\n4.5.9 Listas anidadas\nLas listas también puede estar anidadas, es decir, una lista puede contener a otras listas. Por ejemplo, podemos tener una lista de listas de números:\nvalores = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nAquía \\(valores\\) es una lista que contiene 3 elementos, que a su vez son también listas. Entonces, valores[0] sería la lista [1,2,3]. Si quisiéramos, por ejemplo, acceder al número 2 de dicha lista, tendríamos que volver a acceder al índice 1 de la lista valores[0]:\n\nvalores = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nnumero = valores[0][1]\nprint(numero)\n\n2\n\n\n\n\n\n\n\n\nGeneralización\n\n\n\nEste concepto de listas anidadas se puede generalizar a cualquier secuencia anidada. Por ejemplo, una tupla de tuplas, o una lista de tuplas, o una tupla de listas, etc.\n\ntupla = ((1, 2, 3), (4, 5, 6), (7, 8, 9))\nnumero = tupla[1][2]\nprint(numero)\n\n6\n\n\n\nlista = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nnumero = lista[2][0]\nprint(numero)\n\n7\n\n\n\ntupla = ([1, 2, 3], [4, 5, 6], [7, 8, 9])\nnumero = tupla[0][1]\nprint(numero)\n\n2\n\n\nIncluso se puede reemplazar un elemento anidado por otro:\n\ntupla = ([1, 2, 3], [4, 5, 6], [7, 8, 9])\ntupla[0][1] = 10\nprint(tupla)\n\n([1, 10, 3], [4, 5, 6], [7, 8, 9])\n\n\nEsto es válido siempre y cuando el elemento a reemplazar esté dentro de una secuencia mutable. En el caso de arriba, estamos cambiando el valor de una lista, que se encuentra dentro de la tupla. La tupla no cambia: sigue teniendo 3 listas guardadas.\nSi quisiéramos editar una tupla guardada dentro de una lista, no funcionaría:\nlista = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nlista[0][1] = 10\nprint(lista)\nTypeError: 'tuple' object does not support item assignment\n\n\nLas listas anidadas suelen usarse para representar matrices. Para ello, se puede pensar que cada lista representa una fila de la matriz, y cada elemento de la lista representa un elemento de la fila. Por ejemplo, la matriz:\n\\[\n\\begin{bmatrix}\n1 & 2 & 3 \\\\\n4 & 5 & 6 \\\\\n7 & 8 & 9\n\\end{bmatrix}\n\\]\nse puede representar como la lista de listas:\nmatriz = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir una función que reciba una cantidad de filas y una cantidad de columnas y devuelva una matriz de ceros de ese tamaño. Usar listas por comprensión.\nEjemplo: matrix(2,3) devuelve [[0, 0, 0], [0, 0, 0]]\n\n\n\n\n\nEjemplo Dada una lista de tuplas de dos elementos (precio, producto), desempaquetar la lista en dos listas separadas: una con los precios y otra con los productos.\n\n\nlista = [(100, \"Coca Cola\"), (200, \"Pepsi\"), (300, \"Sprite\")]\n\nprecios = []\nproductos = []\n\nfor precio, producto in lista: # Acá estamos desempaquetando: precio, producto\n    precios.append(precio)\n    productos.append(producto)\n\nprint(precios)\nprint(productos)\n\n[100, 200, 300]\n['Coca Cola', 'Pepsi', 'Sprite']"
  },
  {
    "objectID": "unidad_4.html#listas-y-cadenas",
    "href": "unidad_4.html#listas-y-cadenas",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.6 Listas y Cadenas",
    "text": "4.6 Listas y Cadenas\nVimos que las cadenas tienen el método split, que nos permite separar una cadena en una lista de subcadenas. Por ejemplo:\n\ncadena = \"Esta es una      cadena con    espacios   varios\"\nlista = cadena.split()\n\nprint(lista)\n\n['Esta', 'es', 'una', 'cadena', 'con', 'espacios', 'varios']\n\n\nTambién podemos hacer lo contrario: podemos unir una lista de subcadenas en una cadena usando el método join:\n\nlista = [\"Esta\", \"es\", \"una\", \"cadena\", \"con\", \"espacios\", \"varios\"]\ncadena = \" \".join(lista)\n\nprint(cadena)\n\nEsta es una cadena con espacios varios\n\n\nLa sintaxis del método join es:\n&lt;separador&gt;.join(&lt;lista&gt;)\nEl separador es el caracter que se va a usar para unir los elementos de la lista. En el ejemplo, el separador es un espacio \" \", pero puede ser cualquier caracter. La lista contiene a las subcadenas que se van a unir.\n\n\n\n\n\n\nSet\n\n\n\n\n\nAdicional a las estructuras vistas (cadenas, rangos, listas y tuplas), también tenemos los sets. Los sets no son secuencias, y por lo tanto no tienen índices y no se pueden slicear. Sin embargo, son muy útiles para realizar operaciones de conjuntos, como unión, intersección, diferencia, etc.\n\nLa gracia de un set es que es desordenado (no tiene orden predeterminado) pero cada uno de sus elementos es único. Por lo que agregar varias veces el mismo elemento a un set (set.add(elem)) no tiene efecto, sólo se agrega la primera vez.\n\nDe sets vamos a ver más en la siguiente unidad, junto con los diccionarios."
  },
  {
    "objectID": "unidad_4.html#operaciones-de-las-secuencias",
    "href": "unidad_4.html#operaciones-de-las-secuencias",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.7 Operaciones de las Secuencias",
    "text": "4.7 Operaciones de las Secuencias\nTanto las cadenas, como las tuplas y las listas son secuencias, y por lo tanto comparten una serie de operaciones que podemos realizar sobre ellas.\n\n\n\n\n\n\n\nOperación\nDescripción\n\n\n\n\nx in s\nDevuelve True si el elemento x se encuentra en la secuencia s, False en caso contrario \n\n\ns + t\nConcatena las secuencias s y t\n\n\ns * n\nRepite la secuencia s n veces\n\n\ns[i]\nDevuelve el elemento de la secuencia s en la posición i\n\n\ns[i:j:k]\nDevuelve un slice de la secuencia s desde la posición i hasta la posición j (no incluída), con pasos de a k\n\n\nlen(s)\nDevuelve la cantidad de elementos de la secuencia s\n\n\nmin(s)\nDevuelve el elemento mínimo de la secuencia s\n\n\nmax(s)\nDevuelve el elemento máximo de la secuencia s\n\n\nsum(s)\nDevuelve la suma de los elementos de la secuencia s\n\n\nenumerate(s)\nDevuelve una secuencia de tuplas de la forma (i, s[i]) para cada elemento de la secuencia s\n\n\ncount(x)\nDevuelve la cantidad de veces que aparece el elemento x en la secuencia s\n\n\nindex(x)\nDevuelve el índice de la primera aparición del elemento x en la secuencia s\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nTe recomendamos que pruebes cada una de estas operaciones con las distintas secuencias que vimos en este capítulo.\n\n\nAdemás, es posible crear una lista o tupla a partir de cualquier otra secuencia, usando las funciones list y tuple respectivamente:\n\nlista = list(\"Hola\")\nprint(lista)\n\n['H', 'o', 'l', 'a']\n\n\n\ntupla = tuple(\"Hola\")\nprint(tupla)\n\n('H', 'o', 'l', 'a')\n\n\n\nlista = list( (1, 2, 3) ) # Convertimos una tupla en una lista\nprint(lista)\n\n[1, 2, 3]\n\n\nEsta última es particularmente útil cuando necesitamos trabajar con una tupla, pero como son inmutables, la convertimos a lista para manipularla sin problemas.\n\nEjercicio Escribir una función que le pida al usuario que ingrese números enteros positivos, los vaya agregando a una lista, y que cuando el usuario ingrese un 0, devuelva la lista de números ingresados.\n\ndef ingresar_numeros():\n    numeros = []\n    numero = int(input(\"Ingrese un número: \"))\n\n    while numero != 0:\n        numeros.append(numero)\n        numero = int(input(\"Ingrese un número: \"))\n    return numeros\n\n\n\n\n\n\nEjercicio Escribir una función que cuente la cantidad de letras que tiene una cadena de caracteres, y devuelva su valor.\nLuego, usar esa función como key para ordenar la siguiente lista: [\"Año\", \"Onomatopeya\", \"Murcielago\", \"Arañas\", \"Messi\", \"Camiseta\"].\n\n\ndef contar_letras(cadena):\n    return len(cadena)\n\nlista = [\"Año\", \"Onomatopeya\", \"Murcielago\", \"Arañas\", \"Messi\", \"Camiseta\"]\nlista.sort(key=contar_letras)\n\nprint(lista)\n\n['Año', 'Messi', 'Arañas', 'Camiseta', 'Murcielago', 'Onomatopeya']\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir una función que cuente la cantidad de vocales que tiene una cadena de caracteres, y devuelva su valor. Debe considerar mayúsculas y minúsculas. Pista: podés usar la función para saber si una letra es vocal que hiciste en la unidad 3.\nLuego, usar esa función como key para ordenar la siguiente lista: [\"Año\", \"Onomatopeya\", \"Murcielago\", \"Arañas\", \"Messi\", \"Camiseta\"].\n\n\n\n\n\n\n\n\n\n4.7.1 Map\nLa función map aplica una función a cada uno de los elementos de una secuencia, y devuelve una nueva secuencia con los resultados.\n\ndef obtener_cuadrado(x):\n  return x**2\n\nlista = [1, 2, 3, 4]\nlista_cuadrados = list(map(obtener_cuadrado, lista))\nprint(lista_cuadrados)\n\n[1, 4, 9, 16]\n\n\nLa sintaxis es:\nmap(&lt;funcion&gt;, &lt;secuencia&gt;)\nLa función map devuelve un objeto de tipo map, por lo que en general lo vamos a convertir a una lista usando list(). Sin embargo, el tipo map es iterable, por lo que podríamos recorrerlo con un ciclo for:\n\nfor n in lista_cuadrados:\n  print(n)\n\n1\n4\n9\n16\n\n\n\n\n\n\n\n\nTip\n\n\n\nLas funciones a pasar como parámetro a map devuelven valores transformados del elemento original. Lo que hace map es aplicar la función a cada uno de los elementos de la secuencia original.\n\n\n\n\n4.7.2 Filter\nLa función filter aplica una función a cada uno de los elementos de una secuencia, y devuelve una nueva secuencia con los elementos para los cuales la función devuelve True.\n\ndef es_par(x):\n  return x % 2 == 0\n\nlista = [1, 2, 3, 4]\nlista_pares = list(filter(es_par, lista))\nprint(lista_pares)\n\n[2, 4]\n\n\nLa sintaxis es:\nfilter(&lt;funcion&gt;, &lt;secuencia&gt;)\nLa función filter devuelve un objeto de tipo filter, por lo que en general lo vamos a convertir a una lista usando list(). Sin embargo, el tipo filter es iterable, por lo que podríamos recorrerlo con un ciclo for:\n\nfor n in lista_pares:\n  print(n)\n\n2\n4\n\n\n\n\n\n\n\n\nTip\n\n\n\nLas funciones a pasar como parámetro a filter devuelven valores booleanos del elemento original. Lo que hace filter es filtrar la secuencia original y quedarse sólo con los valores para los cuales la función devuelve True.\n\n\n\nEjemplo Escribir una función que reciba una lista de números y devuelva una lista con los números positivos de la lista original.\n\n\ndef es_positivo(x):\n  return x &gt; 0\n\ndef quitar_negativos_o_cero(lista):\n  return list(filter(es_positivo, lista))\n\nlista = [1, -2, 3, -4, 5, 0]\nlista_positivos = quitar_negativos_o_cero(lista)\nprint(lista_positivos)\n\n[1, 3, 5]\n\n\n\nEjemplo Escribir una función que reciba una lista de nombres y devuelva una lista con los mismos nombres pero con la primer letra en mayúscula.\n\n\ndef capitalizar_nombre(nombre):\n  return nombre.capitalize()\n\ndef capitalizar_lista(lista):\n  return list(map(capitalizar_nombre, lista))\n\nlista = [\"pilar\", \"barbie\", \"violeta\"]\nlista_capitalizada = capitalizar_lista(lista)\nprint(lista_capitalizada)\n\n['Pilar', 'Barbie', 'Violeta']\n\n\n\n\n\n\n\n\nNote\n\n\n\nTanto map como filter son aplicables a cualquiera de las secuencias vistas (rangos, cadena de caracteres, listas, tuplas).\n\n\n\n\n\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nSe está procesando una base de datos para entrenar un modelo de Machine Learning. La base de datos contiene información de personas, y cada persona está representada por una tupla de 2 elementos: nombre, edad.\nEscribir una función que reciba una lista de estas tuplas. La función debe devolver la lista ordenada por edad; y filtrada de forma que sólo queden los nombres de las personas mayores de edad (&gt;18). Además, los nombres deben estar en mayúscula.\nEjemplo:\nSi se tiene [(\"sol\", 40), (\"priscila\", 15), (\"agostina\", 30)]\nuna vez ejecutada, la función debe devolver: [(\"AGOSTINA\",30), (\"SOL\",40)]"
  },
  {
    "objectID": "unidad_4.html#diccionarios",
    "href": "unidad_4.html#diccionarios",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.8 Diccionarios",
    "text": "4.8 Diccionarios\nUn diccionario es una colección de pares clave-valor. Es una estructura de datos que nos permite guardar información de forma organizada, y acceder a ella de forma eficiente. Cada clave está asociada a un valor determinado.\n\n\n\nDiccionario cuyas claves son dominios de internet (.ar, .es, .tv) y cuyos valores asociados son los países correspondientes.\n\n\nLas claves deben ser únicas, es decir, no puede haber dos claves iguales en un mismo diccionario. Los valores pueden repetirse. Si se asigna un valor a una clave ya existente, se reemplaza el valor anterior.\nPodemos acceder a un valor a través de su clave porque las claves son únicas, pero no a la inversa. Es decir, no podemos acceder a una clave a través de su valor, porque los valores pueden repetirse y podría haber varias claves asociadas al mismo valor.\nAdemás, los diccionarios no tienen un orden interno particular. Se consideran entonces iguales dos diccionarios si tienen las mismas claves asociadas a los mismos valores, independientemente del orden en que se hayan agregado.\nAl igual que las listas, los diccionarios son mutables. Esto significa que podemos modificar sus elementos una vez creados.\n\nCualquier valor de tipo inmutable puede ser clave de un diccionario: cadenas, enteros tuplas.\nNo hay restricciones para los valores, pueden ser de cualquier tipo: cadenas, enteros, tuplas, listas, otros diccionarios, etc.\n\n\n4.8.1 Diccionarios en Python\nPara definir un diccionario, se utilizan llaves {} y se separan las claves de los valores con dos puntos :. Cada par clave-valor se separa con comas ,.\n\ndominios = {\"ar\": \"Argentina\", \"es\": \"España\", \"tv\": \"Tuvalu\"}\n\nEl tipo asociado a los diccionarios es dict:\n\nprint(type(dominios))\n\n&lt;class 'dict'&gt;\n\n\nPara declararlo vacío y luego ingresar valores, se lo declara como un par de llaves vacías. Luego, haciendo uso de la notación de corchetes [], se le asigna un valor a una clave:\n\nmaterias = {}\nmaterias[\"lunes\"] = [6103, 7540]\nmaterias[\"martes\"] = [6201]\nmaterias[\"miércoles\"] = [6103, 7540]\nmaterias[\"jueves\"] = []\nmaterias[\"viernes\"] = [6201]\n\nEn el código de arriba, se está creando una variable materias de tipo dict, y se le están asignando valores a las claves \"lunes\", \"martes\", \"miércoles\", \"jueves\" y \"viernes\".\nLos valores asociados a cada clave son listas con los códigos de las materias que se dan esos días. El diccionario se ve algo así:\n{\n    \"lunes\": [6103, 7540],\n    \"martes\": [6201],\n    \"miércoles\": [6103, 7540],\n    \"jueves\": [],\n    \"viernes\": [6201]\n}\n\n\n4.8.2 Accediendo a los Valores de un Diccionario\nPara acceder a los valores de un diccionario, se utiliza la notación de corchetes [] con la clave correspondiente:\n\ncods_lunes = materias[\"lunes\"]\nprint(cods_lunes)\n\n[6103, 7540]\n\n\nVeamos que la clave “lunes” no va a ser igual a la clave “Lunes” o “LUNES”, porque como ya dijimos antes, Python es case sensitive.\n\n\n\n\n\n\n¡Cuidado! Acceso a Claves que no Existen\n\n\n\nSi intentamos acceder a una clave que no existe en el diccionario, se produce un error:\nprint(materias[\"sábado\"])\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nKeyError: 'sábado'\n\n\n\nPara evitar tratar de acceder a una clave que no existe, podemos verificar si una clave se encuentra o no en el diccionario haciendo uso del operador in:\n\nif \"sábado\" in materias:\n    print(materias[\"sábado\"])\nelse:\n    print(\"No hay clases el sábado\")\n\nNo hay clases el sábado\n\n\nTambién podemos usar la función get, que recibe una clave ky un valor por omisión v, y devuelve el valor asociado a la clave k, en caso de existir, o el valor v en caso contrario.\n\nprint(materias.get(\"sábado\", \"Error de clave: sábado\"))\n\nError de clave: sábado\n\n\n\nprint(materias.get(\"domingo\",[]))\n\n[]\n\n\nComo vemos el valor por omisión puede ser de cualquier tipo.\n\n\n4.8.3 Iterando Elementos del Diccionario\n\n4.8.3.1 Por Claves\nPara iterar sobre las claves de un diccionario, podemos usar un ciclo for:\n\nfor dia in materias:\n    print(f\"El {dia} tengo que cursar las materias {materias[dia]}\")\n\nEl lunes tengo que cursar las materias [6103, 7540]\nEl martes tengo que cursar las materias [6201]\nEl miércoles tengo que cursar las materias [6103, 7540]\nEl jueves tengo que cursar las materias []\nEl viernes tengo que cursar las materias [6201]\n\n\nTambién podemos obtener las claves del diccionario como una lista usando el método keys():\n\nfor dia in materias.keys():\n    print(f\"El {dia} tengo que cursar las materias {materias[dia]}\")\n\nEl lunes tengo que cursar las materias [6103, 7540]\nEl martes tengo que cursar las materias [6201]\nEl miércoles tengo que cursar las materias [6103, 7540]\nEl jueves tengo que cursar las materias []\nEl viernes tengo que cursar las materias [6201]\n\n\n\n\n4.8.3.2 Por Valores\nPara iterar sobre los valores de un diccionario, podemos usar el método values():\n\nfor codigos in materias.values():\n    print(codigos)\n\n[6103, 7540]\n[6201]\n[6103, 7540]\n[]\n[6201]\n\n\nNótese que en este último ejemplo, no podemos obtener la clave a partir de los valores. Por eso no imprimimos los días.\n\n\n4.8.3.3 Por Clave-Valor\nPara iterar sobre los pares clave-valor de un diccionario, podemos usar el método items(), que nos devuelve un conjunto de tuplas donde el primer elemento de cada una es una clave y el segundo, su valor asociado (clave,valor):\n\nfor tupla in materias.items():\n  dia = tupla[0]\n  codigos = tupla[1]\n  print(f\"El {dia} tengo que cursar las materias {codigos}\")\n\nEl lunes tengo que cursar las materias [6103, 7540]\nEl martes tengo que cursar las materias [6201]\nEl miércoles tengo que cursar las materias [6103, 7540]\nEl jueves tengo que cursar las materias []\nEl viernes tengo que cursar las materias [6201]\n\n\nTambién podemos desempaquetar las tuplas como vimos previamente:\n\nfor dia, codigos in materias.items():\n  print(f\"El {dia} tengo que cursar las materias {codigos}\")\n\nEl lunes tengo que cursar las materias [6103, 7540]\nEl martes tengo que cursar las materias [6201]\nEl miércoles tengo que cursar las materias [6103, 7540]\nEl jueves tengo que cursar las materias []\nEl viernes tengo que cursar las materias [6201]\n\n\n\n\n\n\n\n\nNote\n\n\n\nComo los diccionarios no son secuencias, no tienen orden interno específico, por lo que no podemos obtener porciones de un diccionario usando slices o [:] como hacíamos con otras estructuras de datos.\n\n\n\n\n\n\n\n\nAcerca de la Iteración de un Diccionario\n\n\n\nEl mayor beneficio de los diccionarios es que podemos acceder a sus valores de forma eficiente, a través de sus claves.\nSi la única funcionalidad que necesitamos de un diccionario es iterarlo, entonces no estamos aprovechando su potencial. En ese caso, es preferible usar una o más listas o tuplas, que es más simple y más eficiente.\nIterar un diccionario es una funcionalidad adicional que nos brinda Python, pero no es su principal uso.\n\n\n\n\n\n4.8.4 Usos de un Diccionario\nLos diccionarios son muy versátiles. Se puede utilizar un diccionario para, por ejemplo, contar cuántas apariciones de cada palabra hay en un texto, o cuántas apariciones por cada letra.\nTambién se puede usar un diccionario para tener una agenda de contactos, donde la clave es el nombre de la persona y el valor el número de teléfono.\n\n\n\n\n\n\nHashmaps: Dato interesante\n\n\n\n\n\nLos diccionarios de Python son implementados usando una estructura de datos llamada hashmap.\nPara cada clave, se le calcula un valor numérico llamado hash, que es el que se usa para acceder al valor asociado a esa clave.\nCuando se recibe una clave, se le calcula su hash y se busca en el diccionario el valor asociado a ese hash.\n\n\n\n\n\n\n4.8.5 Operaciones de los Diccionarios\n\n\n\n\n\n\n\nOperación\nDescripción\n\n\n\n\nd[k]\nDevuelve el valor asociado a la clave k\n\n\nd[k] = v\nAsigna el valor v a la clave k. Si la clave no existe, la agrega al diccionario. Si ya existe, le actualiza el valor asociado.\n\n\ndel d[k]\nElimina la clave k y su valor asociado del diccionario d\n\n\nk in d\nDevuelve True si la clave k se encuentra en el diccionario d, False en caso contrario\n\n\nlen(d)\nDevuelve la cantidad de pares clave-valor del diccionario d\n\n\nd.keys()\nDevuelve una lista con las claves del diccionario d\n\n\nd.values()\nDevuelve una lista con los valores del diccionario d\n\n\nd.items()\nDevuelve una lista de tuplas con los pares clave-valor del diccionario d\n\n\nd.clear()\nElimina todos los pares clave-valor del diccionario d\n\n\nd.copy()\nDevuelve una copia del diccionario d\n\n\nd.pop(k)\nElimina la clave k y su valor asociado del diccionario d, y devuelve el valor asociado\n\n\nd.popitem()\nElimina un par clave-valor del diccionario d, y devuelve una tupla con la clave y el valor eliminados\n\n\nd.get(k, v)\nDevuelve el valor asociado a la clave k si la clave existe, o el valor v en caso contrario\n\n\nd.update(d2)\nAgrega los pares clave-valor del diccionario d2 al diccionario d. Si una clave ya existe en d, actualiza su valor asociado.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nExisten más métodos de diccionarios, pero estos son los más utilizados y los que vamos a ver en la materia. Recomendamos que pruebes cada uno de ellos con los diccionarios que vimos en este capítulo.\n\n\n\n\n4.8.6 Diccionarios y Funciones\nLos diccionarios son mutables, por lo que podemos pasarlos como parámetros a funciones y modificarlos dentro de la función.\n\ndef agregar_alumno(alumnos, nombre, legajo):\n  alumnos[nombre] = legajo\n\nalumnos = {}\nagregar_alumno(alumnos, \"Juan\", 1234)\nagregar_alumno(alumnos, \"María\", 5678)\nprint(alumnos)\n\n{'Juan': 1234, 'María': 5678}\n\n\n\n\n4.8.7 Ordenamiento de Diccionarios\nTenemos algunas operaciones que nos permiten ordenar un diccionario:\n\n\n\n\n\n\n\nOperación\nDescripción\n\n\n\n\ndict()\nCrea un diccionario vacío\n\n\nsorted(d)\nDevuelve una lista ordenada con las claves del diccionario d\n\n\ndict(sorted(d.items()))\nDevuelve un diccionario ordenado con las claves del diccionario d\n\n\n\nSi lo que necesitamos es ordenar diccionarios entre sí (por ejemplo, teniendo una lista de diccionarios), vamos a usar el parámetro key de la función sorted:\n\ndef obtener_nombre(alumno):\n  return alumno[\"nombre\"]\n\nalumnos = [\n  {\"nombre\": \"Priscila\", \"legajo\": 1234},\n  {\"nombre\": \"Iara\", \"legajo\": 5678},\n  {\"nombre\": \"Agostina\", \"legajo\": 9012}\n]\nalumnos_ordenados = sorted(alumnos, key=obtener_nombre)\nprint(alumnos_ordenados)\n\n[{'nombre': 'Agostina', 'legajo': 9012}, {'nombre': 'Iara', 'legajo': 5678}, {'nombre': 'Priscila', 'legajo': 1234}]\n\n\n\n\n\n\n\n\nNote\n\n\n\nEn el ejemplo de arriba, estamos ordenando una lista de diccionarios por el valor de la clave \"nombre\".\nEl parámetro key recibe una función que se va a aplicar a cada elemento de la lista antes de ordenar. En este caso, la función obtener_nombre devuelve el valor de la clave \"nombre\" de cada diccionario, y es lo que se usa para ordenar.\n\n\n\n\n\n\n\n\nEjercicio Desafío\n\n\n\nEscribir una función que reciba una lista de diccionarios y una clave, y devuelva una lista con los diccionarios ordenados según la clave.\n\nEjemplo:\nSi se tiene [{\"nombre\": \"Priscila\", \"legajo\": 1234}, {\"nombre\": \"Iara\", \"legajo\": 5678}, {\"nombre\": \"Agostina\", \"legajo\": 9012}] y se recibe la clave nombre\nuna vez ejecutada, la función debe devolver:\n[{\"nombre\": \"Agostina\", \"legajo\": 9012}, {\"nombre\": \"Iara\", \"legajo\": 5678}, {\"nombre\": \"Priscila\", \"legajo\": 1234}]\n\n\n\n\n\n\n\n\n\nLambda\n\n\n\n\n\nEn el ejemplo anterior, la función obtener_nombre es muy simple, y sólo la usamos una vez.\nEn estos casos, podemos usar una función lambda, que es una función anónima que se declara en una sola línea.\n\n\nalumnos = [\n  {\"nombre\": \"Priscila\", \"legajo\": 1234},\n  {\"nombre\": \"Iara\", \"legajo\": 5678},\n  {\"nombre\": \"Agostina\", \"legajo\": 9012}\n]\n\nalumnos_ordenados = sorted(alumnos, key=lambda alumno: alumno[\"nombre\"])\nprint(alumnos_ordenados)\n\n[{'nombre': 'Agostina', 'legajo': 9012}, {'nombre': 'Iara', 'legajo': 5678}, {'nombre': 'Priscila', 'legajo': 1234}]\n\n\nLo que estamos haciendo es declarar una función que recibe un parámetro alumno y devuelve el valor de la clave \"nombre\" de ese diccionario.\nLa función se declara en una sola línea, y no tiene nombre.\nLa función se pasa como parámetro key a sorted, y se ejecuta para cada elemento de la lista antes de ordenar."
  },
  {
    "objectID": "unidad_4.html#sets",
    "href": "unidad_4.html#sets",
    "title": "4  Tipos de Estructuras de Datos",
    "section": "4.9 Sets",
    "text": "4.9 Sets\nUn set es una estructura de datos mutable (como las listas y los diccionarios), que permite agregar y quitar elementos cumpliendo los requisitos de unicidad y búsqueda en tiempo constante. Además, es posible hacer operaciones entre sets como la unión, intersección y diferencia.\nLa sintaxis de un set es con llaves {}, al igual que el diccionario, pero no contiene pares de clave-valor asociados, únicamente elementos.\n\ns1 = {1, 2, 3, 4}\nprint(s1)\n\n{1, 2, 3, 4}\n\n\nEl set no permite tener elementos repetidos, por lo que tratar de agregar un elemento a un set en donde ya existe, no lo agrega por duplicado:\n\ns1.add(1)\nprint(s1)\n\n{1, 2, 3, 4}\n\n\nPara unir dos sets, podemos usar el método union:\n\ns2 = {3,4,5,6}\ns1.union(s2)\nprint(s1)\n\n{1, 2, 3, 4}\n\n\nTambién podemos ver la intersección, y la diferencia:\n\nintersection = s1.intersection(s2)\ndiff = s1.difference(s2)\n\nprint(f\"La intersección de s1 y s2 es {intersection} y la diferencia es: {diff}\")\n\nLa intersección de s1 y s2 es {3, 4} y la diferencia es: {1, 2}\n\n\nPara crear un set vacío, no podemos usar un par de llaves {}, porque esa es sintaxis para crear un diccionario vacío. Lo que tenemos que hacer es usar el método set().\n\nlegajos = set()\n\nlegajos.add(105609)\nprint(legajos)\n\n{105609}\n\n\n\n4.9.1 Operaciones con Sets\n\n\n\n\n\n\n\nOperación\nDescripción\n\n\n\n\ns.add(x)\nAgrega el elemento x al set s\n\n\ns.remove(x)\nElimina el elemento x del set s. Si x no se encuentra en s, se produce un error\n\n\ns.discard(x)\nElimina el elemento x del set s. Si x no se encuentra en s, no se produce un error\n\n\ns.clear()\nElimina todos los elementos del set s\n\n\ns.copy()\nDevuelve una copia del set s\n\n\ns.union(s2)\nDevuelve un set con los elementos de s y s2\n\n\ns.intersection(s2)\nDevuelve un set con los elementos que están en s y en s2\n\n\ns.difference(s2)\nDevuelve un set con los elementos que están en s pero no en s2\n\n\nlen(s)\nDevuelve la cantidad de elementos en s\n\n\nx in s\nDevuelve True si el elemento x se encuentra en s\n\n\n\n\n\n4.9.2 Ordenamiento e Iteración de Sets\nUn set es un conjunto de datos sin ordenar. Sin embargo, podemos de todas formas y si quisiéramos, ordenar los elementos haciendo uso de sorted. El método sort() no está disponible para los sets.\n\ns3 = {1,7,2,8,4}\nprint(sorted(s3))\n\n[1, 2, 4, 7, 8]\n\n\nLos elementos también pueden iterarse:\n\ns4 = {1, 2, 3, 4}\nfor e in s4:\n  print(e)\n\n1\n2\n3\n4"
  },
  {
    "objectID": "unidad_5.html#subtitle",
    "href": "unidad_5.html#subtitle",
    "title": "5  Entrada y Salida de Información",
    "section": "5.1 Subtitle",
    "text": "5.1 Subtitle"
  },
  {
    "objectID": "unidad_6.html#introducción",
    "href": "unidad_6.html#introducción",
    "title": "6  Librerías de Python",
    "section": "6.1 Introducción",
    "text": "6.1 Introducción\nPython es un lenguaje de programación muy popular, poderoso y versátil que cuenta con una amplia gama de librerías que ayudan a que la programación sea más fácil y eficiente. Pero, ¿qué son las librerías? La librerías son conjuntos de módulos que contienen funciones, clases y variables relacionadas, que permiten realizar tareas sin tener que escribir el código desde cero y este se puede reutilizar en múltiples programas y proyectos.\nEntre las librerías disponibles se encuentran las estándares, que se incluye con cada instalación de Python, y las de código abierto creadas por la gran comunidad de desarrolladores, que constantemente genera nuevas librerías y mejora las existentes. Por ello es aconsejable que, al momento de utilizarlas, se verifique si existe alguna actualización en las guías de usuario.\nAsimismo, estas librerías se pueden clasificar según su aplicación y funcionalidad en: procesamiento de datos, visualización, aprendizaje automático, desarrollo web, procesamiento de lenguaje y de imágenes, entre otras. En este capítulo se analizarán tres de las librerías más reconocidas y ampliamente utilizadas de Python: NumPy y Pandas para procesamiento de datos y Matplotlib, para visualización.\n\n6.1.1 ¿Cómo se utilizan las librerías?\nPara acceder a una librería y sus funciones, se debe instalar por única vez y luego, importar cada vez que la necesitemos:\n\nEn nuestro caso, la instalación no es necesaria ya que utilizamos Google Colab, pero en caso de usar otro IDE, se realiza desde el símbolo del sistema (o en inglés: “Command Prompt”), corriendo: pip install –nombre_de_librería.\nPara importarla, en la parte superior de nuestro código debemos correr import –nombre_de_librería as –nombre_corto_de_librería. El alias o nombre corto de la librería se suele agregar para lograr una mayor legilibilidad del código, pero no es mandatorio."
  },
  {
    "objectID": "unidad_6.html#numpy",
    "href": "unidad_6.html#numpy",
    "title": "6  Librerías de Python",
    "section": "6.2 NumPy",
    "text": "6.2 NumPy\nNumPy es una librería de código abierto muy utilizada en el campo de la ciencia y la ingeniería. Permite trabajar con datos numéricos, matrices multidimensionales, funciones matemáticas y estadísticas avanzadas.\nComo ya se mencionó anteriormente, para utilizarse se debe instalar e importar. Por convención, se suele importar como:\n\nimport numpy as np\n\nNumPy incorpora una estructura de datos propia llamados arrays que es similar a la lista de Python, pero puede almacenar y operar con datos de manera mucho más eficiente. ¡El procesamiento de los arrays es hasta 50 veces más rápido! Esta diferencia de velocidad se debe, en parte, a que los arrays contienen datos homogéneos, a diferencia de las listas que pueden contener distintos tipos de datos dentro.\n\n6.2.1 Arrays\nUn array es un conjunto de elementos del mismo tipo, donde cada uno de ellos posee una posición y esta, es única para cada elemento. Para comprenderlo, analicemos el siguiente ejemplo: si pensamos en una matriz, lo primero que nos viene a la mente es una tabla con valores ordenados en filas y columnas, donde una fila es la línea horizontal y una columna es la vertical. Es decir, una matriz es un conjunto de elementos que posee una posición o índice determinado determinado por la fila y la columna, por lo que sería un array.\nTambién, es posible encontrar en la bibliografía el término ndarray, que es una abreviatura de “array N-dimensional”, debido a que los arrays pueder ser de dimensión nula (0-D), unidimensional, bidimensional, tridimensional, etc, llamados comúnmente escalar, vector, matriz y tensor, respectivamente. En este capítulo se trabajará principalmente con vectores y matrices ya que consideramos que les será útil para aplicar los conocimientos de Numpy en otras materias.\n\n6.2.1.1 ¿Cómo se crea un array?\nUn array se crea usando la función array() a partir de listas o tuplas. Por ejemplo:\n\na = np.array([1, 2, 3])\nprint(a)\n\n[1 2 3]\n\n\nTambién, se pueden crear arrays particulares, constituídos por ceros con zeros() o por unos con ones():\n\n# Creo un array de ceros con dos elementos\na_ceros = np.zeros(2)\nprint(a_ceros)\n\n[0. 0.]\n\n\n\n# Creo un array de unos con dos elementos\na_unos = np.ones(2)\nprint(a_unos)\n\n[1. 1.]\n\n\nAdemás, se pueden crear arrays con un rango de números, utilizando arange() o linspace():\n\n# Creo un array con un rango que empieza en 2 hasta 9 y va de 2 en 2.\na_rango = np.arange(2, 9, 2)\nprint(a_rango)\n\n[2 4 6 8]\n\n\n\n# Creo un array con un rango formado por 4 números, que empieza en 2 hasta 8 (incluídos). \na_rango_2 = np.linspace(2, 8, num=4)\nprint(a_rango_2)\n\n[2. 4. 6. 8.]\n\n\nFinalmente, para crear arrays de más dimensiones, se utilizan varias listas:\n\nmatriz = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(matriz)\n\n[[1 2 3]\n [4 5 6]]\n\n\n\n\n6.2.1.2 Atributos de un array\nPara caracterizar un array es necesario conocer sus dimensiones, utilizando ndim. De esta forma, se puede confirmar que el array llamado matriz, definido anteriormente, es bidimensional:\n\n# Número de ejes o dimensiones de la matriz\nmatriz.ndim\n\n2\n\n\nOtra característica de interés es su forma o shape: para las matrices bidimensionales, se muestra una tupla (n, m) con el número de filas n y de columnas m:\n\n# (n = filas, m = columnas)\nmatriz.shape\n\n(2, 3)\n\n\n\n# Número total de elementos de la matriz: 2 filas x 3 columnas = 6 elementos\nmatriz.size\n\n6\n\n\nAl elemento de una matriz A que se encuentra en la fila i-ésima y la columna j-ésima se llama aij. De manera análoga, para acceder a un elemento de un array se debe indicar primero la posición de la fila y luego, de la columna:\n\nprint('Elemento de la primera fila y segunda columna: ', matriz[0, 1])\n\nElemento de la primera fila y segunda columna:  2\n\n\nO se puede elegir un rango de elementos en una fila o columna particular:\n\nprint('Los elementos de la primera fila, columnas 0 y 1: ', matriz[0, 0:2])\n\nLos elementos de la primera fila, columnas 0 y 1:  [1 2]\n\n\n\nprint('Los elementos de la segunda columna, filas 0 y 1: ', matriz[0:2, 1])\n\nLos elementos de la segunda columna, filas 0 y 1:  [2 5]\n\n\n\n\n6.2.1.3 Modificar arrays\nDe forma similar a lo aprendido con las listas de Python, se pueden modificar los arrays utilizando ciertas funciones. Para entender y aplicar las mismas, definamos un vector llamado a:\n\na = np.array([2, 1, 5, 3, 7, 4, 6, 8])\n\nprint(a)\n\n[2 1 5 3 7 4 6 8]\n\n\nA este vector, se le puede modificar la forma: pasando de ser (8,) a (4,2), por dar un ejemplo:\n\na_reshape = a.reshape(2, 4) # 2 filas y 4 columnas\n\nprint(a_reshape)\n\n[[2 1 5 3]\n [7 4 6 8]]\n\n\nTambién, se modría insertar una fila (axis = 0) o una columna (axis = 1) en una determinada posición. Por ejemplo:\n\n# Agregar fila de cincos en posición 1:\nprint(np.insert(a_reshape, 1, 5, axis=0))\n\n[[2 1 5 3]\n [5 5 5 5]\n [7 4 6 8]]\n\n\n\n# Agregar columna de cincos en posición 1:\nprint(np.insert(a_reshape, 1, 5, axis=1))\n\n[[2 5 1 5 3]\n [7 5 4 6 8]]\n\n\nO lo que es equivalente:\n\n# Agregar columna de cincos en posición 1:\nprint(np.insert(a_reshape, 1, [5, 5], axis=1))\n\n[[2 5 1 5 3]\n [7 5 4 6 8]]\n\n\n\n\n\n\n\n\nObservemos los parámetros\n\n\n\n\nNote que a la función insert(), se le debe indicar:\n- el array que se desea modificar\n- la posición de la fila o columna que se desea agregar\n- los valores a insertar. ¡Ojo con las dimensiones! Para el ejemplo anterior, a_reshape tenía 2 filas, por lo que se debe agregar una columna con 2 elementos o una fila con 4.\n- el eje que se agrega: una fila (axis = 0) o una columna (axis = 1)\n\n\n\nTambién podríamos agregar una fila o una columna utilizando append() al final, como ocurría con las listas:\n\n# Agregar una última fila\na_modificada = np.append(a_reshape, [[1, 2, 3, 4]], axis=0)\nprint(a_modificada)\n\n[[2 1 5 3]\n [7 4 6 8]\n [1 2 3 4]]\n\n\nO eliminarlas con delete()\n\n# Eliminar la fila de la posición 2.\nprint(np.delete(a_modificada, 2, axis=0))\n\n[[2 1 5 3]\n [7 4 6 8]]\n\n\nFinalmente, podemos concatenar arrays, como los siguientes:\n\na = np.array([2, 1, 5, 3])\nb = np.array([7, 4, 6, 8])\n\n# Concatenar a y b:\nc = np.concatenate((a, b))\nprint(c)\n\n[2 1 5 3 7 4 6 8]\n\n\nY ordenar los elementos de un array como numérico o alfabético, ascendente o descendente.\n\nprint(np.sort(c))\n\n[1 2 3 4 5 6 7 8]\n\n\n\n\n\n6.2.2 Operaciones aritméticas utilizando array\nComo se ha mencionado anteriormente, Numpy tiene un gran potencial para realizar operaciones, muy superior al de las listas de Python, gracias a la vectorización que es mucho más rápido que iterar sobre cada elementos. Por ejemplo, si quisieramos sumar dos listas de python necesitaríamos realizar un for y utilizar el método `zip():\n\n# Definir listas\na = [2, 1, 5, 3]\nb = [7, 4, 6, 8]\nc = []\n\n# Sumar el primer elemento de a con el primero de b, el segundo elemento de a con el segundo de b y así sucesivamente\nfor i, j in zip(a, b):\n  c.append(i + j)\nprint(c)\n\n[9, 5, 11, 11]\n\n\nUtlizando las funciones de Numpy, esto ya no es más necesario:\n\n# add() para sumar elemento a elemento de a y b\nc = np.add(a, b)\nprint(c)\n\n[ 9  5 11 11]\n\n\nUna vez aclarado esto, ¡A calcular!\n\n6.2.2.1 Operaciones básicas:\nA continuación se muestra una lista con las operaciones básicas junto con sus operadores asociados, funciones y ejemplos.\n\n\n\nOperación\nOperador\nFunción\n\n\n\n\nSuma\n+\nadd()\n\n\nResta\n-\nsubtract()\n\n\nMultiplicación\n*\nmultiply()\n\n\nDivisión\n/\ndivide()\n\n\nPotencia\n**\npower()\n\n\n\nDefinimos los vectores a y b con los que operaremos y veremos ejemplos:\n\na = np.array([1, 3, 5, 7])\nb = np.array([1, 1, 2, 2])\n\n\nSuma:\n\n\nresultado_1 = a + b\nprint(\"Suma usando +:\", resultado_1) \n\nresultado_2 = np.add(a, b)\nprint(\"Suma usando add():\", resultado_2) \n\nSuma usando +: [2 4 7 9]\nSuma usando add(): [2 4 7 9]\n\n\n\nResta:\n\n\nresultado_1 = a - b\nprint(\"Resta usando -:\", resultado_1) \n\nresultado_2 = np.subtract(a, b)\nprint(\"Resta usando subtract():\", resultado_2) \n\nResta usando -: [0 2 3 5]\nResta usando subtract(): [0 2 3 5]\n\n\n\nMultiplicación:\n\n\nresultado_1 = a * b\nprint(\"Multiplicación usando *:\", resultado_1) \n\nresultado_2 = np.multiply(a, b)\nprint(\"Multiplicación usando multiply():\", resultado_2) \n\nMultiplicación usando *: [ 1  3 10 14]\nMultiplicación usando multiply(): [ 1  3 10 14]\n\n\n\nDivisión:\n\n\nresultado_1 = a / b\nprint(\"División usando /:\", resultado_1) \n\nresultado_2 = np.divide(a, b)\nprint(\"División usando divide():\", resultado_2) \n\nDivisión usando /: [1.  3.  2.5 3.5]\nDivisión usando divide(): [1.  3.  2.5 3.5]\n\n\n\nPotencia:\n\n\nresultado_1 = a ** b\nprint(\"Potencia usando **:\", resultado_1) \n\nresultado_2 = np.power(a, b)\nprint(\"Potencia usando power():\", resultado_2) \n\nPotencia usando **: [ 1  3 25 49]\nPotencia usando power(): [ 1  3 25 49]\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote que si quisieramo operar con un vector b de elementos iguales, podríamos utilizar un escalar.\n\n\n\nb = np.array([2, 2, 2, 2])\n\nresultado_1 = a * b\nprint(\"Usando un vector b = [2, 2, 2, 2]:\", resultado_1) \n\nresultado_2 = a * 2\nprint(\"Usando un escalar b = 2:\", resultado_2) \n\nUsando un vector b = [2, 2, 2, 2]: [ 2  6 10 14]\nUsando un escalar b = 2: [ 2  6 10 14]\n\n\n\n\n6.2.2.2 Logaritmo:\nNumPy provee funciones para los logaritmos de base 2, 10 y e:\n\n\n\nBase\nFunción\n\n\n\n\n2\nlog2()\n\n\n10\nlog10()\n\n\ne\nlog()\n\n\n\nPor ejemplo:\n\n# Ejemplo log2()\nprint(\"Logaritmo base 2:\", np.log2([2, 4, 8, 16]))\n# Ejemplo log10()\nprint(\"Logaritmo base 10:\", np.log10([10, 100, 1000, 10000]))\n# Ejemplo log()\nprint(\"Logaritmo base e:\", np.log([1, np.e, np.e**2]))\n\nLogaritmo base 2: [1. 2. 3. 4.]\nLogaritmo base 10: [1. 2. 3. 4.]\nLogaritmo base e: [0. 1. 2.]\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote que el número de Euler o número e es una constante incluída en NumPy como: np.e\n\n\n\nnp.e\n\n2.718281828459045\n\n\n\n\n6.2.2.3 Funciones trigonométricas:\nA continuación, una lista con las funciones trigonométricas más utilizadas, que toman los valores en radianes:\n\n\n\nFunción trigonométrica\nFunción\n\n\n\n\nseno\nsin()\n\n\ncoseno\ncos()\n\n\ntangente\ntan()\n\n\narcoseno\narcsin()\n\n\narcocoseno\narccos()\n\n\narcotangente\narctan()\n\n\n\nPor ejemplo:\n\n# Ejemplo de seno\nprint(\"Seno de π / 2:\", np.sin(np.pi / 2))\n\n# Ejemplo de arcoseno\nprint(np.arcsin(1))\n\nSeno de π / 2: 1.0\n1.5707963267948966\n\n\n\n# Ejemplo de coseno\nprint(\"Coseno de π:\", np.cos(np.pi))\n\n# Ejemplo de arcocoseno\nprint(\"Arcoseno de -1:\", np.arccos(-1))\n\nCoseno de π: -1.0\nArcoseno de -1: 3.141592653589793\n\n\n\n# Ejemplo de tangente:\nprint(\"Tangente de 0:\", np.tan(0))\n\n# Ejemplo de arcotangente:\nprint(\"Arcotangente de 0:\", np.arctan(0))\n\nTangente de 0: 0.0\nArcotangente de 0: 0.0\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote que el número π es una constante incluída en NumPy como: np.pi\n\n\n\nnp.pi\n\n3.141592653589793\n\n\nPara convertir los radianes a grados y viceversa, se utiliza deg2rad() y rad2deg() respectivamente:\n\nprint(\"De grados [90, 180, 270, 360] a radianes:\", \n      np.deg2rad([90, 180, 270, 360]))\n\nprint(\"De radianes [π/2, π, 1.5*π, 2*π] a grados:\", \n      np.rad2deg([np.pi/2, np.pi, 1.5*np.pi, 2*np.pi]))\n\nDe grados [90, 180, 270, 360] a radianes: [1.57079633 3.14159265 4.71238898 6.28318531]\nDe radianes [π/2, π, 1.5*π, 2*π] a grados: [ 90. 180. 270. 360.]\n\n\n\n\n6.2.2.4 Operaciones con matrices:\nA continuación, una lista con las operaciones que les pueden ser de interés mientras estudian álgebra matricial:\n\n\n\nFunción\nDescripción\n\n\n\n\ndot()\nProducto vectorial\n\n\ntranspose()\nTraspuesta\n\n\nlinalg.inv()\nInversa\n\n\nlinalg.det()\nDeterminante\n\n\n\nDefinimos las matrices 1 y 2 con los que operaremos y veremos ejemplos:\n\n# Crear matrices\nmatriz_1 = np.array([[1, 3], [5, 7]])\nmatriz_2 = np.array([[2, 6], [4, 8]])\n\n\nprint(\"Producto vectorial entre la matriz 1 y 2: \\n\", np.dot(matriz_1, matriz_2))\n\nProducto vectorial entre la matriz 1 y 2: \n [[14 30]\n [38 86]]\n\n\n\nprint(\"Traspuesta de la matriz 1: \\n\", np.transpose(matriz_1))\n\nTraspuesta de la matriz 1: \n [[1 5]\n [3 7]]\n\n\n\nprint(\"Inversa de la matriz 1: \\n\", np.linalg.inv(matriz_1))\n\nInversa de la matriz 1: \n [[-0.875  0.375]\n [ 0.625 -0.125]]\n\n\n\nprint(\"Determinante de la matriz 1: \\n\", np.linalg.det(matriz_1))\n\nDeterminante de la matriz 1: \n -7.999999999999998\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote que así como existen constantes numéricas, existen las matrices particulares como las compuestas por ceros np.zeros(), por unos np.ones() y la matriz identidad np.eyes.\n\n\n\nprint(\"Matriz de identidad de 3x3: \\n\", np.eye(3))\n\nMatriz de identidad de 3x3: \n [[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n\n\n\n\n6.2.2.5 Más operaciones útiles:\n\n\n\n\n\n\n\n\nOperaciones\nFunción\nDescripción\n\n\n\n\nMáximo\nmax()\nValor máximo del array o del eje indicado\n\n\nMínimo\nmin()\nValor mínimo del array o del eje indicado\n\n\nSuma\nsum()\nSuma de todos los elementos o del eje indicado\n\n\nPromedio\nmean()\nPromedio de todos los elementos o del eje indicado\n\n\n\nUtilizando la matriz data como ejemplo:\n\ndata = np.array([[1, 2], [5, 3], [4, 6]])\n\n\nValor máximo\n\n\nprint(\"Valor máximo de todo el array: \", data.max())\nprint(\"Valores máximos de cada columna: \", data.max(axis=0))\n\nValor máximo de todo el array:  6\nValores máximos de cada columna:  [5 6]\n\n\n\nValor mínimo\n\n\nprint(\"Valor mínimo de todo el array: \", data.min())\nprint(\"Valores mínimos de cada fila: \", data.min(axis=1))\n\nValor mínimo de todo el array:  1\nValores mínimos de cada fila:  [1 3 4]\n\n\n\nSuma de elementos:\n\n\nprint(\"Suma de todos los elementos del array: \", data.sum())\nprint(\"Suma de los elementos de cada fila: \", data.sum(axis=1))\n\nSuma de todos los elementos del array:  21\nSuma de los elementos de cada fila:  [ 3  8 10]\n\n\n\nPromedio:\n\n\nprint(\"Promedio de todos los elementos del array: \", data.mean())\nprint(\"Promedio de los elementos de cada columna: \", data.mean(axis=0))\n\nPromedio de todos los elementos del array:  3.5\nPromedio de los elementos de cada columna:  [3.33333333 3.66666667]"
  },
  {
    "objectID": "unidad_6.html#pandas",
    "href": "unidad_6.html#pandas",
    "title": "6  Librerías de Python",
    "section": "6.3 Pandas",
    "text": "6.3 Pandas\nPandas es una librería de código abierto diseñada específicamente para la manipulación y el análisis de datos en Python. Es una herramienta poderosa que puede ayudar a los usuarios a limpiar, transformar y analizar datos de una manera rápida y eficiente.\nDado que se basa en la NumPy, luego de instalarse, se deben importar ambas librerías. Por convención:\n\nimport pandas as pd\n\nPandas incorpora dos estructuras de datos llamados, Series y DataFrames.\n\n6.3.1 Serie\nUna serie es un vector (unidimensional) capaz de contener cualquier tipo de dato, como por ejemplo, números enteros o decimales, strings, objetos de Python, etc.\nPara crearlas, se puede partir de un escalar, una lista, un diccionario, etc., utilizando pd.Serie():\n\n# Crear serie partiendo de una lista:\nlista = [1, \"a\", 3.5]\n\npd.Series(lista)\n\n0      1\n1      a\n2    3.5\ndtype: object\n\n\nNote que se ven dos líneas verticales de datos. A la derecha se observa una columna con los elementos de la lista antes creada, mientas que a la izquierda se encuentra el índice, formado por valores desde 0 a n-1, siendo n la cantidad de elementos. Este índice numérico es el predefinido, por lo que si se deseara uno particular, se puede establecer utilizando index.\nEl índice es de vital importancia ya que permite acceder a los elementos de la serie. Es por ello que al colocar un índice en particular, su longitud debe ser acorde al número de elementos de la misma. De lo contrario, se mostrará un ValueError.\n\n# Crear serie partiendo de una lista, indicando el índice\npd.Series(lista, index = [\"x\", \"y\", \"z\"])\n\nx      1\ny      a\nz    3.5\ndtype: object\n\n\nEn el caso de crear Series utilizando diccionarios, sus claves o keys pasan a formar el índice.\n\n# Crear serie partiendo de un diccionario:\ndiccionario = {\"x\": 1, \"y\": \"a\", \"z\": 3.5}\n\na = pd.Series(diccionario)\na\n\nx      1\ny      a\nz    3.5\ndtype: object\n\n\nComo ya se debe estar imaginando, para acceder a un elemento de la serie, se debe indicar el valor del índice o la posición entre corchetes.\n\n# Acceder al elemento de índice x:\na[\"x\"]\n\n1\n\n\n\n# Acceder al elemento de posición 0:\na[0]\n\n1\n\n\nOtra característica interesante de las series (y de los DataFrames, como se verá a continuación) es la vectorización: así como los arrays, no requieren recorrer valor por valor en un for para realizar operaraciones. Por ejemplo:\n\na + a\n\nx      2\ny     aa\nz    7.0\ndtype: object\n\n\n\n\n6.3.2 DataFrame\nUn DataFrame es una estructura de datos tabular (bidimensional), compuesta por filas y columnas, que se asemeja a una hoja de cálculo de Excel. Para crearlos, se utiliza DataFrame() y se ingresan diferentes estructuras como arrays, diccionarios, listas, series u otros dataframes.\nEn el siguiente ejemplo, se crea un Dataframe partiendo de un diccionario data para las columnas y de una lista label para el índice:\n\ndata = {'columna_1': ['a', 'b', 'c', 'd', 'e', 'f'],\n        'columna_2': [2.5, 3, 0.5, None, 5, None],\n        'columna_3': [1, 3, 2, 3, 2, 3]}\n\nlabels = ['a1', 'a2', 'a3', 'a4', 'a5', 'a6']\n\npd.DataFrame(data, index=labels)\n\n\n\n\n\n\n\n\ncolumna_1\ncolumna_2\ncolumna_3\n\n\n\n\na1\na\n2.5\n1\n\n\na2\nb\n3.0\n3\n\n\na3\nc\n0.5\n2\n\n\na4\nd\nNaN\n3\n\n\na5\ne\n5.0\n2\n\n\na6\nf\nNaN\n3\n\n\n\n\n\n\n\n\n6.3.2.1 Atributos y descripción de un Dataframe\nA continuación, se observa una tabla con métodos que nos permiten conocer las características de un determinado DataFrame.\n\n\n\nMétodo\nDescripción\n\n\n\n\ninfo()\nResume la información del DataFrame\n\n\nshape\nDevuelve una tupla con el número de filas y columnas\n\n\nsize\nNúmero de elementos\n\n\ncolumns\nLista con los nombres de las columnas\n\n\nindex\nLista con los nombres de las filas\n\n\ndtypes\nSerie con los tipos de datos de las columnas\n\n\nhead()\nMuestra las primeras filas\n\n\ntail()\nMuestra las últimas filas\n\n\ndf.describe()\nBrinda métricas de las columnas numéricas\n\n\n\nPara ejemplificar los métodos y las funciones de Pandas, usaremos el DataFrame df definido en la siguiente línea de código.\n\ndata = {'nombre': ['José Martínez', 'Rosa Díaz', 'Javier Garcíaz', 'Carmen López', 'Marisa Collado', 'Antonio Ruiz', 'Antonio Fernández', \n                   'Pilar González', 'Pedro Tenorio', 'Santiago Manzano', 'Macarena Álvarez', 'José Sanz', 'Miguel Gutiérrez', 'Carolina Moreno'],\n        'edad': [18, 32, 24, 35, 46, 68, 51, 22, 35, 46, 53, 58, 27, 20],\n        'sexo': ['H', 'M', 'H', 'M', 'M', 'H', 'H', 'M', 'H', 'H', 'M', 'H', 'H', 'M'],\n        'peso': [85.0, 65.0, None, 65.0, 51.0, 66.0, 62.0, 60.0, 90.0, 75.0, 55.0, 78.0, 109.0, 61.0],\n        'altura': [1.79, 1.73, 1.81, 1.7, 1.58, 1.74, 1.72, 1.66, 1.94, 1.85, 1.62, 1.87, 1.98, 1.77],\n        'colesterol': [182.0, 232.0, 191.0, 200.0, 148.0, 249.0, 276.0, None, 241.0, 280.0, 262.0, 198.0, 210.0, 194.0]}\n\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\nnombre\nedad\nsexo\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n3\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n\n\n4\nMarisa Collado\n46\nM\n51.0\n1.58\n148.0\n\n\n5\nAntonio Ruiz\n68\nH\n66.0\n1.74\n249.0\n\n\n6\nAntonio Fernández\n51\nH\n62.0\n1.72\n276.0\n\n\n7\nPilar González\n22\nM\n60.0\n1.66\nNaN\n\n\n8\nPedro Tenorio\n35\nH\n90.0\n1.94\n241.0\n\n\n9\nSantiago Manzano\n46\nH\n75.0\n1.85\n280.0\n\n\n10\nMacarena Álvarez\n53\nM\n55.0\n1.62\n262.0\n\n\n11\nJosé Sanz\n58\nH\n78.0\n1.87\n198.0\n\n\n12\nMiguel Gutiérrez\n27\nH\n109.0\n1.98\n210.0\n\n\n13\nCarolina Moreno\n20\nM\n61.0\n1.77\n194.0\n\n\n\n\n\n\n\nCon info() se puede ver: - el índice en la primera línea, que es un rango de 0 a 13 - el número total de columnas en la segunda línea - el uso de la memoria en la última - una tabla con los nombres de las columnas en Column, la cantidad de valores no nulos en Non-Null Count y el tipo de dato en Dtype para cada una de ellas.\n\ndf.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 14 entries, 0 to 13\nData columns (total 6 columns):\n #   Column      Non-Null Count  Dtype  \n---  ------      --------------  -----  \n 0   nombre      14 non-null     object \n 1   edad        14 non-null     int64  \n 2   sexo        14 non-null     object \n 3   peso        13 non-null     float64\n 4   altura      14 non-null     float64\n 5   colesterol  13 non-null     float64\ndtypes: float64(3), int64(1), object(2)\nmemory usage: 804.0+ bytes\n\n\nNote que utilizando dtypes, columns e index se obtiene parte de esta información:\n\n# Tipo de dato por columna\ndf.dtypes\n\nnombre         object\nedad            int64\nsexo           object\npeso          float64\naltura        float64\ncolesterol    float64\ndtype: object\n\n\n\n# Nombre de cada columna\ndf.columns\n\nIndex(['nombre', 'edad', 'sexo', 'peso', 'altura', 'colesterol'], dtype='object')\n\n\n\n# índice\ndf.index\n\nRangeIndex(start=0, stop=14, step=1)\n\n\nLa forma del DataFrame es de 14 filas y 6 columnas, por lo que contiene 84 elementos.\n\n# Forma del DataFrame (filas, columnas)\ndf.shape\n\n(14, 6)\n\n\n\n# Número de elementos del DataFrame\ndf.size\n\n84\n\n\nAsimismo, cuando no conocemos un DataFrame, puede ser importante ver las primeras 5 filas con head() o las últimas con tail(). Si se quisiera observar un número determinado, sólo hay que especificarlo, por ejemplo:\n\n# Mostrar las primeras 3 filas.\ndf.head(3)\n\n\n\n\n\n\n\n\nnombre\nedad\nsexo\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n\n\n\n\n\n\n# Mostrar las últimas 5 filas.\ndf.tail()\n\n\n\n\n\n\n\n\nnombre\nedad\nsexo\npeso\naltura\ncolesterol\n\n\n\n\n9\nSantiago Manzano\n46\nH\n75.0\n1.85\n280.0\n\n\n10\nMacarena Álvarez\n53\nM\n55.0\n1.62\n262.0\n\n\n11\nJosé Sanz\n58\nH\n78.0\n1.87\n198.0\n\n\n12\nMiguel Gutiérrez\n27\nH\n109.0\n1.98\n210.0\n\n\n13\nCarolina Moreno\n20\nM\n61.0\n1.77\n194.0\n\n\n\n\n\n\n\nPor otro lado, describe() devuelve un resumen descriptivo de las columnas de valores numéricos, como “edad”, “peso”, “altura” y “colesterol”.\n\ndf.describe()\n\n\n\n\n\n\n\n\nedad\npeso\naltura\ncolesterol\n\n\n\n\ncount\n14.000000\n13.000000\n14.000000\n13.000000\n\n\nmean\n38.214286\n70.923077\n1.768571\n220.230769\n\n\nstd\n15.621379\n16.126901\n0.115016\n39.847948\n\n\nmin\n18.000000\n51.000000\n1.580000\n148.000000\n\n\n25%\n24.750000\n61.000000\n1.705000\n194.000000\n\n\n50%\n35.000000\n65.000000\n1.755000\n210.000000\n\n\n75%\n49.750000\n78.000000\n1.840000\n249.000000\n\n\nmax\n68.000000\n109.000000\n1.980000\n280.000000\n\n\n\n\n\n\n\nEstas métricas podrían obtenerse utilizando funciones determinadas, como: - count(): contabiliza los valores no nulos - mean(): promedio - min(): valor mínimo - max(): valor máximo\nPor ejemplo:\n\ndf.count()\n\nnombre        14\nedad          14\nsexo          14\npeso          13\naltura        14\ncolesterol    13\ndtype: int64\n\n\nFinalmente, como ocurre con las series, para acceder a los elementos de un DataFrame se puede indicar la posición o el nombre de la fila o columna.\nPara acceder a una fila en particular, utilizamos iloc[] con un entero, una lista de enteros o un rango de números que indican las posiciones o con loc[] indicando el valor del índice.\n\n# Mostrar la fila de posición 0:\ndf.iloc[0]\n\nnombre        José Martínez\nedad                     18\nsexo                      H\npeso                   85.0\naltura                 1.79\ncolesterol            182.0\nName: 0, dtype: object\n\n\n\n# Mostrar la fila de posición 0:\ndf.iloc[[0]]\n\n\n\n\n\n\n\n\nnombre\nedad\nsexo\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n\n\n\n\n\n\n# Mostrar las filas de posición 0 y 3:\ndf.iloc[[0, 3]]\n\n\n\n\n\n\n\n\nnombre\nedad\nsexo\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n3\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n\n\n\n\n\n\n\n\n# Mostrar las filas de posiciones entre 0 hasta 3 (exclusive):\ndf.iloc[:3]\n\n\n\n\n\n\n\n\nnombre\nedad\nsexo\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n\n\n\n\n\n\n# Equivalente a df.iloc[:3]:\ndf.head(3)\n\n\n\n\n\n\n\n\nnombre\nedad\nsexo\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n\n\n\n\n\n\n# Mostar la fila cuyo valor del índice es 0:\ndf.loc[0]\n\nnombre        José Martínez\nedad                     18\nsexo                      H\npeso                   85.0\naltura                 1.79\ncolesterol            182.0\nName: 0, dtype: object\n\n\nPor otro lado, para acceder a una columna se pueden utilizar los nombres de la mismas con DataFrame[columna] o su equivalente DataFrame.columna.\n\n# Mostrar la columna \"nombre\"\ndf['nombre'] # o df.nombre\n\n0         José Martínez\n1             Rosa Díaz\n2        Javier Garcíaz\n3          Carmen López\n4        Marisa Collado\n5          Antonio Ruiz\n6     Antonio Fernández\n7        Pilar González\n8         Pedro Tenorio\n9      Santiago Manzano\n10     Macarena Álvarez\n11            José Sanz\n12     Miguel Gutiérrez\n13      Carolina Moreno\nName: nombre, dtype: object\n\n\n\n# Mostrar más de una columna: \"nombre\" y \"edad\":\ndf[['nombre', 'edad']]\n\n\n\n\n\n\n\n\nnombre\nedad\n\n\n\n\n0\nJosé Martínez\n18\n\n\n1\nRosa Díaz\n32\n\n\n2\nJavier Garcíaz\n24\n\n\n3\nCarmen López\n35\n\n\n4\nMarisa Collado\n46\n\n\n5\nAntonio Ruiz\n68\n\n\n6\nAntonio Fernández\n51\n\n\n7\nPilar González\n22\n\n\n8\nPedro Tenorio\n35\n\n\n9\nSantiago Manzano\n46\n\n\n10\nMacarena Álvarez\n53\n\n\n11\nJosé Sanz\n58\n\n\n12\nMiguel Gutiérrez\n27\n\n\n13\nCarolina Moreno\n20\n\n\n\n\n\n\n\nFinalmente, se puede utilizar loc[filas, columnas] que devuelve un DataFrame con los elemento que se encuentra en las filas con los nombres de la lista filas y las columnas con los nombres de la lista columna.\n\n# Mostrar la filas de índice 0, 1, 2, 3, columnas \"nombre\" y \"edad\"\ndf.loc[:3, ['nombre', 'edad']]\n\n\n\n\n\n\n\n\nnombre\nedad\n\n\n\n\n0\nJosé Martínez\n18\n\n\n1\nRosa Díaz\n32\n\n\n2\nJavier Garcíaz\n24\n\n\n3\nCarmen López\n35\n\n\n\n\n\n\n\n\n# O su equivalente:\ndf.loc[df.index[[0, 1, 2, 3]], ['nombre', 'edad']]\n\n\n\n\n\n\n\n\nnombre\nedad\n\n\n\n\n0\nJosé Martínez\n18\n\n\n1\nRosa Díaz\n32\n\n\n2\nJavier Garcíaz\n24\n\n\n3\nCarmen López\n35\n\n\n\n\n\n\n\n\n\n6.3.2.2 Modificar un Dataframe\nA la hora de modificar un DataFrame puede ser que querramos: - cambiar la estructura del mismo, como los nombres de las columnas y de los índices, - agregar una nueva filas o columna - reemplazar un dato en una determinada posición.\nA continuación, se enumeran distintos métodos para llevar a cabo estos cambios.\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nset_index()\nConvierte una determinada columna en el nuevo índice.\n\n\nreset_index()\nReestablece el índice predefinido\n\n\nrename()\nRenombra las columnas\n\n\ninsert()\nAgrega columnas\n\n\nloc[fila]\nAgrega una fila en un índice dado\n\n\ndrop()\nElimina columnas y filas\n\n\nloc[fila, columna]\nModifica un valor particular dado un índice y una columna\n\n\nmap()\nBusca un valor dado en una columna y lo reemplaza\n\n\nreplace()\nReemplaza un valor dado en una columna\n\n\n\nUtilizando set_index() podemos, Por ejemplo, transformar a la columna “nombre” en el nuevo índice, y para volver al predefinido, usando reset_index().\n\ndf = df.set_index(keys = \"nombre\")\ndf.head()\n\n\n\n\n\n\n\n\nedad\nsexo\npeso\naltura\ncolesterol\n\n\nnombre\n\n\n\n\n\n\n\n\n\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n\n\nMarisa Collado\n46\nM\n51.0\n1.58\n148.0\n\n\n\n\n\n\n\n\ndf = df.reset_index()\ndf.head()\n\n\n\n\n\n\n\n\nnombre\nedad\nsexo\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n3\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n\n\n4\nMarisa Collado\n46\nM\n51.0\n1.58\n148.0\n\n\n\n\n\n\n\nPara renombrar una columna, se utiliza rename(columns={\"nombre_columna\": \"nuevo_nombre_columna\"})\n\n# Reemplazo \"nombre\" por \"nombre y apellido\"\ndf = df.rename(columns={\"nombre\": \"nombre y apellido\"})\ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n3\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n\n\n4\nMarisa Collado\n46\nM\n51.0\n1.58\n148.0\n\n\n\n\n\n\n\nPara agregar una nueva columna, existe el método insert(), que requiere indicar La posición de la nueva columna, el nombre de la nueva columna, y los valores de la misma. Para ello, creamos una lista llamada direccion con 14 valores, para cada una de las personas del DataFrame.\n\n# Valores de la nueva columna\ndireccion = [\"CABA\", \"Bs As\", \"Bs As\", \"Bs As\", \"CABA\", \"Bs As\", \"CABA\", \"CABA\", \"CABA\", \"CABA\", \"CABA\", \"Bs As\", \"CABA\", \"CABA\"]\n\n# Insertar la columna \"direccion\" en la posición 3:\ndf.insert(3, \"direccion\", direccion)\ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\ndireccion\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\nCABA\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\nBs As\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nBs As\nNaN\n1.81\n191.0\n\n\n3\nCarmen López\n35\nM\nBs As\n65.0\n1.70\n200.0\n\n\n4\nMarisa Collado\n46\nM\nCABA\n51.0\n1.58\n148.0\n\n\n\n\n\n\n\nPara agregar una nueva fila, se utiliza el ya conocido loc[], que requiere indicar el índice y los valores de la misma. Para ello, creamos una lista llamada nueva_fila con valores para cada columna del DataFrame.\n\n# Valores de la nueva fila\nnueva_fila = ['Carlos Rivas', 28, 'H', \"Bs As\", 89.0, 1.78, 245.0]\n\n# Insertar la fila 14\ndf.loc[14] = nueva_fila\ndf.tail()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\ndireccion\npeso\naltura\ncolesterol\n\n\n\n\n10\nMacarena Álvarez\n53\nM\nCABA\n55.0\n1.62\n262.0\n\n\n11\nJosé Sanz\n58\nH\nBs As\n78.0\n1.87\n198.0\n\n\n12\nMiguel Gutiérrez\n27\nH\nCABA\n109.0\n1.98\n210.0\n\n\n13\nCarolina Moreno\n20\nM\nCABA\n61.0\n1.77\n194.0\n\n\n14\nCarlos Rivas\n28\nH\nBs As\n89.0\n1.78\n245.0\n\n\n\n\n\n\n\nPara eliminar una columna (axis=1) o fila (axis=0), se utiliza drop():\n\n# Elimino la columna \"direccion\", equivalente a del df[\"direccion\"]\ndf = df.drop('direccion', axis=1)  \ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\n\n\n3\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n\n\n4\nMarisa Collado\n46\nM\n51.0\n1.58\n148.0\n\n\n\n\n\n\n\n\n# Elimino la fila 14\ndf = df.drop(14, axis=0) \ndf.tail()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\n\n\n\n\n9\nSantiago Manzano\n46\nH\n75.0\n1.85\n280.0\n\n\n10\nMacarena Álvarez\n53\nM\n55.0\n1.62\n262.0\n\n\n11\nJosé Sanz\n58\nH\n78.0\n1.87\n198.0\n\n\n12\nMiguel Gutiérrez\n27\nH\n109.0\n1.98\n210.0\n\n\n13\nCarolina Moreno\n20\nM\n61.0\n1.77\n194.0\n\n\n\n\n\n\n\n\n\n\n\n\n\nAgregar columnas con operaciones\n\n\n\nComo se ha mencionado anteriormente, gracias a la vectorización se pueden agregar columnas partiendo de operaciones entre columnas existentes en el DataFrame.\n\n\nPor ejemplo, suponga que queremos ingresar una columna el índice de masa corporal de las personas que se calcula de la siguiente manera:\n\\[\nIMC = \\frac{Peso(kg)}{Altura(m)^2}\\]\n\n# Crear la columna \"IMC\"\ndf[\"IMC\"] = df[\"peso\"] / df[\"altura\"]**2\ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n26.528510\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n21.718066\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\nNaN\n\n\n3\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n22.491349\n\n\n4\nMarisa Collado\n46\nM\n51.0\n1.58\n148.0\n20.429418\n\n\n\n\n\n\n\nDe manera análoga, se puede crear la columna dirección sin utilizar insert(). Usando la lista direccion:\n\ndf[\"direccion\"] = direccion\ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\ndireccion\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n26.528510\nCABA\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n21.718066\nBs As\n\n\n2\nJavier Garcíaz\n24\nH\nNaN\n1.81\n191.0\nNaN\nBs As\n\n\n3\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n22.491349\nBs As\n\n\n4\nMarisa Collado\n46\nM\n51.0\n1.58\n148.0\n20.429418\nCABA\n\n\n\n\n\n\n\nFinalmente, para cambiar un valor determinado se utiliza loc[], como por ejemplo, agregar el peso de Javier García (tercera fila):\n\ndf.loc[2, 'peso'] = 92\ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\ndireccion\n\n\n\n\n0\nJosé Martínez\n18\nH\n85.0\n1.79\n182.0\n26.528510\nCABA\n\n\n1\nRosa Díaz\n32\nM\n65.0\n1.73\n232.0\n21.718066\nBs As\n\n\n2\nJavier Garcíaz\n24\nH\n92.0\n1.81\n191.0\nNaN\nBs As\n\n\n3\nCarmen López\n35\nM\n65.0\n1.70\n200.0\n22.491349\nBs As\n\n\n4\nMarisa Collado\n46\nM\n51.0\n1.58\n148.0\n20.429418\nCABA\n\n\n\n\n\n\n\nPara transformar los valores de una columna entera, podemos utilizar map() pasando un diccionario del estilo {valor_viejo: valor_nuevo}. Por ejemplo, modificar la columna “sexo” reemplazando “H” por “M” y “M” por “F”:\n\ndf['sexo'] = df['sexo'].map({'H': 'M', 'M': 'F'})\ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\ndireccion\n\n\n\n\n0\nJosé Martínez\n18\nM\n85.0\n1.79\n182.0\n26.528510\nCABA\n\n\n1\nRosa Díaz\n32\nF\n65.0\n1.73\n232.0\n21.718066\nBs As\n\n\n2\nJavier Garcíaz\n24\nM\n92.0\n1.81\n191.0\nNaN\nBs As\n\n\n3\nCarmen López\n35\nF\n65.0\n1.70\n200.0\n22.491349\nBs As\n\n\n4\nMarisa Collado\n46\nF\n51.0\n1.58\n148.0\n20.429418\nCABA\n\n\n\n\n\n\n\nOtra manera sería utilizando replace(), como en la columna “direccion” donde se modificó “Bs As” por “Buenos Aires”.\n\ndf['direccion'] = df['direccion'].replace('Bs As', 'Buenos Aires')\ndf.head()\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\ndireccion\n\n\n\n\n0\nJosé Martínez\n18\nM\n85.0\n1.79\n182.0\n26.528510\nCABA\n\n\n1\nRosa Díaz\n32\nF\n65.0\n1.73\n232.0\n21.718066\nBuenos Aires\n\n\n2\nJavier Garcíaz\n24\nM\n92.0\n1.81\n191.0\nNaN\nBuenos Aires\n\n\n3\nCarmen López\n35\nF\n65.0\n1.70\n200.0\n22.491349\nBuenos Aires\n\n\n4\nMarisa Collado\n46\nF\n51.0\n1.58\n148.0\n20.429418\nCABA\n\n\n\n\n\n\n\n\n\n6.3.2.3 Filtrar un Dataframe\nPara filtrar los elementos de un DataFrame se suelen utilizar condiciones lógicas. Por ejemplo:\n\n# Seleccionar aquellas personas menores de 40 años:\ndf[df['edad'] &lt; 40]\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\ndireccion\n\n\n\n\n0\nJosé Martínez\n18\nM\n85.0\n1.79\n182.0\n26.528510\nCABA\n\n\n1\nRosa Díaz\n32\nF\n65.0\n1.73\n232.0\n21.718066\nBuenos Aires\n\n\n2\nJavier Garcíaz\n24\nM\n92.0\n1.81\n191.0\nNaN\nBuenos Aires\n\n\n3\nCarmen López\n35\nF\n65.0\n1.70\n200.0\n22.491349\nBuenos Aires\n\n\n7\nPilar González\n22\nF\n60.0\n1.66\nNaN\n21.773842\nCABA\n\n\n8\nPedro Tenorio\n35\nM\n90.0\n1.94\n241.0\n23.913275\nCABA\n\n\n12\nMiguel Gutiérrez\n27\nM\n109.0\n1.98\n210.0\n27.803285\nCABA\n\n\n13\nCarolina Moreno\n20\nF\n61.0\n1.77\n194.0\n19.470778\nCABA\n\n\n\n\n\n\n\nCuando se requieren múltiples condiciones, se puede adicionar usando símbolos como & para intersecciones y | para uniones. Por ejemplo:\n\n# Seleccionar aquellas personas de sexo femenino y menores de 40 años:\ndf[(df['edad'] &lt; 40) & (df['sexo'] == 'F')]\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\ndireccion\n\n\n\n\n1\nRosa Díaz\n32\nF\n65.0\n1.73\n232.0\n21.718066\nBuenos Aires\n\n\n3\nCarmen López\n35\nF\n65.0\n1.70\n200.0\n22.491349\nBuenos Aires\n\n\n7\nPilar González\n22\nF\n60.0\n1.66\nNaN\n21.773842\nCABA\n\n\n13\nCarolina Moreno\n20\nF\n61.0\n1.77\n194.0\n19.470778\nCABA\n\n\n\n\n\n\n\n\n# Seleccionar aquellas personas cuyo peso es 60kg o 90kg:\ndf[(df['peso'] == 60.0) | (df['peso'] == 90.0)]\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\ndireccion\n\n\n\n\n7\nPilar González\n22\nF\n60.0\n1.66\nNaN\n21.773842\nCABA\n\n\n8\nPedro Tenorio\n35\nM\n90.0\n1.94\n241.0\n23.913275\nCABA\n\n\n\n\n\n\n\nCuando se desea filtrar con un cierto rango en una determinada columna, se pueden utilizar las condiciones antes mencionadas o la función between().\n\n# Equivalente a df[(df['edad'] &gt; 25) & (df['edad'] &lt; 40)]\ndf[df['edad'].between(25, 40)]\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\ndireccion\n\n\n\n\n1\nRosa Díaz\n32\nF\n65.0\n1.73\n232.0\n21.718066\nBuenos Aires\n\n\n3\nCarmen López\n35\nF\n65.0\n1.70\n200.0\n22.491349\nBuenos Aires\n\n\n8\nPedro Tenorio\n35\nM\n90.0\n1.94\n241.0\n23.913275\nCABA\n\n\n12\nMiguel Gutiérrez\n27\nM\n109.0\n1.98\n210.0\n27.803285\nCABA\n\n\n\n\n\n\n\nFinalmente, puede ser interesante encontrar aquellas las filas con datos faltantes o NaN. Para ello, se utiliza la función isnull() que devuelve True si el valor de la columna es nulo o NaN. Por ejemplo:\n\ndf['IMC'].isnull()\n\n0     False\n1     False\n2      True\n3     False\n4     False\n5     False\n6     False\n7     False\n8     False\n9     False\n10    False\n11    False\n12    False\n13    False\nName: IMC, dtype: bool\n\n\nPara visualizar aquella fila donde el índice de masa corporal es nulo, filtramos:\n\ndf[df['IMC'].isnull() == True]\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\ndireccion\n\n\n\n\n2\nJavier Garcíaz\n24\nM\n92.0\n1.81\n191.0\nNaN\nBuenos Aires\n\n\n\n\n\n\n\n\n\n6.3.2.4 Otros métodos útiles\nA continuación, se muestra una lista con métodos que resultan muy útiles a la hora de analizar datos:\n\n\n\n\n\n\n\nMétodo\nDescripción\n\n\n\n\nsort_values(by, ascending)\nOrdena el DataFrame considerando los valores de la o las columnas determinadas\n\n\nvalue_counts()\nIndica los valores únicos de una determinada columna y el número de veces que aparece en ella\n\n\ngroupby().agg()\nAgrupa las filas según ciertos valores de columnas y aplica funciones\n\n\n\n\nSort value:\n\nPara utilizar la función sort_values(by, ascending), se debe indicar en el parámetro by una lista con las columnas para ordenar el DataFrame y en ascending, True si el orden deseado es creciente o False para decreciente.\nEn el siguiente ejemplo ordenamos por “nombre y apellido” en forma alfabética:\n\ndf.sort_values(by=['nombre y apellido'], ascending=[True])\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\ndireccion\n\n\n\n\n6\nAntonio Fernández\n51\nM\n62.0\n1.72\n276.0\n20.957274\nCABA\n\n\n5\nAntonio Ruiz\n68\nM\n66.0\n1.74\n249.0\n21.799445\nBuenos Aires\n\n\n3\nCarmen López\n35\nF\n65.0\n1.70\n200.0\n22.491349\nBuenos Aires\n\n\n13\nCarolina Moreno\n20\nF\n61.0\n1.77\n194.0\n19.470778\nCABA\n\n\n2\nJavier Garcíaz\n24\nM\n92.0\n1.81\n191.0\nNaN\nBuenos Aires\n\n\n0\nJosé Martínez\n18\nM\n85.0\n1.79\n182.0\n26.528510\nCABA\n\n\n11\nJosé Sanz\n58\nM\n78.0\n1.87\n198.0\n22.305471\nBuenos Aires\n\n\n10\nMacarena Álvarez\n53\nF\n55.0\n1.62\n262.0\n20.957171\nCABA\n\n\n4\nMarisa Collado\n46\nF\n51.0\n1.58\n148.0\n20.429418\nCABA\n\n\n12\nMiguel Gutiérrez\n27\nM\n109.0\n1.98\n210.0\n27.803285\nCABA\n\n\n8\nPedro Tenorio\n35\nM\n90.0\n1.94\n241.0\n23.913275\nCABA\n\n\n7\nPilar González\n22\nF\n60.0\n1.66\nNaN\n21.773842\nCABA\n\n\n1\nRosa Díaz\n32\nF\n65.0\n1.73\n232.0\n21.718066\nBuenos Aires\n\n\n9\nSantiago Manzano\n46\nM\n75.0\n1.85\n280.0\n21.913806\nCABA\n\n\n\n\n\n\n\nAhora, ¿Qué ocurre cuando ordenamos siguiendo varias columnas? Los valores del DataFrame se ordenan siguiendo la primera columna en primer lugar, luego la segunda, y así sucesivamente.\n\ndf.sort_values(by=['direccion', 'nombre y apellido'], ascending=[True, True])\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\ndireccion\n\n\n\n\n5\nAntonio Ruiz\n68\nM\n66.0\n1.74\n249.0\n21.799445\nBuenos Aires\n\n\n3\nCarmen López\n35\nF\n65.0\n1.70\n200.0\n22.491349\nBuenos Aires\n\n\n2\nJavier Garcíaz\n24\nM\n92.0\n1.81\n191.0\nNaN\nBuenos Aires\n\n\n11\nJosé Sanz\n58\nM\n78.0\n1.87\n198.0\n22.305471\nBuenos Aires\n\n\n1\nRosa Díaz\n32\nF\n65.0\n1.73\n232.0\n21.718066\nBuenos Aires\n\n\n6\nAntonio Fernández\n51\nM\n62.0\n1.72\n276.0\n20.957274\nCABA\n\n\n13\nCarolina Moreno\n20\nF\n61.0\n1.77\n194.0\n19.470778\nCABA\n\n\n0\nJosé Martínez\n18\nM\n85.0\n1.79\n182.0\n26.528510\nCABA\n\n\n10\nMacarena Álvarez\n53\nF\n55.0\n1.62\n262.0\n20.957171\nCABA\n\n\n4\nMarisa Collado\n46\nF\n51.0\n1.58\n148.0\n20.429418\nCABA\n\n\n12\nMiguel Gutiérrez\n27\nM\n109.0\n1.98\n210.0\n27.803285\nCABA\n\n\n8\nPedro Tenorio\n35\nM\n90.0\n1.94\n241.0\n23.913275\nCABA\n\n\n7\nPilar González\n22\nF\n60.0\n1.66\nNaN\n21.773842\nCABA\n\n\n9\nSantiago Manzano\n46\nM\n75.0\n1.85\n280.0\n21.913806\nCABA\n\n\n\n\n\n\n\nAnalicemos el ejemplo anterior, donde queremos ordenar según “direccion” y “nombre y apellido”. Allí, primero se ordena de manera creciente por dirección, resultando en dos grupos: el superior con “direccion” = “Buenos Aires” y el inferior con “CABA”. Luego, cada uno de esos grupos se ordena por “nombre y apellido” de forma creciente.\n\n\n\nEjemplo de sort_values()\n\n\n\nValue Count:\n\nUtilizando value_counts() se pueden contar las filas en cada grupo según “direccion”. Es decir, cuantas filas hay para “Buenos Aires” y para “CABA”.\n\ndf['direccion'].value_counts()\n\nCABA            9\nBuenos Aires    5\nName: direccion, dtype: int64\n\n\n\nGroup by:\n\ngroupby() es un método que nos permite agrupar los datos del DataFrame según los valores de una o unas columnas dadas, tranformándose estas en el nuevo índice de los grupos. Por ejemplo, si quisieramos agrupar por:\n\n“direccion”: corremos df.groupby(['direccion']) obteniendo una tabla con valores agrupados por “direccion”, siendo esta columna el nuevo índice.\n“direccion” y “sexo”: corremos df.groupby(['direccion', 'sexo']) obteniendo una tabla con valores agrupados por “direccion” y “sexo”, siendo ambas columnas el nuevo índice.\n\n\n\n\nEjemplo de groupby()\n\n\nUna vez obtenidos los grupos que deseamos analizar, podemos realizar una función de agregación agg() utilizando algunas o todas las columnas restantes. Estas funciones pueder ser suma, media, mínimo, máximo, contar valores no nulos, entre otras. Veamos algunos ejemplos:\n\n# Agrupar por \"direccion\" y contar los valores no nulos de todas las columnas\ndf.groupby(['direccion']).agg('count')\n\n\n\n\n\n\n\n\nnombre y apellido\nedad\nsexo\npeso\naltura\ncolesterol\nIMC\n\n\ndireccion\n\n\n\n\n\n\n\n\n\n\n\nBuenos Aires\n5\n5\n5\n5\n5\n5\n4\n\n\nCABA\n9\n9\n9\n9\n9\n8\n9\n\n\n\n\n\n\n\n\n# Agrupar por \"direccion\" y \"sexo\" y contar los valores no nulos de alguna columnas\ndf.groupby(['direccion', 'sexo'])[['edad', 'peso']].agg('count')\n\n\n\n\n\n\n\n\n\nedad\npeso\n\n\ndireccion\nsexo\n\n\n\n\n\n\nBuenos Aires\nF\n2\n2\n\n\nM\n3\n3\n\n\nCABA\nF\n4\n4\n\n\nM\n5\n5\n\n\n\n\n\n\n\nTambién se puede asignar para cada columna, una operación distinta:\n\n# Agrupar por \"direccion\" y \"sexo\" y calcular el valor máximo de la columna \"colesterol\" y el promedio de \"peso\"\ndf.groupby(['direccion', 'sexo']).agg({'colesterol': ['max'], 'peso': ['mean']})\n\n\n\n\n\n\n\n\n\ncolesterol\npeso\n\n\n\n\nmax\nmean\n\n\ndireccion\nsexo\n\n\n\n\n\n\nBuenos Aires\nF\n232.0\n65.000000\n\n\nM\n249.0\n78.666667\n\n\nCABA\nF\n262.0\n56.750000\n\n\nM\n280.0\n84.200000\n\n\n\n\n\n\n\n\n# Agrupar por \"direccion\" y \"sexo\" y calcular los valores máximos y mínimos de la columna \"colesterol\" y el promedio de \"peso\"\ndf.groupby(['direccion', 'sexo']).agg({'colesterol': ['min', 'max'], 'peso': ['mean']})\n\n\n\n\n\n\n\n\n\ncolesterol\npeso\n\n\n\n\nmin\nmax\nmean\n\n\ndireccion\nsexo\n\n\n\n\n\n\n\nBuenos Aires\nF\n200.0\n232.0\n65.000000\n\n\nM\n191.0\n249.0\n78.666667\n\n\nCABA\nF\n148.0\n262.0\n56.750000\n\n\nM\n182.0\n280.0\n84.200000"
  },
  {
    "objectID": "unidad_6.html#matplotlib",
    "href": "unidad_6.html#matplotlib",
    "title": "6  Librerías de Python",
    "section": "6.4 Matplotlib",
    "text": "6.4 Matplotlib\nMatplotlib es probablemente la librería de Python más usada para crear gráficos, también llamados plots. Esta provee una forma rápida de graficar datos en varios formatos de alta calidad que pueden ser compartidos y/o publicados, resultando una alternativa open source de MATLAB. De hecho, matplotlib.pyplot es una colección de funciones que hacen que matplotlib funcione como MATLAB, con comandos análogos y argumentos similares.\nComo ya se imagina, el primer paso es importar la librería. Por convención:\n\nimport matplotlib.pyplot as plt\n\n\n6.4.1 Creación de gráficos con matplotlib\nPara crear un gráfico con matplotlib, se deben seguir los siguientes pasos:\n\nCrear la figura que contendrá el gráfico, utilizando las funciones subplots() o figure(). Se recomienda la primera, como se verá más adelante.\nGraficar los datos, utilizando distintas funciones dependiendo del tipo de gráfico que se desea realizar:\n\n\n\n\nFunción\nTipo de Gráfico\n\n\n\n\nplot()\nGráfico de línea\n\n\nscatter()\nGráfico de puntos\n\n\nbar()\nGráfico de barras verticales\n\n\nbarh()\nGráfico de barras horizontales\n\n\npie()\nGráfico de torta\n\n\n\n\nPersonalizar el gráfico. Este paso no es mandatorio, pero sí, muy recomendado para lograr un mejor entendimiento de la visualización\nMostrar el gráfico, utilizando la función show()\n\nEsto quiere decir que, si deseamos visualizar datos rápidamente, podríamos realizarlo corriendo únicamente las siguientes tres líneas de código:\nOpción 1\nfig = plt.figure()  \nplt.funcion_grafico_elegido()       # Reemplazar funcion_grafico_elegido() por una función\nplt.show()  \nOpción 2\nfig, ax = plt.subplots()  \nax.funcion_grafico_elegido()        # Reemplazar funcion_grafico_elegido() por una función     \nplt.show()  \nPero, ¿cuál debería usar? Eso depende de lo que quieras hacer. A continuación, se verá el detalle de lo que está ocurriendo en cada línea, para que así puedas elegir qué es lo mejor para vos.\n\nplt.figure()\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\nplt.subplots()\n\n(&lt;Figure size 672x480 with 1 Axes&gt;, &lt;Axes: &gt;)\n\n\n\n\n\nSi bien no se puede ver un gráfico en ninguno de los outputs, analicemos lo que nos imprime:\n\nfig = plt.figure() crea una figura pero sin axes, por lo que muestra &lt;Figure size 640x480 with 0 Axes&gt;.\nfig, ax = plt.subplots() permite crear ambos: figura y axes, por lo que muestra &lt;Figure size 640x480 with 1 Axes&gt;, &lt;AxesSubplot: &gt;).\n\nNote además, que se ha seguido una convención al nombrarse la figura como fig y los axes como ax. Pero… ¿qué es una figura y un axes?\nUna figura es el marco que delimita la zona donde se trazan los gráficos, mientras que los axes, son lo que llamamos comunmente gráficos, es decir, son las áreas donde los puntos se pueden especificar en términos de coordenadas. Por lo tanto, una figura puede contener muchos axes, pero un axes determinado sólo puede estar contenido en una única figura.\n\n\n\nEsquema de figuras y axes\n\n\n\n\n\n\n\n\n¡Ojo! No confundir axes con axis\n\n\n\n\nLos Axis son los ejes cartesianos que se encargan de establecer los límites, la escala y las dimensiones del gráfico: un axes puede tener 2 Axis, si es un gráfico plano, o 3, si es un gráfico en 3D.\n\n\nEntonces, con lo aprendido hasta el momento, volvamos a revisar las líneas de código anteriores:\nOpción 1\nfig = plt.figure()                  # Se crea una figura vacía sin Axes\nplt.funcion_grafico_elegido()       # Se grafica según la función elegida\nplt.show()                          # Mostrar \nEsta opción es más amigable para principiantes ya que es más conciso y resulta muy útil cuando simplemente se desea crear un gráfico para verificar resultados rápidamente.\nOpción 2\nfig, ax = plt.subplots()            # Se crea una figura con un único Axes\nax.funcion_grafico_elegido()        # Se grafica según la función elegida\nplt.show()                          # Mostrar\nEsta opción es ideal cuando necesitamos un enfoque más flexible, con gráficos más complejos o con un ajuste fino como los que veremos en este apunte.\n\n\n6.4.2 Partes de una Figura y personalización\nEsta imagen, fue obtenida de la referencia de matplotlib y resume de manera fácil y visual las modificaciones que podemos hacerla a las figuras creadas.\n\n\n\nPartes de una Figura\n\n\nSi desea conocer más detalle, puede ingresar a https://matplotlib.org/stable/tutorials/introductory/quick_start.html.\nCon lo aprendido hasta el momento, vamos a realizar nuestro primer gráfico para luego mostrar cómo modificar su aspecto. La función que usaremos es plot(), con la que se obteniene un gráfico de línea; esta recibe los vectores X e Y para formar puntos en el plano cartesiano que son unidos con una línea.\n\n# Grafico elemental\nx = [0,2,10,11,18,25]\ny = [0,1,2,3,4,5]\n\nfig, ax = plt.subplots()\n\n# Gráfico de línea\nax.plot(x, y)\nplt.show()\n\n\n\n\n\n6.4.2.1 Cambiar el aspecto de los gráficos:\nPara diferenciar las curvas o simplemente para modificar los gráficos según nuestros gustos personales, se pueden definir los distintos parámetros dentro de plot(), estableciendo el tipo de línea y puntos, el grosor, el color, etc:\n\ncolor = nombre del color, por ejemplo: 'blue', 'green', 'red', etc.\nmarker = forma de los puntos o marcadores, por ejemplo: '^', 'o', 'v', etc.\nlinestyle = estilo de línea, por ejemplo: 'solid', 'dashed', 'dotted' o sus equivalentes:'-', '--', ':', entre otros.\nmarkersize, linewidth = con un número, establecemos el tamaño del marcador y el espesor de la línea respectivamente.\n\nNote que si no le asignamos un valor, se establecen los predefinidos.\n\nx = [0,2,10,11,18,25]   # Tiempo (min)\ny = [0,1,2,3,4,5]       # Distancia (m)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)\nplt.show()\n\n\n\n\nPara ver las múltiples opciones disponibles, les dejamos el siguiente link de consulta: https://matplotlib.org/2.1.1/api/_as_gen/matplotlib.pyplot.plot.html\n\n\n6.4.2.2 Grilla o cuadrícula:\nPara leer facilmente el valor de cada punto, podemos agregar una cuadrícula usando grid().\nSi deseamos modificarle, por ejemplo, el color, el estilo de línea, o sólo queremos ver uno de los ejes, podemos indicarlo utilizando parámetros muy similares a los vistos anteriormente pero en la funcion grid().\n\nx = [0,2,10,11,18,25]   # Tiempo (min)\ny = [0,1,2,3,4,5]       # Distancia (m)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)\n\n# Grilla preestablecida\nax.grid()\nplt.show()\n\n\n\n\n\n#Gráfica con la grilla preestablecida\nx = [0,2,10,11,18,25]   # Tiempo (min)\ny = [0,1,2,3,4,5]       # Distancia (m)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)\n\n#Grilla modificada\nax.grid(axis = 'y', color = 'gray', linestyle = 'dashed')\nplt.show()\n\n\n\n\n\n\n6.4.2.3 Títulos\nUna de las partes más importantes para que un gráfico se pueda entender es ponerle un título y explicar qué significa cada eje. Eso se hace con las funciones set_xlabel(), set_ylabel() y set_title(). Cada una recibe un string que se usará como etiqueta del eje X, etiqueta del eje Y o título, respectivamente.\nSiendo que los valores de x son el tiempo medido en minutos y los de y una distancia en metros, entonces:\n\nx = [0,2,10,11,18,25]   # Tiempo (min)\ny = [0,1,2,3,4,5]       # Distancia (m)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)\n\n# Mostrar el título del gráfico\nax.set_title(\"Gráfico de posición\")\n\n# Mostrar el título de los ejes\nax.set_xlabel('Tiempo (min)')\nax.set_ylabel('Distancia (m)')\n\n# Grilla preestablecida\nax.grid()\nplt.show()\n\n\n\n\n\n\n6.4.2.4 Referencias\nEl gráfico con el que estamos trabajando sólo tiene una línea, pero si contara con más de una, el uso de referencias sería escencial para lograr el entendimiento del mismo. Para rotular las líneas, dentro de plot() se debe definir la referencia como label. Luego se coloca legend()\n\nx = [0,2,10,11,18,25]   # Tiempo (min)\ny = [0,1,2,3,4,5]       # Distancia (m)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, label='Objeto 1', color='green', marker='^', linestyle='--', markersize=8, linewidth=1.2)\n\n# Mostrar el título del gráfico\nax.set_title(\"Gráfico de posición\")\n\n# Mostrar el título de los ejes\nax.set_xlabel('Tiempo (min)')\nax.set_ylabel('Distancia (m)')\n\n# Agregar la refencia\nax.legend()\n\n# Grilla preestablecida\nax.grid()\nplt.show()\n\n\n\n\n\n\n6.4.2.5 Características de los ejes:\nComo podemos identificar en los gráficos anteriores, Python decidió las características de los ejes:\n\nEje x: se extiende del 0 a 25, de 5 en 5.\nEje y: se extiende del 0 a 5, de 1 en 1.\n\nPodemos establecer los limites del eje x e y usando set_xlim() y set_ylim() respectivamente.\n\nx = [0,2,10,11,18,25]   # Tiempo (min)\ny = [0,1,2,3,4,5]       # Distancia (m)\n\nfig, ax = plt.subplots()\n\nax.plot(x, y, label='Objeto 1', color='green', marker='^', linestyle='--',\n        markersize=8, linewidth=1.2)\n\n# Mostrar el título del gráfico\nax.set_title(\"Gráfico de posición\")\n\n# Mostrar el título de los ejes\nax.set_xlabel('Tiempo (min)')\nax.set_ylabel('Distancia (m)')\n\n# Establecer los límites de los ejes\nax.set_xlim(0, 30)\nax.set_ylim(0, 6)\n\n# Agregar la refencia\nax.legend()\n\n# Grilla preestablecida\nax.grid()\nplt.show()\n\n\n\n\n\n\n\n6.4.3 Tipos de gráficos\nA continuación, vamos a ver ejemplos de los tipos de gráficos más comunes, las funciones que son necesarias para crearlos y cuándo se debe utilizar cada uno de ellos.\nPara estos ejemplos, los datos a graficar son valores de listas únicamente por fines didácticos, ya que podría tratarse de arrays o columnas de DataFrames. Además, recuerden que mucho de lo aprendido para modificar el aspecto de un gráfico, como agregar títulos, cuadrículas, límites a los ejes, etc., se puede aplicar también en estas figuras.:\n\n6.4.3.1 Gráfico de línea\nEl gráfico de línea permite visualizar cambios en los valores lo largo de un rango continuo (tendencias), como puede ser el tiempo o la distancia. Para crearlo, se utiliza la función plot(), como vimos anteriormente:\n\nx = [0,2,10,11,18,25]\ny = [0,1,2,3,4,5]\n\nfig, ax = plt.subplots()\n\nax.plot(x, y)\nplt.show()\n\n\n\n\n\n\n6.4.3.2 Gráfico de dispersión o puntos\nEl gráfico de dispersión o puntos permite visualizar la relación entre las variables. Para crearlo, se utiliza la función scatter():\n\nx = [5,7,8,7,2,17,2,9,4,11,12,9,6]\ny = [99,86,87,88,111,86,103,87,94,78,77,85,86]\n\nfig, ax = plt.subplots()\n\nax.scatter(x, y)\nplt.show()\n\n\n\n\n\n\n6.4.3.3 Gráfico de barras\nEl gráfico de barras permite visualizar proporciones, comparando dos o más valores entre sí. Para crearlo, se utiliza la función bar(), la cual primero recibe, en primer lugar, las etiquetas de las barras que se van a mostrar y en segundo lugar, la altura correspondiente a cada una de estas barras.\n\npeso = [340, 115, 200, 200, 270]\ningredientes = ['chocolate', 'manteca', 'azúcar', 'huevo', 'harina']\n\nfig, ax = plt.subplots()\n\nax.bar(ingredientes, peso)\n\nax.set_xlabel('Ingredientes')\nax.set_ylabel('Masa (g)')\n\nax.set_title(\"Receta\")\n\nplt.show()\n\n\n\n\nNote que con la función anterior, las barras adquieren una dirección vertical: si quisieramos verlas de manera horizontal, debemos usar la función barh() y cambiar los títulos de los ejes según corresponda:\n\npeso = [340, 115, 200, 200, 270]\ningredientes = ['chocolate', 'manteca', 'azúcar', 'huevo', 'harina']\n\nfig, ax = plt.subplots()\n\nax.barh(ingredientes, peso)\n\nax.set_ylabel('Ingredientes')\nax.set_xlabel('Masa (g)')\n\nax.set_title(\"Receta\")\n\nplt.show()\n\n\n\n\n\n\n6.4.3.4 Gráfico de torta\nEl gráfico de torta, como el de barras, permite visualizar y comparar proporciones pero de manera circular y como partes de un todo. Para crearlo, se utiliza la función pie(), la cual podría recibir solamente números pero es útil también saber qué simboliza cada parte. Por eso, para referenciar cada porción se usa el parámetro labels. Por otro lado, el parámetro autopct establece cómo se mostrará el porcentaje: por ejemplo, %1.1f%% le indica que el porcentaje tendrá un decimal, mientras que %1.2f%% tendrá dos decimales.\n\npeso = [340, 115, 200, 200, 270]\ningredientes = ['chocolate', 'manteca', 'azúcar', 'huevo', 'harina']\n\nfig, ax = plt.subplots()\n\nax.pie(peso, labels= ingredientes, autopct='%1.1f%%')\n\nax.set_title(\"Receta\")\n\nplt.show()\n\n\n\n\n\n\n\n6.4.4 Gráficos múltiples\nEn los casos anteriores, creamos siempre un sólo gráfico con una curva, en una figura. Pero… ¿Cómo podríamos graficar varias curvas en un mismo gráfico?\n\n# Valores que se desean graficar\nx = [0, 1, 2, 3, 4, 5]\ny_linear = [0, 1, 2, 3, 4, 5]\ny_quadratic = [0, 1, 4, 9, 16, 25]\ny_cubic = [0, 1, 8, 27, 64, 125]\n\nfig, ax = plt.subplots(figsize=(5, 3))\n\nax.plot(x, y_linear, label='Lineal')\nax.plot(x, y_quadratic, label='Cuadrático')\nax.plot(x, y_cubic, label='Cúbico')\n\nax.set_title(\"Gráfico de múltiples curvas\")\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.legend()\n\nplt.show()\n\n\n\n\nNote que se agregan nuevos datos al mismo axes, por lo que siempre usamos plot() pero con distintos valores de y. Asimismo, se estableció un tamaño de la figura con figsize=(width, height)\n\n\n6.4.5 Grilla de gáficos\nTambién podríamos querer ver varios axes en una misma figura. Para ello, tenemos que definir, como si se tratase de una matriz o tabla, cuántas columnas ncols y cuantas nrows de gráficos deseamos. Por ejemplo, supongamos que quiero ver dos gráficos en una misma fila:\n\nfig, ax = plt.subplots(nrows=1, ncols=2)   # o simplemente plt.subplots(1,2)\n\n\n\n\nDe manera análoga, podemos representar las 3 curvas anteriores pero viendo 3 filas de gráficos en una única columna:\n\n# Valores que se desean graficar\nx = [0, 1, 2, 3, 4, 5]\nx_linear = [0, 1, 2, 3, 4, 5]\nx_quadratic = [0, 1, 4, 9, 16, 25]\nx_cubic = [0, 1, 8, 27, 64, 125]\n\nfig, ax = plt.subplots(nrows=3, ncols=1)\n\nax[0].plot(x, x_linear)\nax[0].set_title('Lineal')\n\nax[1].plot(x, x_quadratic)\nax[1].set_title('Cuadrático')\n\nax[2].plot(x, x_cubic)\nax[2].set_title('Cúbico')\n\nplt.show()\n\n\n\n\nEntonces, lo único que debemos hacer es indicar la posición del axes con números dentro del corchete . Si tengo varias columnas y filas, dentro del corchete, se indica primero la fila y luego la columna: ax[fila, columna].\n\nfig, ax = plt.subplots(nrows=3, ncols=3)\nfig.subplots_adjust(wspace=0.5, hspace=0.5) # Con esto indicamos el espacio libre entre los subplots\n\nax[0, 1].plot(x, x_linear)\nplt.show()\n\n\n\n\n\n\n6.4.6 Funciones de Gráficas\nEn términos generales, si nos encontramos en la situacion de copiar y pegar las mismas líneas de código para realizar gráficos similares, trendríamos que pensar en crear una función que simplifique esta tarea. Por ejemplo:\n\nx = [0, 1, 2, 3, 4, 5]\nx_linear = [0, 1, 2, 3, 4, 5]\nx_quadratic = [0, 1, 4, 9, 16, 25]\nx_cubic = [0, 1, 8, 27, 64, 125]\n\nfig, ax=plt.subplots(3)\nax[0].plot(x,x_linear,label=\"$x$\",color=\"r\")\nax[0].set_xlabel(\"eje x\")\nax[0].set_ylabel(\"eje y\")\nax[0].legend()\nax[0].grid()\n\n\nax[1].plot(x,x_quadratic,label=\"$x^2$\",color=\"b\")\nax[1].set_xlabel(\"eje x\")\nax[1].set_ylabel(\"eje y\")\nax[1].legend()\nax[1].grid()\n\n\nax[2].plot(x,x_cubic,label=\"$x^3$\",color=\"g\")\nax[2].set_xlabel(\"eje x\")\nax[2].set_ylabel(\"eje y\")\nax[2].legend()\nax[2].grid()\nplt.show()\n\n\n\n\nPara evitar lo anterior, definimos una función a la que le debemos entregar los valores a graficar:\n\ndef crear_grafico(x, y, label, ax, xlabel, ylabel, title, color):\n  \"\"\"Crea un gráfico a partir de vectores con valores de los ejes x e y.\n    Recibe además:\n    - El texto para el label\n    - El subplot a donde graficar\n    - Un label para el eje x\n    - Un label para el eje y\n    - Un título para el gráfico\n    - Un color\n    El color y el eje pueden ser None. En ese caso toman valores por default\"\"\"\n\n  if color == None:\n    color = \"blue\"\n\n  # Si sólo haremos un gráfico, no necesito indicarle la posición\n  if ax == None:\n      fig, ax = plt.subplots()\n\n  # Definimos el gráfico\n  ax.plot(x, y, label=label, color=color)\n  ax.set_xlabel(xlabel)\n  ax.set_ylabel(ylabel)\n  ax.set_title(title)\n\n  return ax\n\n\nfig , ax = plt.subplots(3)\n\n# En vez de copiar y pegar el código, llamo a la función crear_grafico():\ncrear_grafico(x, x_linear, \"x\", ax[0], \"Eje x\", \"Eje y\", \"Lineal\", color=\"green\")\ncrear_grafico(x, x_quadratic, \"$x^2$\", ax[1], \"Eje x\", \"Eje y\", \"Cuadrática\", color=\"red\")\ncrear_grafico(x, x_cubic, \"$x^3$\", ax[2], \"Eje x\", \"Eje y\", \"Cúbica\", None)\n\n# Hacemos un for para agregar la cuadrícula y las referencias en cada axes:\nfor axes in fig.axes[:]:\n  axes.grid()\n  axes.legend()\n\n\n\n\nComo comentamos dentro de la función, también podemos usar crear_grafico() para un único gráfico:\n\ncrear_grafico(x, x_linear, \"x\", None, \"\", \"\", \"\", \"green\")\n\n&lt;Axes: &gt;\n\n\n\n\n\n\n\n6.4.7 Gráficos utilizando NumPy y Pandas\n\nNumPy:\n\nCuando se realizó el gráfico lineal, cuadrático y cúbico de x, se utilizaron listas de Python. A continuación puede ver lo fácil que podría realizarse utilizando NumPy:\n\nx = np.arange(0, 6)\ny_linear = x\ny_quadratic = x**2\ny_cubic = x**3\n\nfig, ax = plt.subplots(figsize=(5, 3))\n\nax.plot(x, y_linear, label='Lineal')\nax.plot(x, y_quadratic, label='Cuadrático')\nax.plot(x, y_cubic, label='Cúbico')\n\nax.set_title(\"Gráfico de múltiples curvas\")\nax.set_xlabel('x')\nax.set_ylabel('y')\nax.legend()\n\nplt.show()\n\n\n\n\n\nPandas:\n\nSi deseamos visualizar los datos contenidos en un DataFrame, podemos realizarlo facilmente. Definimos df:\n\ndata = {'animal': ['gato','chinchilla', 'perro'],\n        'edad': [2.5, 3, 7],\n        'visitas': [1, 3, 2],\n        'prioridad': ['si', 'si', 'no']}\n\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\nanimal\nedad\nvisitas\nprioridad\n\n\n\n\n0\ngato\n2.5\n1\nsi\n\n\n1\nchinchilla\n3.0\n3\nsi\n\n\n2\nperro\n7.0\n2\nno\n\n\n\n\n\n\n\n\n# Determino las columnas del DataFrame que queremos graficar\nx_values = df['animal']\ny_values = df['edad']\n\nfig, ax = plt.subplots()\n\nax.bar(x_values, y_values)\n\nax.set_xlabel('Animal')\nax.set_ylabel('Edad (años)')\n\nax.set_title(\"Mascotas\")\n\nplt.show()"
  },
  {
    "objectID": "guia.html#recomendaciones-al-realizar-las-guías",
    "href": "guia.html#recomendaciones-al-realizar-las-guías",
    "title": "Guía de Ejercicios",
    "section": "Recomendaciones al realizar las guías",
    "text": "Recomendaciones al realizar las guías\n\nPrestá atención al leer el enunciado. En particular:\n\nSi se pide una función que devuelva o calcule un valor, la función debe tener una función return.\nSi se pide una función que imprima un valor, la función debe tener un print.\nSi se pide una función que pida o pregunte algo al usuario, la función debe tener un input.\nA menos que se diga específicamente “pedirle al usuario”, no es necesario que el programa contenga input. En todo caso, hacer que la función reciba el o los datos por parámetro.\n\nCada ejercicio puede tener muchas soluciones posibles. Una vez que encuentres una solución, en lugar de pasar al siguiente ejercicio, pensá si se te ocurre una solución cuya codificación sea más simple.\nEs muy importante que el código sea lo más claro y legible posible.\n\nEn particular, nombres de funciones y variables deben ser descriptivos.\nTambién prestá atención a los espacios en blanco y a la indentación.\n\nNo documentes en exceso, pero tampoco ahorres documentación necesaria.\nProbá siempre que el código cumpla con lo solicitado."
  },
  {
    "objectID": "guia.html#guía-1-introducción-a-la-algoritmia-y-la-programación",
    "href": "guia.html#guía-1-introducción-a-la-algoritmia-y-la-programación",
    "title": "Guía de Ejercicios",
    "section": "Guía 1: Introducción a la Algoritmia y la Programación",
    "text": "Guía 1: Introducción a la Algoritmia y la Programación\n\n\n\n\n\n\nRecomendación\n\n\n\nEn esta guía nos dedicaremos a introducirnos en los conceptos de programación y algoritmo. Para los primeros seis ejercicios, te recomendamos ver este video para recordar cómo entiende la computadora nuestras instrucciones.\n\n\n\nSe tiene que explicar a una máquina exactamente cómo servir un vaso de jugo (de los que vienen en cartón) de la heladera. Recordando la definición de algoritmo, hacer una descripción paso a paso de lo que se tiene que hacer y usar para lograr el objetivo. Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nSe tiene que explicar a una máquina exactamente cómo hacer una tostada con queso, pensá qué ingredientes se necesitan con sus cantidades, cómo tiene que ser el espacio de trabajo y los elementos que va a necesitar usar. Recordando la definición de algoritmo, hacer una descripción paso a paso de lo que se tiene que hacer y usar para hacer una tostada con queso. Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nSe te pide que organices una colecta de alimentos no perecederos por la Ciudad de Buenos Aires. Contamos con algunos automóviles y camionetas de voluntarios, un listado de donaciones, listado de los alimentos a donar, la disponibilidad horaria y la dirección en la cual se dejan los alimentos. La colecta se realiza en un solo día. ¿Cómo la organizarías? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nTenés que enviar invitaciones personalizadas para tu cumpleaños. Cada invitación tiene que mencionar el nombre de la persona y la relación que tiene con vos. Contamos con una impresora a la que le das el texto a enviar, un listado con los nombres de los invitados y la relación que cada uno tiene con vos. ¿Cómo redactarías el texto de la invitación? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nSe te encargó definir qué datos son necesarios para el registro de estudiantes en un curso de inglés. ¿Qué datos crees que deberían ser obligatorios y cuáles opcionales? ¿Y si el curso es de cocina? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nContás con un listado de cosas a comprar y tenes que ir a un supermercado que cuenta con distintas góndolas o pasillos. Cada góndola o pasillo puede contar con varios, uno o ninguno de los productos de tu lista. ¿Cuál sería el listado de instrucciones para poder terminar lo más rápido posible? Pista: No vas a necesitar nada de código en este ejercicio, sólo nombrar los pasos.\nCon el anexo de Replit de la Unidad 1, realizá tu primer programa: hacé que se imprima por pantalla un “¡Hola mundo!”."
  },
  {
    "objectID": "guia.html#guía-2-tipos-de-datos-expresiones-y-funciones",
    "href": "guia.html#guía-2-tipos-de-datos-expresiones-y-funciones",
    "title": "Guía de Ejercicios",
    "section": "Guía 2: Tipos de Datos, Expresiones y Funciones",
    "text": "Guía 2: Tipos de Datos, Expresiones y Funciones\n\nGuardar el texto “Hola, Mundo!” en una variable e imprimirla por pantalla.\nGuardar los números 1, 2 y 3 en tres variables distintas e imprimirlos por pantalla.\n\nGuardar los números 1, 2 y 3 en tres variables distintas y luego sumarlos e imprimir el resultado por pantalla.\n\nRepetir con las distintas operaciones disponibles que se vieron en la unidad 2: resta, multiplicación, división, división entera, resto, potencia; combinando los números entre sí.\n\nCrear un programa que le solicite al usuario:\n\nSu nombre y lo imprima por pantalla.\nSu edad y la imprima por pantalla.\nSu edad, le sume 1, y la imprima por pantalla.\n\nCrear un programa que le solicite al usuario un número, y que devuelva el resto obtenido de dividirlo por 2.\n¿Qué operador vimos para obtener el resto?\nEscribir un programa que le pida al usuario su año de nacimiento, y que le diga qué edad tiene en el año actual.\nCrear un programa que le solicite al usuario 5 enteros y que muestre por pantalla el promedio de ellos. Hacerlo de dos formas:\n\nPrimero, usando 5 variables para cada entero.\nDespués, usando una sola variable para almacenar la suma de los 5 enteros. ¿Cómo se te ocurre que podrías hacer?\n\nCrear una función que reciba un número y que devuelva el valor absoluto.\nCrear una función que reciba un número y que devuelva True si es par, y False si es impar.\nCrear una función que reciba un número y un string, y que devuelva ambos concatenados dentro de un nuevo string.\nCrear una función que reciba dos enteros y que devuelva el resto y el cociente entre ellos.\nCrear una función que le pida al usuario su nombre y apellido, e los imprima con el siguiente formato: “Apellido, Nombre”.\nHacer una función que reciba una palabra y devuelva la cantidad de letras que tiene.\n\nHacer una función que reciba una palabra y que imprima los primeros 5 caracteres únicamente. Ejemplo: Si se recibe “pensamiento” se debe imprimir “pensa”.\nHacer una función que reciba una palabra y que imprima sólo los caracteres ubicados en posiciones pares. Ejemplo: Si se recibe “pensamiento” se debe imprimir “pnaino”.\nHacer una función que reciba una palabra y que imprima la palabra dada vuelta. Ejemplo: Si se recibe “materia” se debe imprimir “airetam”.\n\nHacer una funcion que reciba una palabra, le borre todas las letras “a” e imprima el resultado por pantalla. Pista: usar una función predefinida de Python. Ejemplo: Si se recibe “casa” se debe imprimir “cs”. Pista: usar slices.\nAnalizar qué tipo de dato (o error) se obtiene al hacer las siguientes operaciones:\n\n5 / 2\n5 // 2\n5 % 2\n5 ** 2\n5.0 / 2\n5.0 // 2\n5.0 % 2\n5.0 ** 2\n5 / 2.0\n5 // 2.0\n5 % 2.0\n5 ** 2.0\n5.0 / 2.0\n5.0 // 2.0\n5.0 % 2.0\n5.0 ** 2.0\n\"Hola\" * 2\n\"Hola\" + 2\n\"Hola\" + \"2\"\nx = \"Hola\"\nx += \" mundo\"\n\n\nEscribir una función que convierta un valor dado en grado Celcius, a Fahrenheit. Recordar que la fórmula para la conversión es: F = 9/5 * C + 32.\nEscribir una función que convierta un valor dado en grados Fahrenheit, a Celcius. Usar la misma fórmula anterior.\n\nEscribir una función que calcule el área de un triángulo recibiendo como parámetros su base y su altura.\nSiendo el cálculo de la norma de un vector \\(v\\) en \\(R^3\\):\n\\[||v|| = \\sqrt{v_1^2 + v_2^2 + v_3^2}\\]\nEscribir una función que calcule la norma de un vector en R3 recibiendo como parámetros las 3 componentes \\(v_1\\), \\(v_2\\) y \\(v_3\\) del mismo.\nDesafío (no obligatorio): Calcular el área de un rectángulo (alineado con los ejes \\(x\\) e \\(y\\)), dadas sus coordenadas \\(x_1\\), \\(x_2\\), \\(y_1\\) e \\(y_2\\)."
  },
  {
    "objectID": "guia.html#guía-3-estructuras-de-control",
    "href": "guia.html#guía-3-estructuras-de-control",
    "title": "Guía de Ejercicios",
    "section": "Guía 3: Estructuras de Control",
    "text": "Guía 3: Estructuras de Control\n\n1. Decisiones\n\nEscribir una función que, dado un número entero \\(n\\), calcule si es impar o no.\nEscribir una implementación propia de la función \\(abs\\), que devuelva el valor absoluto de cualquier valor que reciba. Ejemplo: mi_abs(5) devuelve 5 y mi_abs(-5) devuelve 5. Pista: No se puede usar la función predefinida abs.\nEscribir una función que reciba un número y devuelva True si es entero y False si no lo es. Pista: no se puede usar la función isinstance.\nEscribir una función para determinar si una letra recibida es vocal o no. La misma debe devolver un valor booleano. Luego, escribir una función para determinar si una letra es consonante o no.\n\nResolver sin el uso de in ni not in.\nResolver usando in y not in.\nResolver para que la función identifique tanto mayúsculas como minúsculas. Pista: investigar los métodos lower y upper de string.\n\n\n\n\n\n\n\n\nTip: in y not in\n\n\n\n\n\n¿Conocés el uso de in?\nPara saber si un elemento está en una lista o en un string, podemos usar in y not in. Por ejemplo:\n\n'a' in 'hola'\n\nTrue\n\n\n\n'w' in 'hola'\n\nFalse\n\n\n\n'w' not in 'hola'\n\nTrue\n\n\n\n'casa' in ['cama', 'mesa', 'silla']\n\nFalse\n\n\n\n\n\n\nEscribir funciones que resuelvan los siguientes problemas:\n\nDado un año, que devuelva si es bisiesto. Nota: un año es bisiesto si es un número divisible por 4, pero no si es divisible por 100, excepto que también sea divisible por 400.\nDado un mes y un año, que devuelva la cantidad de días correspondientes.\nPedirle al usuario su día y mes de cumpleaños. El programa debe imprimir un mensaje indicando a qué signo corresponde el usuario.\n\nAries: 21 de marzo al 20 de abril.\nTauro: 21 de abril al 20 de mayo.\nGeminis: 21 de mayo al 21 de junio.\nCancer: 22 de junio al 23 de julio.\nLeo: 24 de julio al 23 de agosto.\nVirgo: 24 de agosto al 23 de septiembre.\nLibra: 24 de septiembre al 22 de octubre.\nEscorpio: 23 de octubre al 22 de noviembre.\nSagitario: 23 de noviembre al 21 de diciembre.\nCapricornio: 22 de diciembre al 20 de enero.\nAcuario: 21 de enero al 19 de febrero.\nPiscis: 20 de febrero al 20 de marzo.\nPiedra, papel o tijera: escribir un programa de “Piedra, papel o tijera” tal que sea imposible que el usuario gane. El usuario debe ingresar R (piedra), P (papel), o T (tijera) y la computadora debe siempre ganarle. Ejemplo:\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: R\n¡Papel! ¡Gané!\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: P\n¡Tijera! ¡Gané!\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: T\n¡Piedra! ¡Gané!\n¡Piedra (R), papel (P) o tijera (T)!\nIngrese jugada: M\nEsa jugada no está disponible.\nSuponiendo que el primer día del año fue lunes, escribir una función que reciba un número con el día del año (de 1 a 366) y devuelva el día de la semana que le toca. Por ejemplo: si se recibe ‘3’, debe devolver “miércoles”, y si se recibe ‘9’, debe devolver “martes”.\n\n\n\n2. Ciclos\n\nEscribir función que:\n\nImprima por pantalla todos los números entre 10 y 20.\nSalude a todas las personas de esta lista [Flaminia, Serena, Agustina, Priscila, Sol, Agostina, Iara, Lu] con el mensaje \"Hola &lt;nombre&gt;! Vamos a aprender a programar\".\nLe pida al usuario que ingrese 5 números y le muestre la suma total de todos ellos.\nImprima por pantalla todos los números entre 100 y 199 que sean divisibles por 7.\nReciba dos números, y recorra todos los números entre ellos, imprimiendo en pantalla si es par o impar. Por ejemplo, recibiendo 1 y 3, debe imprimir:\n\n1 es impar\n2 es par\n3 es impar\nSe quiere hacer un programa para enseñar a los niños las tablas de multiplicar del 1 al 10. Crear una función que reciba un número e imprima por pantalla la tabla de multiplicar de ese número. Ejemplo:\nmostrar_tablas_para(1)\ndebe imprimir:\n1 x 1 = 1\n1 x 2 = 2\n1 x 3 = 3\n1 x 4 = 4\n1 x 5 = 5\n1 x 6 = 6\n1 x 7 = 7\n1 x 8 = 8\n1 x 9 = 9\n1 x 10 = 10\nmostrar_tablas_para(-2)\ndebe imprimir:\nError: El número debe ser positivo y estar entre 1 y 10\nCrear una función que cante el feliz cumpleaños. Dado un entero, debe imprimir ‘Que los cumplas feliz’ en distintas líneas por esa cantidad de veces.\n\nNecesitamos escribir un programa de cobro en el supermercado. La función debe recibir un número entero que representa el monto a pagar y debe permitir al usuario que ingrese valores, hasta que el pago se haya realizado en su totalidad. Además, le debe ir indicando cuánto le queda por pagar. El programa no da vuelto.\n\nEjemplo: Su total a pagar es: 500  Ingrese el monto a pagar: 100  Pendientes: 400. Ingrese el monto a pagar: 200  Pendientes: 200. Ingrese el monto a pagar: 200  Pendientes: 0. Gracias por su compra.\n\nHacer que el programa anterior dé vuelto:\n\nEjemplo: Su total a pagar es: 500  Ingrese el monto a pagar: 100  Pendientes: 400. Ingrese el monto a pagar: 200  Pendientes: 200. Ingrese el monto a pagar: 300  Pendientes: 0. Su vuelto es: 100. Gracias por su compra.\nEscribir un programa que le pida al usuario que ingrese un número. Para ese número, se imprime la tabla de multiplicar del 1 al 10. Luego, se le vuelve a pedir otro número. Si el usuario ingresa “X”, el programa debe terminar. El usuario debe poder ingresar números indefinidamente hasta que ingrese “X”. Se puede reutilizar la función del ejercicio 9 de esta guía.\nEjemplo: Hola! Esto es Tablas de Multiplicar  Ingrese un número o \"X\" para salir: 1  1 x 1 = 1  1 x 2 = 2  1 x 3 = 3  1 x 4 = 4  1 x 5 = 5  1 x 6 = 6  1 x 7 = 7  1 x 8 = 8  1 x 9 = 9  1 x 10 = 10  Ingrese un número o \"X\" para salir: -2  Error: El número debe ser positivo y estar entre 1 y 10  Ingrese un número o \"X\" para salir: X  ¡Adios!\nManejo de contraseñas\n\nEscribir un programa que contenga una constraseña inventada, que le pregunte al usuario la contraseña, y no le permita continuar hasta que la haya ingresado correctamente.\nModificar el programa anterior para que solamente permita una cantidad fija de intentos.\nModificar el programa anterior para que sea una función que devuelva si el usuario ingresó o no la contraseña correctamente, mediante un valor booleano (True o False).\n\n\nHacer una función que reciba un número del 1 al 10, y luego permita al usuario poder adivinar ese número, ingresando valores repetidamente. Para cada ingreso del usuario, el programa debe indicarle si su numero es menor o mayor al número a adivinar. Una vez que el usuario ingresa el número correcto, lo felicita y termina.\nRepetir permitiendo únicamente 3 intentos.\nRepetir generando el número aleatoriamente de la siguiente forma dentro de la función, sin recibirlo por parámetro:\n\n\n\nimport random\nnumero_a_adivinar = random.randint(1, 10)\nprint(numero_a_adivinar)\n\n5\n\n\n\n\n\n\n\n\nTip: Librerías\n\n\n\n\n\n¿Sabías que Python tiene muchas librerías que podés usar para hacer cosas más complejas? Por ejemplo, la librería random tiene funciones para generar números aleatorios. También hay otras librerías como Pandas para trabajar con datos, Matplotlib para hacer gráficos, Numpy para trabajar con matrices, y muchas más. Vamos a estar viendo estas tres en la última unidad de la materia.\nUna librería es un conjunto de funciones que alguien más escribió y que podemos usar en nuestros programas. Para usar una librería, primero tenemos que importarla. Por ejemplo, para usar la librería random, tenemos que poner import random al principio de nuestro programa (arriba de todo en nuestro archivo). Luego, podemos usar las funciones de la librería, como random.randint(1, 10).\n\n\n\n\n\nQueremos modelar una máquina de sacar juguetes. Debemos hacer una función que reciba un número que representa la cantidad de fichas \\(x\\) que necesita la máquina para funcionar. Se debe imprimir un mensaje en pantalla que indique “Ingresá \\(x\\) fichas para comenzar”. El usuario deberá ingresar entonces letras “F”, que representan a las fichas. Notar que si se ingresa algo distinto a “F”, se ignora.\n\nSe debe seguir solicitando fichas siempre que no se haya alcanzado la cantidad necesaria para funcionar. Cuando se haya alcanzado la cantidad necesaria, se debe imprimir un mensaje que indique “¡A jugar!”. Ejemplo:\nIngresá 2 fichas para comenzar: F\nIngresá 2 fichas para comenzar: B\nIngresá 2 fichas para comenzar: Hola\nIngresá 2 fichas para comenzar: F\n¡A jugar!\n\nModificar el programa anterior para que vaya mostrando la cantidad de fichas que faltan para comenzar a jugar. Ejemplo:\n\nIngresá 2 fichas para comenzar: F\nIngresá 1 fichas para comenzar: B\nIngresá 1 fichas para comenzar: ficha\nIngresá 1 fichas para comenzar: F\n¡A jugar!\nCrear una función que calcule si un número es primo o no. Un número es primo cuando solamente es divisible por sí mismo y por 1. Pista: usar el operador módulo %.\nDesafío (obligatorio): Crear una función que reciba un número entero e imprima los números primos entre 0 y el número ingresado.\nDesafío (obligatorio):\n\nCrear una función que reciba dos números, y devuelva la suma de todos los números múltiplos de 7 entre esos dos números. Por ejemplo, si recibe 3 y 25, debe devolver 7 + 14 + 21 = 42. Si recibe 3 y 4, debe devolver 0, ya que no hay múltiplos de 7 entre esos dos números.\nRepetir calculando el promedio en vez de la suma.\nRepetir calculando únicamente el promedio entre los primeros 3 múltiplos de 7 encontrados. Pista: usar break.\nRepetir calculando únicamente el promedio entre los múltiplos de 7 encontrados que no sean múltiplos de 2. Pista: usar continue.\n\nDesafío (obligatorio):\n\nEscribir una función que dada la cantidad de ejercicios de un examen, y el porcentaje de ejercicios bien resueltos necesario para aprobar dicho examen, revise un grupo de exámenes.\n\nPara ello, en cada paso debe preguntarle al usuario la cantidad de ejercicios resueltos por el alumno, o pedirle que ingrese “*” para salir. Debe mostrar por pantalla el porcentaje correspondiente a la cantidad de ejercicios resueltos respecto a la cantidad de ejercicios del examen y una leyenda que indique si aprobó o no.\n\nAdicional al punto anterior: imprimir un mensaje informándole al usuario la cantidad de ejercicios y el % de aprobación.\nValidar que el usuario siempre ingrese números positivos y menor o iguales a la cantidad de ejercicios del examen, o “*“. De lo contrario, mostrar un mensaje de error y volver a pedirle el dato al usuario."
  },
  {
    "objectID": "guia.html#guía-4-tipos-de-estructuras-de-datos",
    "href": "guia.html#guía-4-tipos-de-estructuras-de-datos",
    "title": "Guía de Ejercicios",
    "section": "Guía 4: Tipos de Estructuras de Datos",
    "text": "Guía 4: Tipos de Estructuras de Datos\n\nCadenas de caracteres\n\nEscribir funciones que dada una cadena y un caracter:\n\nInserte el caracter entre cada letra de la cadena. Ejemplo: 'separar' y '-' debería devolver 's-e-p-a-r-a-r'.\n\nReemplace todos los espacios por el caracter. Ejemplo: 'mi archivo de texto.txt' y '_’ debería devolver 'mi_archivo_de_texto.txt'.\n\nReemplace todos los dígitos de la cadena por el caracter. Ejemplo: 'su clave es: 1540' y '*' debería devolver 'su clave es: ****'.\n\nInserte el caracter cada 3 dígitos en la cadena. Ejemplo: '2552552550' y '.' debería devolver '255.255.255.0'\nModificar todas las anteriores para que, adicionalmente, reciba un parámetro que indique la cantidad máxima de reemplazos o inserciones a realizar. Ejemplo: 'su clave es: 1540', '*' y 3 debería devolver 'su clave es: ***0'.\n\nEscribir una función que reciba una cadena que contiene un largo número entero y devuelva una cadena con el número y las separaciones de miles. Por ejemplo, si recibe 1234567890, debe devolver 1.234.567.890. Cuidado: no es lo mismo 123.456.789.0 que 1.234.567.890. Tienen que ser separaciones de miles y quedar un número válido.\nEscribir funciones que dada una cadena de caracteres:\n\nDevuelva la primera letra de cada palabra. Ejemplo: si se recibe Ciclo Básico Común se debe devolver CBC.\nIndique si se trata de un palíndromo. Por ejemplo, anita lava la tina es un palíndromo (se lee igual de izquierda a derecha que de derecha a izquierda).\n\nEscribir funciones que dadas dos cadenas de caracteres:\n\nIndique si la segunda cadena es subcadena de la primera. Por ejemplo, 'compu' es subcadena de 'computacional'.\nDevuelva la que sea anterior en orden alfábetico. Por ejemplo, si recibe 'kde' y 'gnome' debe devolver 'gnome'.\n\nEscribir una función que, dada una cadena de caracteres, devuelva una lista con cada uno de los caracteres que la componen en mayúscula. Ejemplo: 'Hola' debe devolver ['H', 'O', 'L', 'A']. Restricción: no se permite el uso de ciclos for/while.\nEscribir una función que, dada una cadena de caracteres, devuelva una tupla con cada uno de los caracteres que no es una vocal. Ejemplo: 'Algoritmos' debe devolver ('l', 'g', 'r', 't', 'm', 's'). Restricción: no se permite el uso de ciclos for/while.\nEscribir una función que, dada una cadena de caracteres, devuelva el número de índice del último caracter. Por ejemplo, para la cadena 'Hola' debe devolver 3. Restricción: no se permite el uso de ciclos for/while.\nDesafío (obligatorio):\n\nSe quiere implementar un buscador dentro de un editor de texto, que permita encontrar todas las ocurrencias de una palabra en un texto. Para ello, se debe implementar una función que reciba como parámetro una palabra y un texto, y que devuelva una lista con las posiciones de inicio de cada ocurrencia de la palabra dentro del texto. Ejemplo: si se busca 'al' en 'calcule el precio al valor actual', debe devolver [1, 18, 22, 31]. Pista: index devolverá un error si la subcadena no se encuentra. ¿Qué otro método tenemos disponible para buscar subcadenas?\nModificar la función anterior para que devuelva la cantidad de ocurrencias encontradas. Ejemplo: si se busca 'al' en 'calcule el precio al valor actual', debe devolver 4. Restricción: No se puede usar el método len.\n\nDesafío (no obligatorio): Escribir una función que reciba dos cadenas de caracteres y devuelva una lista con todos los caracteres que no tienen en común. Ejemplo: 'Python' y 'Hola' debería devolver el conjunto de letras ['P', 'y', 't', 'l', 'a', 'n'], indiferentemente del orden y de si está en mayúscula o minúscula. Nota: para que un caracter esté en la lista, no es necesario que esté en la misma posición. Restricción: no se permite el uso de ciclos for/while. Pista: investigar cómo usar lambda.\n\n\n\nRangos, Tuplas y Listas\n\nUsar un rango para:\n\nImprimir los números del 10 al 50 inclusive, saltando de 5 en 5.\nImprimir los números del 40 al 20 en orden decreciente, saltando de 2 en 2.\nCrear una lista con los números del 4 al 10. Luego, acceder con el índice a los elementos que contienen a los números 4, 6 y 9 e impimirlos por pantalla. Pista: recordar que los índices comienzan en 0.\n\nEscribir una función que reciba:\n\nUna lista y devuelva True si su longitud es par y False si su longitud es impar.\n\nUna lista de números cualesquiera y devuelva el elemento máximo y el mínimo.\nUna lista de números y devuelva otra lista con los mismos números ordenados de menor a mayor. Por ejemplo, si recibe [5, 10, 7, 3] debe devolver [3, 5, 7, 10].\n\n\nEscribir una función que reciba una lista de nombres y un número, que representa el cupo. La función debe devolver en una lista a los nombres que no pudieron entrar al curso por falta de cupo. Ejemplo: chequear_cupo(['Agustina', 'Iara', 'Priscila', 'Sol', 'Lucía'], 3) debe devolver ['Sol', 'Lucía'].\nModificar la función anterior para que devuelva únicamente a la última persona de la lista de la gente que pudo entrar. Ejemplo: chequear_cupo(['Agustina', 'Iara', 'Priscila', 'Sol', 'Lucía'], 3) debe devolver 'Priscila', porque es la última que tuvo cupo.\n\nDada la lista de tuplas [(\"Argentina\", 3), (\"España\",1), (\"Uruguay\", 2), (\"Francia\",2)], donde cada tupla contiene un país y la cantidad de mundiales que ganaron:\n\nHacer una función que reciba la lista por parámetro e imprima la información de cada país con el siguiente formato:\n\nPaís: &lt;nombre&gt; - Copas: &lt;cantidad&gt;\nSi y sólo si el país es “Argentina”, se debe imprimir el nombre con 3 estrellas: \"Argentina⭐⭐⭐\". Usar el operador abreviado +=.\n\nHacer una función que reciba la lista por parámetro y devuelva la cantidad de mundiales que ganaron entre todos los países. Ejemplo: contar_mundiales([(\"Argentina\", 3), (\"España\",1), (\"Uruguay\", 2), (\"Francia\",2)]) debe devolver 8.\nHacer una función que reciba la lista por parámetro y la devuelva, ordenada por cantidad de copas ganadas.\nHacer una función que reciba la lista por parámetro y devuelva una lista con los países que tienen más de una copa ganada.\n\nEscribir una función que reciba dos fichas de dominó y determine si encajan o no entre sí.\n\nResolver teniendo en cuenta que las fichas se reciben con formato de tuplas. Ejemplo: (3,4) y (5,4).\nResolver teniendo en cuenta que las fichas se reciben con formato de string. Ejemplo: '3-4' y '5-4'.\n\nEscribir una función que reciba dos vectores y devuelva su producto escalar. El producto escalar se calcula como: Siendo \\(v1 = (v1_1, v1_2, ..., v1_n)\\) y \\(v2 = (v2_1, v2_2, ..., v2_n)\\), entonces\n\\[v1 \\cdot v2 = (v1_1 \\cdot v2_1) + (v1_2 \\cdot v2_2) + ... + (v1_n \\cdot v2_n)\\] Si los vectores no tienen las mismas dimensiones, la función debe devolver None.\nSe tiene una base de datos con nombres de libros de la siguiente forma [\"La Noche de la Usina\", \"La Pregunta de sus Ojos\", \"Ser Feliz era Esto\",...], y se quiere saber cuántos libros repetidos tienen. Escribir una función que reciba la base de datos y devuelva, para cada uno de los títulos, cuántos ejemplares hay. La lista no tiene un tamaño fijo, y puede contener muchos títulos repetidos.\n\nEscribir una función que reciba una tupla, un índice, y un nuevo valor. La función debe modificar la tupla, cambiando el valor en la posición dada por el índice, por el nuevo valor pasado como parámetro. Devolver la tupla modificada.\nRepetir el ejercicio anterior, pero con una lista.\nRepetir ambos si ahora, en vez de recibir un índice, se recibe el valor a eliminar. Si no se contiene al valor, se devuelve la estructura tal cual se recibió.\n\nEscribir una función que reciba una lista y un número \\(n\\). Para dicho número \\(n\\), debe imprimir los últimos \\(n\\) elementos de la lista en orden inverso, y luego devolver la lista sin ellos. Ejemplo: Si se recibe [1, 2, 3, 4, 5] y n = 2, debe imprimir 5, 4 y devolver [1, 2, 3].\nEscribir una función que reciba una lista de números y devuelva la misma lista en orden inverso.\nEscribir una función que dado un valor \\(n\\), devuelva una lista con los números del 1 a \\(n\\). Restricción: usar listas por comprensión.\nEscribir una función que devuelva una matriz y una tupla (fila, columna), y devuelva el valor ubicado en esa posición de la matriz. Ejemplo: si se recibe la matriz [[1, 2], [3, 4]] y la tupla (0, 1), debe devolver 2.\nSe tiene una lista de supermercado escrita como string con productos separados por coma: \"pan, arroz, pescado, jugo, fideos,...\".\n\nEscribir una función que reciba la cadena de caracteres de los productos de supermercado y devuelva una lista con cada uno de los productos por separado: ['pan', 'arroz', 'pescado', 'jugo', 'fideos', ...].\nSe tiene además otra cadena de caracteres con los precios de cada producto: \"100, 50, 200, 80, 30,...\". Escribir una función que reciba ambas cadenas y devuelva una lista con tuplas de (producto, precio): [('pan', 100), ('arroz', 50), ('pescado', 200), ('jugo', 80), ('fideos', 30), ...].\nPara la función del punto anterior, escribir otra función que reciba la lista de tuplas y devuelva el precio total de la lista de compras.\n\nSe quiere crear una lista de supermercado, solicitándole al usuario productos hasta que ingrese el valor ‘X’. La función debe devolver los productos en un string, separados por comas. Ejemplo: si se ingresa ‘pan’, ‘arroz’, ‘pescado’, ‘X’, debe devolver \"pan, arroz, pescado\".\nHacer una función que reciba una lista de palabras, las ordene en orden alfabético y luego las una en un string separadas por espacios. Ejemplo: si recibe ['hola', 'como', 'estas'], debe devolver \"como estas hola\".\nDesafio (obligatorio): Escribir una función que reciba un tamaño y devuelva una matriz con 1 en la diagonal principal y 0 en el resto. Ejemplo: si recibe 4, debe devolver la matriz identidad de tamaño 4x4. \\[\n\\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n\\end{bmatrix}\n\\]\nDesafio (obligatorio): Escribir una función que reciba una matriz y devuelva su transpuesta. Ejemplo: si recibe la matriz [[1, 2, 3], [4, 5, 6]], debe devolver [[1, 4], [2, 5], [3, 6]].\nSi se recibe: \\[\n\\begin{bmatrix}\n1 & 2 & 3  \\\\\n4 & 5 & 6  \\\\\n\\end{bmatrix}\n\\]\nSe debe devolver:\n\\[\n\\begin{bmatrix}\n1 & 4 \\\\\n2 & 5 \\\\\n3 & 6 \\\\\n\\end{bmatrix}\n\\]\nDesafio (no obligatorio): Agenda Simplificada\nEscribir una función que reciba una cadena a buscar y una lista de tuplas (nombre_completo, telefono), y busque dentro de la lista todas las entradas que contengan en el nombre completo la cadena recibida (puede ser el nombre, el apellido o sólo una parte de cualquiera de ellos). Debe devolver una lista con todas las tuplas encontradas.\nDesafio (no obligatorio): Sistema de facturación simplificado.\nSe cuenta con una lista ordenada de productos con tuplas de (identificador, descripción, precio), y una lista de los productos a facturar, con tuplas de (identificador, cantidad).\nSe desea generar una factura que incluya la cantidad, la descripción, el precio unitario y el precio total de cada producto comprado, y al final imprima el total general.\nEscribir una función que reciba ambas listas e imprima por pantalla la factura solicitada.\nSuper Desafio (no obligatorio): Batalla Naval\n\nSe tiene una matriz de 10x10 que representa un tablero. Cada celda contiene un 0 si está vacía, o un 1 si hay un barco (consideramos que en este caso, sólo hay barcos unitarios que ocupan un espacio).\nLa posición de los barcos se representa con tuplas de (fila, columna). Por ejemplo, si se tiene un barco en la fila 1, columna 3, se representa con la tupla (1, 3).\nEscribir una función que cree un tablero con 10 barcos ubicados aleatoriamente (usar la libreria random), y que permita al usuario intentar adivinar dónde están.\nEl usuario luego ingresa una posición, y la máquina indica si había un barco en esa posición (mostrando un mensaje por pantalla “¡Hundido!”) o no (“¡Agua!”).\nEl usuario gana cuando hunde todos los barcos del tablero. Si se equivoca más de 5 veces, pierde.\n\n\n\n\n\n\nBatalla Naval: Modo Supervivencia\n\n\n\n\n\n¿Te animás a que el juego sea un ida y vuelta? Es decir, que el usuario también pueda poner barcos y la máquina intente adivinar dónde están. Una posibilidad es que el usuario tenga su propio tablero en un papel, y una vez cada uno, la máquina y el usuario elijan una posición para atacar.\nTe dejamos unos tips:\n\nLas posiciones son limitadas por el tablero 10x10\nLas posiciones no deberían repetirse\n\n¿Se te ocurre una forma fácil de generar y guardar todas las posiciones posibles del tablero, e ir sacando de a una para que no se repitan? ¿Quién pensás que ganaría, la máquina o el usuario? En este caso, el usuario y la máquina tienen intentos ilimitados intercalados hasta que alguno de los dos gane.\n\n\n\n\n\n\nDiccionarios\n\nEscribir una función que reciba una lista de tuplas, y que devuelva un diccionario en donde las claves sean los primeros elementos de las tuplas, y los valores una lista con los segundos. Por ejemplo:\n\nl = [('Hola', 'don Pepito'), ('Hola', 'don Jose'), ('Buenos', 'días')]\nprint(tuplas_a_diccionario(l))\n{'Hola': ['don Pepito', 'don Jose'], 'Buenos': ['días']}\n\nEscriba una función que reciba una cadena y devuelva:\n\nUn diccionario con la cantidad de apariciones de cada palabra en la cadena. Por ejemplo, si recibe \"Qué lindo día que hace hoy\" debe devolver: {'qué': 2, 'lindo': 1, 'día': 1, 'hace': 1, 'hoy': 1}.\nUn diccionario con la cantidad de apariciones de cada caracter en la cadena.\n\nEscribir una función que reciba una cantidad de iteraciones N.\n\nSe deberá simular una persona que tira un dado N veces, y se deberá devolver un diccionario con la cantidad de apariciones de cada valor en el dado. Nota: para simular una tirada, usar import randomy random.randint(1, 6).\nRepetir el punto anterior, si ahora en vez de tirar 1 dado, tira 2. Se debe devolver un diccionario con la cantidad de apariciones de cada valor de la suma de ambos dados.\n\nEscribir un programa que le pida al usuario que ingrese nombres.\n\nSi el nombre se encuentra en la agenda, debe mostrar el teléfono.\nSi el nombre no se encuentra, debe permitir ingresar el teléfono correspondiente.\n\nEn ambos casos, El usuario puede utilizar la palabra “EXIT” para dejar de ingresar nombres.\nEscribir una función que reciba un texto y para cada caracter presente en el texto, devuelva la palabra más larga en la que se encuentra ese caracter.\nNos contratan para hacer un nuevo sistema de FIUBA para almacenar información de sus estudiantes:\n\n\n\nnombre\napellido\ndni\ncarrera\n\n\n\n\nVioleta\nPerez\n42000000\nInformática\n\n\nCarla\nGuanca\n42001001\nMecánica\n\n\nManuela\nGomez\n42002002\nQuímica\n\n\n\n\nCrear un diccionario que sirva para representar a cada persona. Debe contener las claves nombre, apellido, dni y carrera. Los diccionarios se deben guardan en una lista llamada estudiantes.\nAgregar al diccionario creado un nuevo elemento, que debe ser otro diccionario y represente las notas obtenidas en la carrera. La clave debe ser el codigo y el valor la nota (del 1 al 10) obtenida.\nAgregar para la estudiante Violeta Perez la nota 7 en la materia Algoritmos y Programación III (7507), y la nota 4 en la materia Análisis Matemático II (6103).\nTeniendo la lista de estudiantes, buscar en la lista la persona con mayor cantidad de notas e imprimirla por pantalla.\n\nEn un vivero se guardan las plantas en una lista de diccionarios con la siguiente información: especia, luz directa (si/no), precio. Se necesita un sistema que guarde las plantas a medida que van llegando. Hacer una función que reciba la lista de diccionarios de plantas, y los datos de la planta nueva, y agregue esa planta a la lista de diccionarios.\nEscribir una función que reciba una lista de diccionarios y una clave, y devuelva una lista con los valores correspondientes a esa clave.\nSe tiene un ticket de supermercado en forma de diccionario con los siguientes datos:\n\nNombre del Producto\nPrecio por Unidad\nCantidad\n\nSe pide hacer una función que reciba el ticket y devuelva el monto a pagar total.\nRosita tiene una lista de diccionarios donde guarda todas las películas que vió. La información para cada una es: el nombre de la serie, año en que salió, y la puntuación que le puso del 1 al 10. Hacer una función que reciba el diccionario y devuelva una nueva lista de diccionarios donde sólo estén las películas que tienen puntaje mayor a 7.\n\nResolver sin usar filter\nResolver usando filter.\n\nLa profesora Llamel guarda las notas del parcial de Pensamiento Computacional en una lista de diccionarios. Cada diccionario tiene la siguiente información: nombre, apellido, intento, nota.\nLos intentos pueden ser 1 (si es la primera vez que rinde el parcial) o 2 (si está en el recuperatorio).\n\nSe pide haecr una funciónq ue dada esta lista de diccionarios, se devuelva el promedio de las notas en la primera oportunidad que rindieron los alumnos.\nGeneralizar la función anterior, para que también reciba el número de intento y se pueda devolver el promedio de cualquiera de los dos intentos.\n\nEn una fábrica se tiene una base de datos donde se guardan todos los códigos de los productos que se fabrican como claves de un diccionario. Los valores de cada clave son nuevos diccionarios, con la siguiente información: fecha de vencimiento (mes,año), si pasó el chequeo de calidad o no.\nSe pude hacer una función que reciba esta lista de diccinoarios, y elimine a todos los productos que no pasaron el chequeo de calidad. Devolver en una tuple todos los productos eliminados en formato {codigo: diccionario del producto}.\nSe quiere guardar información de un grupo de maratonistas. Se necesita guardar su nombre, DNI y todas las maratones que corrió. Para esto último, se guardan: nombre de cada una, año, puesto y el tiempo que tardaron en correrlas (en minutos).\n\nCrear un diccionario de ejemplo que represente esta situación.\nTeniendo esta lista de diccionarios, ordenarlos alfabéticamente por el nombre de los maratonistas.\nTeniendo esta lista de diccionarios, ordenar las maratones en tiempo ascendente según el tiempo que tardaron en correrlas.\n\nDesafío (obligatorio): Laura tiene una lista de diccionarios donde guarda el valor de todas las reviews laborales anuales que le hicieron. La información de cada una es año, seniority en ese momento (trainee, junior, semisenior, senior), el sueldo en ese momento y el valor del bono de performance que le dieron. La semana pasada le avisaron que por políticas de la empresa, los bonos ahora deben calcularse como un porcentaje de su sueldo.\nLaura quiere entonces actualizar sus diccionarios, para que en vez de guardar el monto exacto del bono, guarde el porcentaje que le corresponde. Ejemplo: si en el 2019 su sueldo era de $1.000.000 y el bono que le dieron era de $40.000, el bono fue del 4% del sueldo.\n\nHacer una función que reciba la lista de diccionarios, y para cada una de las reviews, modifique el valor del bono por el porcentaje correspondiente.\nHacer una función que reciba la lista de diccionarios ya modificada y devuelva los años en los que Laura tuvo un bono mayor al 50% de su sueldo. Restricción: usar filter y map.\n\nDesafío (no obligatorio): Donarg (https://www.donarg.com.ar/) es un proyecto que nació con estudiantes de FIUBA con el fin de optimizar procesos tanto para donantes de sangre como para hospitales y servicios de hemoterapia. Formado por estudiantes y graduados universitarios comprometidos, fue galardonado con el primer puesto en la FIUBATON 2020 “Desafío Cuarentena” del FIUBA Consulting Club, destacándose entre más de 100 proyectos.\nDonarg necesita un sistema que permita filtrar una base de datos de posibles donantes de sangre, quedándose con los que cumplen los requisitos.\nLa base contiene los siguientes datos de cada posible donante:\n\nNombre\nApellido\nEdad\nPeso\nFecha de la última donación. Puede ser ‘None’ si nunca donó. Formato: (dia,mes,año)\nFecha del último tatuaje. Puede ser ‘None’ si no tiene tatuajes. Formato: (dia,mes,año)\nTipo de sangre. Puede ser ‘0+’, ‘0-’, ‘A+’, ‘A-’, ‘B+’, ‘B-’, ‘AB+’, ‘AB-’\n\nLos requisitos son:\n\nTener entre 16 y 65 años\nPesar más de 50 kilos\nQue hayan pasado 2 meses desde la última donación\nQue hayan pasado 6 meses desde el último tatuaje\n\n\nSe pide hacer una función que reciba una lista de diccionarios con la información de cada posible donante, y devuelva una lista con los que cumplen los requisitos.\nSe pide hacer una función que priorice a los donantes que tienen sangre tipo 0 (positivo y negativo) por sobre todos los A, B y AB (positivos y negativos); ya que son los que más se necesitan. La función debe recibir la lista de diccionarios con la información de cada posible donante ya filtrada por requisitos, y devolver una nueva lista ordenados de mayor a menor prioridad.\nSe pide hacer una función que reciba la lista de diccionarios con la información de cada posible donante ya filtrada por requisitos y ordenada por prioridad, que se quede con los que son 0+ y 0-, y los ordene por órden alfabético de apellido.\n\n\n\nSi querés saber más sobre el proyecto, podés visitar su página web:\nhttps://www.donarg.com.ar/\no sacar turno para donar sangre en\nhttps://www.donarg.com.ar/dondedono."
  }
]